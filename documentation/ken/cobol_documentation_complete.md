# COBOL System Documentation

*Generated: 2025-09-24 07:40:22*

This document contains complete documentation for 267 COBOL programs, including both business/functional perspectives and technical/migration perspectives.

## Table of Contents

1. [ACAS](#acas)
2. [acas000](#acas000)
3. [acas004](#acas004)
4. [acas005](#acas005)
5. [acas006](#acas006)
6. [acas007](#acas007)
7. [acas008](#acas008)
8. [acas010](#acas010)
9. [acas011](#acas011)
10. [acas012](#acas012)
11. [acas013](#acas013)
12. [acas014](#acas014)
13. [acas015](#acas015)
14. [acas016](#acas016)
15. [acas017](#acas017)
16. [acas019](#acas019)
17. [acas022](#acas022)
18. [acas023](#acas023)
19. [acas026](#acas026)
20. [acas029](#acas029)
21. [acas030](#acas030)
22. [acas032](#acas032)
23. [acasconvert1](#acasconvert1)
24. [acasconvert2](#acasconvert2)
25. [acasconvert3](#acasconvert3)
26. [acas-get-params](#acas-get-params)
27. [acasirsub1](#acasirsub1)
28. [acasirsub3](#acasirsub3)
29. [acasirsub4](#acasirsub4)
30. [acasirsub5](#acasirsub5)
31. [ACAS-Sysout](#acas-sysout)
32. [acas-test-takeon-1](#acas-test-takeon-1)
33. [acas-test-takeon-2](#acas-test-takeon-2)
34. [analLD](#analld)
35. [analMT](#analmt)
36. [analRES](#analres)
37. [analUNL](#analunl)
38. [auditLD](#auditld)
39. [auditLD2](#auditld2)
40. [auditMT](#auditmt)
41. [auditRES](#auditres)
42. [auditUNL](#auditunl)
43. [cbl_oc_dump](#cbl-oc-dump)
44. [cobdump](#cobdump)
45. [delfolioLD](#delfoliold)
46. [delfolioMT](#delfoliomt)
47. [delfolioRES](#delfoliores)
48. [delfolioUNL](#delfoliounl)
49. [deliveryLD](#deliveryld)
50. [deliveryMT](#deliverymt)
51. [deliveryRES](#deliveryres)
52. [deliveryUNL](#deliveryunl)
53. [dfltLD](#dfltld)
54. [dfltMT](#dfltmt)
55. [dummy-rdbmsMT](#dummy-rdbmsmt)
56. [fhlogger](#fhlogger)
57. [finalLD](#finalld)
58. [finalMT](#finalmt)
59. [general](#general)
60. [gl000](#gl000)
61. [gl020](#gl020)
62. [gl030](#gl030)
63. [gl050](#gl050)
64. [gl051](#gl051)
65. [gl060](#gl060)
66. [gl070](#gl070)
67. [gl071](#gl071)
68. [gl072](#gl072)
69. [gl080](#gl080)
70. [gl090](#gl090)
71. [gl090a](#gl090a)
72. [gl090b](#gl090b)
73. [gl100](#gl100)
74. [gl105](#gl105)
75. [gl120](#gl120)
76. [glbatchLD](#glbatchld)
77. [glbatchMT](#glbatchmt)
78. [glbatchRES](#glbatchres)
79. [glbatchUNL](#glbatchunl)
80. [glpostingLD](#glpostingld)
81. [glpostingMT](#glpostingmt)
82. [glpostingRES](#glpostingres)
83. [glpostingUNL](#glpostingunl)
84. [irs](#irs)
85. [irs000](#irs000)
86. [irs010](#irs010)
87. [irs020](#irs020)
88. [irs030](#irs030)
89. [irs040](#irs040)
90. [irs050](#irs050)
91. [irs055](#irs055)
92. [irs060](#irs060)
93. [irs065](#irs065)
94. [irs070](#irs070)
95. [irs080](#irs080)
96. [irs085](#irs085)
97. [irs090](#irs090)
98. [irsdfltLD](#irsdfltld)
99. [irsdfltMT](#irsdfltmt)
100. [irsdfltRES](#irsdfltres)
101. [irsdfltUNL](#irsdfltunl)
102. [irsfinalLD](#irsfinalld)
103. [irsfinalMT](#irsfinalmt)
104. [irsfinalRES](#irsfinalres)
105. [irsfinalUNL](#irsfinalunl)
106. [irsnominalLD](#irsnominalld)
107. [irsnominalMT](#irsnominalmt)
108. [irsnominalRES](#irsnominalres)
109. [irsnominalUNL](#irsnominalunl)
110. [irsnominalUNL2](#irsnominalunl2)
111. [irspostingLD](#irspostingld)
112. [irspostingMT](#irspostingmt)
113. [irspostingRES](#irspostingres)
114. [irspostingUNL](#irspostingunl)
115. [irsubp](#irsubp)
116. [makesqltable-free](#makesqltable-free)
117. [makesqltable-original](#makesqltable-original)
118. [maps01](#maps01)
119. [maps04](#maps04)
120. [maps09](#maps09)
121. [nominalLD](#nominalld)
122. [nominalMT](#nominalmt)
123. [nominalRES](#nominalres)
124. [nominalUNL](#nominalunl)
125. [otm3LD](#otm3ld)
126. [otm3MT](#otm3mt)
127. [otm3RES](#otm3res)
128. [otm3UNL](#otm3unl)
129. [otm5LD](#otm5ld)
130. [otm5MT](#otm5mt)
131. [otm5RES](#otm5res)
132. [otm5UNL](#otm5unl)
133. [paymentsLD](#paymentsld)
134. [paymentsMT](#paymentsmt)
135. [paymentsRES](#paymentsres)
136. [paymentsUNL](#paymentsunl)
137. [pl000](#pl000)
138. [pl010](#pl010)
139. [pl015](#pl015)
140. [pl020](#pl020)
141. [pl025](#pl025)
142. [pl030](#pl030)
143. [pl040](#pl040)
144. [pl050](#pl050)
145. [pl055](#pl055)
146. [pl060](#pl060)
147. [pl070](#pl070)
148. [pl080](#pl080)
149. [pl085](#pl085)
150. [pl090](#pl090)
151. [pl095](#pl095)
152. [pl100](#pl100)
153. [pl115](#pl115)
154. [pl120](#pl120)
155. [pl130](#pl130)
156. [pl140](#pl140)
157. [pl160](#pl160)
158. [pl165](#pl165)
159. [pl170](#pl170)
160. [pl180](#pl180)
161. [pl190](#pl190)
162. [pl800](#pl800)
163. [pl900](#pl900)
164. [pl910](#pl910)
165. [pl920](#pl920)
166. [pl930](#pl930)
167. [pl940](#pl940)
168. [pl950](#pl950)
169. [pl960](#pl960)
170. [plautogenLD](#plautogenld)
171. [plautogenMT](#plautogenmt)
172. [plautogenRES](#plautogenres)
173. [plautogenUNL](#plautogenunl)
174. [plinvoiceLD](#plinvoiceld)
175. [plinvoiceMT](#plinvoicemt)
176. [plinvoiceRES](#plinvoiceres)
177. [plinvoiceUNL](#plinvoiceunl)
178. [purchase](#purchase)
179. [purchLD](#purchld)
180. [purchMT](#purchmt)
181. [purchRES](#purchres)
182. [purchUNL](#purchunl)
183. [sales](#sales)
184. [salesLD](#salesld)
185. [salesMT](#salesmt)
186. [salesRES](#salesres)
187. [salesUNL](#salesunl)
188. [send-mail-test-example](#send-mail-test-example)
189. [send-some-mail](#send-some-mail)
190. [send-some-mail2](#send-some-mail2)
191. [sl000](#sl000)
192. [sl010](#sl010)
193. [sl020](#sl020)
194. [sl050](#sl050)
195. [sl055](#sl055)
196. [sl060](#sl060)
197. [sl070](#sl070)
198. [sl080](#sl080)
199. [sl085](#sl085)
200. [sl090](#sl090)
201. [sl095](#sl095)
202. [sl100](#sl100)
203. [sl110](#sl110)
204. [sl115](#sl115)
205. [sl120](#sl120)
206. [sl130](#sl130)
207. [sl140](#sl140)
208. [sl160](#sl160)
209. [sl165](#sl165)
210. [sl170](#sl170)
211. [sl180](#sl180)
212. [sl200](#sl200)
213. [sl800](#sl800)
214. [sl810](#sl810)
215. [sl820](#sl820)
216. [sl830](#sl830)
217. [sl900](#sl900)
218. [sl910](#sl910)
219. [sl920](#sl920)
220. [sl930](#sl930)
221. [sl940](#sl940)
222. [sl950](#sl950)
223. [sl960](#sl960)
224. [sl970](#sl970)
225. [slautogenLD](#slautogenld)
226. [slautogenMT](#slautogenmt)
227. [slautogenRES](#slautogenres)
228. [slautogenUNL](#slautogenunl)
229. [sldelinvnosLD](#sldelinvnosld)
230. [sldelinvnosMT](#sldelinvnosmt)
231. [sldelinvnosRES](#sldelinvnosres)
232. [sldelinvnosUNL](#sldelinvnosunl)
233. [slinvoiceLD](#slinvoiceld)
234. [slinvoiceMT](#slinvoicemt)
235. [slinvoiceRES](#slinvoiceres)
236. [slinvoiceUNL](#slinvoiceunl)
237. [slpostingLD](#slpostingld)
238. [slpostingMT](#slpostingmt)
239. [slpostingRES](#slpostingres)
240. [slpostingUNL](#slpostingunl)
241. [st000](#st000)
242. [st010](#st010)
243. [st020](#st020)
244. [st030](#st030)
245. [st040](#st040)
246. [st050](#st050)
247. [st060](#st060)
248. [stock](#stock)
249. [stockconvert2](#stockconvert2)
250. [stockconvert3](#stockconvert3)
251. [stockLD](#stockld)
252. [stockMT](#stockmt)
253. [stockRES](#stockres)
254. [stockUNL](#stockunl)
255. [sys002](#sys002)
256. [sys4LD](#sys4ld)
257. [sys4MT](#sys4mt)
258. [systemLD](#systemld)
259. [systemMT](#systemmt)
260. [systemRES](#systemres)
261. [systemUNL](#systemunl)
262. [valueLD](#valueld)
263. [valueMT](#valuemt)
264. [valueRES](#valueres)
265. [valueUNL](#valueunl)
266. [xl150](#xl150)
267. [xl160](#xl160)

---
## ACAS
*[1/267]*

### Business/Functional Perspective
### ACAS System Menu  

---

#### Program Purpose  
The ACAS menu program presents a single entry point for users to launch the various accounting modules of the Applewood Computers Accounting System. From this screen a user can open the Nominal Ledger (IRS), General Ledger, Sales Ledger, Purchase Ledger, Stock Control, run system setup routines, or exit back to the operating system. The program ensures that the terminal is large enough for the menu, validates required environment settings, and directs the request to the appropriate subsystem, providing a consistent and secure start‑up experience for all users.  

---

#### Screen Interactions  
1. **Menu Title** – “ACAS System Menu” displayed at the top of the screen.  
2. **Date and Time** – Current system date and, if available, the current time are shown below the title.  
3. **Prompt** – “Select one of the following by letter  :- [ ]” appears, inviting the user to press a letter key.  
4. **Options**  
   - **(A)** Nominal Ledger (IRS)  
   - **(B)** Sales Ledger  
   - **(C)** Purchase Ledger  
   - **(D)** General Ledger  
   - **(E)** Stock Control  
   - **(X)** Exit To system  
   - **(Z)** System Setup  
5. The screen clears and re‑displays the menu if an invalid key is entered.  

---

#### Messages and Errors  
- **Terminal Size Error** – If the terminal has fewer than 24 lines or 80 columns, a message informs the user that the terminal is too small and prompts for a key press before re‑checking.  
- **Environment Setup Error** – If required environment variables are missing, a brief notice is shown, and the program waits for a key press before aborting.  
- **File Access Error** – If the system parameter file cannot be opened or read, the program displays a concise error notice and terminates.  
- **System Processing Error** – Should an internal system routine return a failure code, the program presents a generic “System processing error” message and exits.  

---

#### User Flow Summary  
1. The user starts the ACAS program from the operating system.  
2. The program verifies terminal dimensions and required environment variables.  
3. The menu screen is displayed, showing the current date and optional time.  
4. The user presses a letter key corresponding to the desired subsystem (A, B, C, D, E, X, or Z).  
5. The program calls the selected subsystem program (e.g., “irs” for A, “sales” for B).  
6. The subsystem interface takes over; when the user finishes, control returns to the ACAS menu.  
7. The user may choose another option, run system setup, or press X to exit the ACAS program back to the operating system.  

---

#### Program Linkages  
- sys002  
- sl070  
- acas000  
- maps04  
- general  
- sales  
- purchase  
- stock  
- irs

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program starts in **ACAS-Main**, sets screen exception flags, obtains terminal dimensions, and performs program argument parsing. [Seen in: ACAS-Main.]  
It opens the system parameter file via **System-Open-Input**, checks for errors, and if the system has never been initialized, invokes **sys002** and **sl070** to create necessary tables. [Seen in: Open-System, System-Open-Input, System-Check-4-Errors, call-system-setup.]  
After initialization, the menu is displayed and the user’s letter choice is accepted; the choice dispatches to the appropriate subsystem via **load-it** and **loadXX** paragraphs, or to system setup or exit. [Seen in: Display-Menu, accept-loop, load-it.]

5.2 Initialization  
The program sets COBOL screen exception flags, reads terminal line and column counts, and loops until minimum 24 lines and 80 columns are satisfied. [Seen in: Get-Term-Settings.]  
It calls **zz020-Get-Program-Args** to capture up to two command line arguments into Arg-Vals. [Seen in: zz020-Get-Program-Args.]  
The system parameter file is opened with **System-Open-Input**, and any file errors trigger **System-Check-4-Errors** which may abort the program. [Seen in: System-Open-Input, System-Check-4-Errors.]

5.3 Core Processing  
Path: System Setup  
Trigger: `scycle = 0` after **System-Read-Indexed** or user selects menu letter 'Z'.  
Key steps: call **sys002** via **call-system-setup**, then **Open-System**.  
I/O: system files, **sys002**.  
Outcomes: system parameters are initialized, `ws-term-code` may be set.  
[Seen in: call-system-setup, Open-System.]

Path: First‑Time System Initialization  
Trigger: `fs-reply` not zero after **System-Open-Input**.  
Key steps: call **sys002**, then call **sl070** to create value and analysis tables.  
I/O: system files, **sl070**.  
Outcomes: tables created, `ws-term-code` set.  
[Seen in: System-Open-Input, System-Check-4-Errors, call-system-setup, load00.]

Path: Menu Dispatch  
Trigger: user selects a letter in the menu.  
Key steps: **accept-loop** reads `menu-reply`, searches `letters`, sets `z`, then **load-it** dispatches to **load00** and the appropriate **loadXX** paragraph.  
I/O: screen, subsystem programs via `ws-called`.  
Outcomes: `ws-term-code` set, program may exit or return to menu.  
[Seen in: accept-loop, load-it, load00.]

Path: System-Open-Input  
Trigger: **Open-System**.  
Key steps: set `fn-open` true, `fn-input` true, perform **acas000**, then **System-Check-4-Errors**.  
I/O: system parameter file.  
Outcomes: `fs-reply` set, error handling may occur.  
[Seen in: System-Open-Input, System-Check-4-Errors.]

Path: System-Check-4-Errors  
Trigger: after any **acas000** call.  
Key steps: if `fs-reply` not zero, display `SY011`, close system, go to **Open-Error-Continued**.  
I/O: display, accept.  
Outcomes: may abort program with error status.  
[Seen in: System-Check-4-Errors, Open-Error-Continued.]

5.4 Termination  
The program exits via **overclose** which performs a `GOBACK`, or via **main-exit** which stops the run. [Seen in: overclose, main-exit.]  
Before exiting, any open system files are closed by **System-Close** and the terminal environment is left unchanged. [Seen in: System-Close.]

---
## acas000
*[2/267]*

### Business/Functional Perspective
### System File Handler  

**Program Purpose**  
The program manages the central system file that stores configuration and status information for the ACAS system. It provides a single point of access for opening, closing, reading, writing, or updating the file, or for performing the same actions in the database. By ensuring that these operations are performed correctly and consistently, the program protects critical configuration data, supports audit trails, and reduces the risk of data corruption.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **File access errors** – problems opening, closing, reading, writing or rewriting the file (e.g., file already open, file not found, or write failure).  
- **Invalid operation or key** – unsupported function code or key number outside the allowed range.  
- **Record size mismatch** – the size of the data record supplied does not match the expected size, halting the operation.  
- **Database errors** – issues connecting to the database, executing a query, or updating a record.  
- **Duplicate processing or duplicate file open** – messages logged when a duplicate operation is detected.  
- **General system errors** – any other unforeseen problems that prevent the operation from completing.  

**User Flow Summary**  
The calling routine tells the program what action to perform (open, close, read, write, or rewrite) and, when required, which record key to target. The program validates the request, checks that the file or database is ready, and then carries out the action. On success the file or database is updated and a normal status is returned. If an error occurs, the program logs the issue and returns a failure status, allowing the caller to handle the problem or inform the user.  

**Program Linkages**  
- systemMT  
- dfltMT  
- finalMT  
- sys4MT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs at aa010-main, which initializes logging and validates key ranges for indexed operations. [Seen in: aa010-main.]  
If the FA-RDBMS-Flat-Statuses flag is set to “66”, the routine delegates to ba-Process-RDBMS to perform database access before returning. [Seen in: aa010-main.]  
Otherwise the routine evaluates File-Function to dispatch to one of the flat-file operations (open, close, read-indexed, write, rewrite) or to an error handler, then performs cleanup and exits. [Seen in: aa010-main.]

5.2 Initialization  
The program clears the logging parameters WS-Log-System and WS-Log-File-No, and sets the initial record size test variables A and B to zero. [Seen in: aa010-main.]  
It then verifies that File-Key-No is within 1–4 for indexed functions, setting WE-Error 998 and FS-Reply 99 if out of range. [Seen in: aa010-main.]

5.3 Core Processing  
Path: RDBMS Processing  
Trigger: FA-RDBMS-Flat-Statuses = “66” in aa010-main.  
Key steps: perform ba012-Test-WS-Rec-Size-2, load DB connection parameters from System-Record, evaluate File-Key-No to call the appropriate DAL (systemMT, dfltMT, finalMT, sys4MT) with File-Access and ACAS-DAL-Common-data.  
I/O: calls to DAL modules (systemMT, dfltMT, finalMT, sys4MT).  
Outcomes: sets WE-Error and FS-Reply based on DAL return; exits section.  
[Seen in: aa010-main, ba012-Test-WS-Rec-Size-2, ba015-Test-Ends.]

Path: Open  
Trigger: File-Function = 1 in aa010-main.  
Key steps: set WS-File-Key, WS-No-Paragraph, zero FS-Reply WE-Error, check Cobol-File-Status; if not open, open input, i‑o, output or extend based on fn-input, fn-i-o, fn-output, fn-extend; set Cobol-File-Status to 1; set WE-Error if fs-reply non‑zero.  
I/O: open System-File.  
Outcomes: FS-Reply and WE-Error reflect open status; Cobol-File-Status set to 1.  
[Seen in: aa020-Process-Open.]

Path: Read-Indexed  
Trigger: File-Function = 4 in aa010-main.  
Key steps: set WS-No-Paragraph, set rrn to File-Key-No, build WS-File-Key string, zero FS-Reply WE-Error, read System-File record into WS-System-Record.  
I/O: read System-File.  
Outcomes: FS-Reply and WE-Error set by read; WS-System-Record contains data.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Write  
Trigger: File-Function = 5 in aa010-main.  
Key steps: set WS-No-Paragraph, zero FS-Reply WE-Error, build WS-File-Key string, set rrn to File-Key-No, write System-Record from WS-System-Record.  
I/O: write System-File.  
Outcomes: FS-Reply and WE-Error set by write.  
[Seen in: aa070-Process-Write.]

Path: Bad-Function  
Trigger: File-Function other than 1,2,4,5,7 in aa010-main.  
Key steps: set WE-Error 999, FS-Reply 99.  
I/O: none.  
Outcomes: error status.  
[Seen in: aa100-Bad-Function.]

5.4 Termination  
After processing, aa999-main-exit performs logging if Testing-1 is set, then control returns to aa-main-exit which calls Ca-Process-Logs if needed and then aa-Exit to exit program. [Seen in: aa999-main-exit, aa-main-exit, aa-Exit.]  
The program exits with exit program, leaving FS-Reply and WE-Error set to indicate the result of the last operation. [Seen in: aa-Exit.]

---
## acas004
*[3/267]*

### Business/Functional Perspective
### Recurring Sales Invoice File Handler  

**Program Purpose**  
The program manages the storage and retrieval of recurring sales invoice data. It supports opening and closing the file, reading records sequentially or by key, writing new records, updating existing ones, and deleting records. The system validates keys and record lengths, logs all operations, and forwards database requests to a dedicated data‑access layer, ensuring data integrity and audit‑ready activity for the invoicing subsystem.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – Operation completed with no error.  
- **End of File** – No more records to read.  
- **Key Not Found** – The requested record does not exist or the key is invalid.  
- **Duplicate or Invalid Key Type** – The key number supplied is outside the valid range for the requested operation.  
- **Access‑Type Error** – The file access method is not supported for the operation.  
- **File‑Open/Close Error** – The file could not be opened or closed.  
- **Record‑Length Mismatch** – The size of the supplied record does not match the defined record structure.  
- **Database Error** – An error occurred while communicating with the database layer (e.g., connection or SQL error).  
- **Unknown Error** – Any other error condition that prevents the operation from completing.  

**User Flow Summary**  
When the invoicing system needs to add, retrieve, update, or delete a recurring sales invoice record, it calls this handler and supplies the desired file function (open, close, read, write, etc.), the key information, and the record data if applicable. The program checks that the key and access type are appropriate, then performs the file operation or forwards the request to the database access layer. After the operation, it returns a status code and, for reads, the requested record and key. All actions are logged for audit purposes. In case of an error, a clear message is provided to the calling program, which can then inform the user or take corrective action.  

**Program Linkages**  
- slautogenMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry begins at aa010‑main which initializes logging and validates key parameters. [Seen in: aa010‑main.]  
It then determines whether to process a COBOL flat file or delegate to the RDBMS layer; if FS‑Cobol‑Files‑Used is false, ba‑Process‑RDBMS is invoked and the program exits. [Seen in: aa010‑main.]  
For flat file processing, aa010‑main performs a record‑size check, sets up file paths, and dispatches to the appropriate aa0xx paragraph based on File‑Function. [Seen in: aa010‑main.]  
Each aa0xx paragraph handles a specific file operation (open, close, read, write, delete, rewrite, start) and terminates by performing aa999‑main‑exit, which logs if testing is enabled and then returns control to aa‑main‑exit. [Seen in: aa020‑Process‑Open, aa030‑Process‑Close, aa040‑Process‑Read‑Next, aa050‑Process‑Read‑Indexed, aa060‑Process‑Start, aa070‑Process‑Write, aa080‑Process‑Delete, aa090‑Process‑Rewrite, aa999‑main‑exit.]

5.2 Initialization  
aa010‑main sets logging parameters WS‑Log‑System and WS‑Log‑File‑No, then validates File‑Key‑No for read‑indexed, start, and delete functions, setting error codes and exiting if out of range. [Seen in: aa010‑main.]  
If FS‑Cobol‑Files‑Used is false, the program calls ba‑Process‑RDBMS to handle database access and then exits via aa999‑main‑exit. [Seen in: aa010‑main, ba‑Process‑RDBMS.]  
The program performs ba012‑Test‑WS‑Rec‑Size‑2 to ensure the working‑storage record length matches the file record length, initializing DB connection parameters if the lengths are compatible. [Seen in: aa010‑main, ba012‑Test‑WS‑Rec‑Size‑2.]  
It then clears SQL error fields and evaluates File‑Function to dispatch to the appropriate processing paragraph. [Seen in: aa010‑main.]

5.3 Core Processing  
Path: Process‑Open  
Trigger: File‑Function = 1 (open)  
Key steps: set WS‑File‑Key, open Agen‑Invoice‑File in the mode indicated by fn‑input, fn‑i‑o, fn‑output, or fn‑extend; set Cobol‑File‑Status, set WS‑File‑Key to “OPEN SL AUTOGEN File”; set WE‑Error if fs‑reply non‑zero; go to aa999‑main‑exit.  
I/O: Agen‑Invoice‑File  
Outcomes: FS‑Reply set to 0 or error code; WE‑Error set accordingly; WS‑File‑Key set; program exits via aa999‑main‑exit.  
[Seen in: aa020‑Process‑Open.]

Path: Process‑Read‑Next  
Trigger: File‑Function = 34 (read‑next)  
Key steps: check Cobol‑File‑Eof; if EOF set FS‑Reply 10, WE‑Error, clear key, stop; else read next record; if EOF set FS‑Reply 10, WE‑Error, set Cobol‑File‑Status, initialize record, set WS‑File‑Key “EOF”; else move record to WS‑Invoice‑Record, move key to WS‑File‑Key, WE‑Error zero; exit.  
I/O: Agen‑Invoice‑File  
Outcomes: FS‑Reply 0 or 10; WE‑Error 0 or 10; WS‑Invoice‑Record populated; WS‑File‑Key set; program exits via aa999‑main‑exit.  
[Seen in: aa040‑Process‑Read‑Next.]

Path: Process‑Read‑Indexed  
Trigger: File‑Function = 4  
Key steps: evaluate keys; if File‑Key‑No=1 read key; if success move record and key; else initialize record, set WS‑File‑Key “Failed action”; set WE‑Error 21, FS‑Reply 21; if key type out of range set WE‑Error 998, FS‑Reply 99; exit.  
I/O: Agen‑Invoice‑File  
Outcomes: FS‑Reply 0 or 21 or 99; WE‑Error 0 or 21 or 998; WS‑Invoice‑Record populated or empty; WS‑File‑Key set; program exits via aa999‑main‑exit.  
[Seen in: aa050‑Process‑Read‑Indexed.]

Path: Process‑Write  
Trigger: File‑Function = 5  
Key steps: move WS‑Invoice‑Record to file record; write record; if invalid key set FS‑Reply 22; set WE‑Error zero; set WS‑File‑Key to key; exit.  
I/O: Agen‑Invoice‑File  
Outcomes: FS‑Reply 0 or 22; WE‑Error 0; WS‑File‑Key set; program exits via aa999‑main‑exit.  
[Seen in: aa070‑Process‑Write.]

Path: Process‑Delete  
Trigger: File‑Function = 8  
Key steps: move WS‑Invoice‑Record to file record; delete record; if invalid key set FS‑Reply 21; set WE‑Error zero; set WS‑File‑Key to key; exit.  
I/O: Agen‑Invoice‑File  
Outcomes: FS‑Reply 0 or 21; WE‑Error 0; WS‑File‑Key set; program exits via aa999‑main‑exit.  
[Seen in: aa080‑Process‑Delete.]

Path: RDBMS Processing  
Trigger: FS‑Cobol‑Files‑Used = false (database mode)  
Key steps: perform ba012‑Test‑WS‑Rec‑Size‑2 to validate record lengths; set DB connection parameters from system record; call “slautogenMT” with File‑Access, ACAS‑DAL‑Common‑data, WS‑Invoice‑Record; exit section.  
I/O: none (database via DAL)  
Outcomes: WE‑Error may be set by DAL; FS‑Reply unchanged; program exits via aa999‑main‑exit.  
[Seen in: ba‑Process‑RDBMS.]

5.4 Termination  
aa999‑main‑exit performs logging if Testing‑1 is set, then transfers control to aa‑main‑exit. [Seen in: aa999‑main‑exit.]  
aa‑main‑exit calls Ca‑Process‑Logs to close the log file, resets File‑Function and Access‑Type to zero, and then goes to aa‑Exit. [Seen in: aa‑main‑exit, Ca‑Process‑Logs, aa‑Exit.]  
The program terminates by executing aa‑Exit which invokes the COBOL EXIT PROGRAM statement. [Seen in: aa‑Exit.]

---
## acas005
*[4/267]*

### Business/Functional Perspective
### Nominal Ledger File Handler  

**Program Purpose**  
The program manages the General Ledger nominal‑ledger file. It opens, reads, writes, updates, and deletes ledger records, handling both flat files and database tables. By ensuring each operation succeeds or reports a clear error, it maintains accurate ledger data, supports audit trails, and reduces the risk of data corruption.  

**Screen Interactions**  
No persistent screens are displayed during normal processing.  
The only user interaction occurs when the program detects a mismatch between the in‑memory record size and the file record size. In that case it shows a brief error screen containing:  

1. A message that the temporary record size is smaller than the ledger record size.  
2. A prompt: “GL901 Note error and hit return”.  
The program waits for the user to press Enter before terminating the operation.  

**Messages and Errors**  
- **Record size mismatch** – The program alerts the user and pauses for confirmation.  
- **Invalid key or key not found** – The operation fails and returns a status indicating the key was not found.  
- **End of file reached** – Reading beyond the last record returns an end‑of‑file status.  
- **File open/close errors** – If the file cannot be accessed, the program reports a generic error.  
- **Access type or key range errors** – The program rejects operations with improper key numbers or access modes.  
- **Database errors** – If the underlying database cannot process a request, a general database error status is returned.  

**User Flow Summary**  
A higher‑level application supplies the ledger record and the requested function (open, close, read, write, delete, etc.). The program carries out the operation against the flat file or the database, logs the activity, and returns a status code. If the operation succeeds, control is passed back to the caller with no visible message. If an error occurs, a descriptive status is returned; in the specific case of a record‑size mismatch the user sees a short error screen and must press Enter to continue.  

**Program Linkages**  
- nominalMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa010-main which sets up logging and validates key ranges. [Seen in: aa010-main.]  
It then dispatches to the appropriate processing paragraph based on File-Function via evaluate. [Seen in: aa010-main.]  
After performing the requested file operation, control returns to aa-Exit which exits the program. [Seen in: aa-Exit.]

5.2 Initialization  
aa010-main initializes logging variables, checks File-Key-No for start/read-indexed/delete, and performs RDBMS processing if FS-Cobol-Files-Used is false. [Seen in: aa010-main.]  
It then tests record size consistency via ba012-Test-WS-Rec-Size-2 and clears SQL error fields before evaluating File-Function. [Seen in: aa010-main.]

5.3 Core Processing  
Path: Open  
Trigger: File-Function = 1 (fn-open)  
Key steps: set WS-File-Key, open Ledger-File in the requested mode (input, i‑o, output, extend), handle errors, set Cobol-File-Status.  
I/O: Ledger-File.  
Outcomes: FS-Reply set on error, WE-Error set, program exits via aa999-main-exit.  
[Seen in: aa020-Process-Open.]

Path: Read-Next  
Trigger: File-Function = 3 (fn-read-next)  
Key steps: read next record, handle EOF, move Ledger-Record to WS-Ledger-Record, set WS-File-Key, clear errors.  
I/O: Ledger-File.  
Outcomes: FS-Reply 10 on EOF, WE-Error 10, WS-Ledger-Record populated.  
[Seen in: aa040-Process-Read-Next.]

Path: Read-Indexed  
Trigger: File-Function = 4 (fn-read-indexed)  
Key steps: evaluate keys, read Ledger-File by key, handle invalid key, move record to WS-Ledger-Record.  
I/O: Ledger-File.  
Outcomes: FS-Reply 21 on invalid key, WE-Error 255, record returned.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Write  
Trigger: File-Function = 5 (fn-write)  
Key steps: move WS-Ledger-Record to Ledger-Record, write record, handle invalid key.  
I/O: Ledger-File.  
Outcomes: FS-Reply 22 on invalid key, WE-Error unchanged, record written.  
[Seen in: aa070-Process-Write.]

Path: Delete  
Trigger: File-Function = 8 (fn-delete)  
Key steps: set Ledger-Key from WS-Ledger-Key, delete record, handle invalid key.  
I/O: Ledger-File.  
Outcomes: FS-Reply 21 on invalid key, WE-Error unchanged, record deleted.  
[Seen in: aa080-Process-Delete.]

Path: Start  
Trigger: File-Function = 9 (fn-start)  
Key steps: evaluate keys, perform start operations based on access-type (equal, not-less-than, greater-than, less-than), handle invalid key.  
I/O: Ledger-File.  
Outcomes: FS-Reply 21 on invalid key, WE-Error 255, position set.  
[Seen in: aa060-Process-Start.]

5.4 Termination  
After processing, aa-Exit calls exit program. [Seen in: aa-Exit.]  
Logging is performed during aa999-main-exit if Testing-1 is true, then control returns to aa-Exit. [Seen in: aa999-main-exit.]

---
## acas006
*[5/267]*

### Business/Functional Perspective
### GL Posting File Handler  

**Program Purpose**  
The program manages all input‑output operations for General Ledger posting records. It ensures that records are accurately written, updated, read, or deleted in either a flat‑file or database environment. By handling file access, key validation, and error reporting, the system maintains data integrity and supports audit trails for financial postings.

**Screen Interactions**  
No direct screens. This program is invoked by other modules after a data‑entry step and returns status information back to that context.

**Messages and Errors**  
- **Success** – Record operations complete without issue.  
- **End of File** – No more records to read.  
- **Key or Record Not Found** – The specified key does not exist or is invalid.  
- **File Access Issues** – Problems opening, closing, or accessing the posting file.  
- **Invalid Parameters** – Incorrect use of function codes or key values.  
- **Record Size Mismatch** – Internal record length error that stops the operation.  
- **Database Errors** – Failure to connect to or communicate with the underlying RDBMS.  

**User Flow Summary**  
A calling program supplies the posting record data, the desired file operation (open, close, read, write, delete, etc.), and any required key values.  
- For *open* operations the file is prepared for subsequent actions.  
- *Read next* and *read indexed* retrieve the next or a specific record, respectively.  
- *Start* positions the file for a subsequent read.  
- *Write* adds a new record; *rewrite* updates an existing one; *delete* removes a record.  
If the system is configured for database storage, the program forwards the same request to the database access layer, which performs the equivalent operation. After the action, the program returns a status code indicating success or the nature of any error, and logs the activity if logging is enabled.

**Program Linkages**  
- glpostingMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the aa-Process-Flat-File section (aa010-main) where it initializes logging, validates key ranges, and determines whether to perform RDBMS or flat‑file processing. [Seen in: aa010-main.]  
It then evaluates the File‑Function value and dispatches to the appropriate operation paragraph (e.g., aa020‑Process‑Open, aa040‑Process‑Read‑Next, aa070‑Process‑Write, etc.). [Seen in: aa010-main.]  
After the operation completes, control returns to aa‑Exit which terminates the program, optionally logging the result if testing is enabled. [Seen in: aa-Exit.]

5.2 Initialization  
The program sets logging identifiers (WS‑Log‑System, WS‑Log‑File‑No) and checks that the File‑Key‑No is 1 for indexed or delete operations, setting WE‑Error 998 or 996 if not. [Seen in: aa010-main.]  
It performs a record‑size test (ba012‑Test‑WS‑Rec‑Size‑2) to ensure the linkage record matches the file record, initializing RDBMS connection parameters if flat files are not used. [Seen in: ba012-Test-WS-Rec-Size-2.]

5.3 Core Processing  

Path: Open File  
Trigger: File‑Function = 1 (fn‑input, fn‑i‑o, fn‑output, or fn‑extend)  
Key steps: Open the Posting‑File in the requested mode, handle errors by closing and reopening if necessary, and set FS‑Reply and WE‑Error accordingly.  
I/O: Posting‑File (flat file)  
Outcomes: File opened, FS‑Reply set to 0 on success or error code on failure.  
[Seen in: aa020-Process-Open.]

Path: Read‑Next Record  
Trigger: File‑Function = 3 (fn‑read‑next)  
Key steps: Read next record, detect EOF, initialize WS‑Posting‑Record on success, set FS‑Reply and WE‑Error.  
I/O: Posting‑File (flat file)  
Outcomes: WS‑Posting‑Record populated, FS‑Reply 0 or 10 for EOF.  
[Seen in: aa040-Process-Read-Next.]

Path: Write Record  
Trigger: File‑Function = 5 (fn‑write)  
Key steps: Move WS‑Posting‑Record to Posting‑Record, write with invalid‑key handling, set FS‑Reply and WE‑Error.  
I/O: Posting‑File (flat file)  
Outcomes: Record written, FS‑Reply 0 or 22 for invalid key.  
[Seen in: aa070-Process-Write.]

Path: Delete Record  
Trigger: File‑Function = 8 (fn‑delete)  
Key steps: Set Post‑Key and Post‑Rrn, delete the record, set FS‑Reply and WE‑Error.  
I/O: Posting‑File (flat file)  
Outcomes: Record deleted, FS‑Reply 0.  
[Seen in: aa080-Process-Delete.]

Path: Start Record  
Trigger: File‑Function = 9 (fn‑start)  
Key steps: Validate access type, perform start operation with various key comparisons, set FS‑Reply on failure.  
I/O: Posting‑File (flat file)  
Outcomes: File positioned at start record, FS‑Reply 0 or 21 for invalid key.  
[Seen in: aa060-Process-Start.]

Path: RDBMS Processing  
Trigger: FS‑Cobol‑Files‑Used = false or special open‑output condition.  
Key steps: Load RDBMS parameters, call glpostingMT DAL with File‑Access and WS‑Posting‑Record, handle errors via WE‑Error.  
I/O: RDBMS table accessed through DAL (glpostingMT).  
Outcomes: Record processed in database, FS‑Reply and WE‑Error set by DAL.  
[Seen in: ba-Process-RDBMS.]

5.4 Termination  
On completion of the selected operation, the program executes aa‑Exit which performs a GOBACK (exit program) and, if testing is enabled, logs the result via Ca‑Process‑Logs. [Seen in: aa-Exit.]  
The aa‑999‑main‑exit paragraph ensures any pending logs are written before exiting, setting FS‑Reply and WE‑Error to zero on normal termination. [Seen in: aa999-main-exit.]

---
## acas007
*[6/267]*

### Business/Functional Perspective
### GL Batch File Handler  

**Program Purpose**  
The GL Batch File Handler allows the accounting system to manage General Ledger batch files and, when configured, the equivalent database tables. It accepts requests to open, close, read, write, delete, or rewrite records, and it ensures that all operations are performed safely and consistently. By validating file keys, record lengths, and database connectivity, the program protects the integrity of financial data, supports audit trails, and reduces the risk of data corruption or loss.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – Operation completed without issues.  
- **End of File** – No more records available to read.  
- **Invalid Key** – The requested record key does not exist.  
- **Parameter Error** – The operation was called with an inappropriate or missing parameter (e.g., wrong access type).  
- **Record Length Mismatch** – The in‑memory record is not the same size as the file or database layout, indicating a program or data structure problem.  
- **File Operation Error** – Issues opening, closing, writing, deleting, or rewriting the file (e.g., file not found, write protected).  
- **Database Error** – Problems connecting to or executing commands against the database (e.g., connection failure, SQL error).  

**User Flow Summary**  
A calling program supplies the file name, the type of file operation to perform, and any necessary keys or data. The batch handler validates the request and then performs the requested action: it may open or close a file, read the next record, read a specific record by key, write a new record, rewrite an existing record, or delete a record. If the system is configured for database access, the same operation is forwarded to the appropriate database module, which performs the equivalent action on the underlying table. After the action completes, the handler returns status codes that indicate success, the type of any error, or the presence of end‑of‑file. These results are passed back to the calling context, which can then decide how to present the outcome to the user or to log it for audit purposes.  

**Program Linkages**  
- glbatchMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs at aa010-main which initializes logging and validates key parameters before dispatching to the appropriate file operation paragraph. [Seen in: aa010-main.]  
The File-Function value determines the path: open, close, read, write, delete, rewrite, start, or an error path, each handled by its dedicated paragraph. [Seen in: aa010-main.]  
After file operations, control returns to aa999-main-exit for optional logging and then to aa-Exit to terminate the program. [Seen in: aa999-main-exit.]

5.2 Initialization  
aa010-main sets the log system and file number, checks File-Key-No for start, read-indexed, and delete operations, and performs early error handling for invalid key ranges. [Seen in: aa010-main.]  
It then tests whether RDBMS processing is required, performs record-size validation via ba012-Test-WS-Rec-Size-2, clears SQL error fields, and evaluates File-Function to dispatch to the appropriate paragraph. [Seen in: aa010-main.]

5.3 Core Processing  
Path: File-Open  
Trigger: File-Function = 1  
Key steps: Open the Batch-File in the mode specified by File-Access (input, i-o, output, extend), handle reply codes, and set Cobol-File-Status.  
I/O: Batch-File.  
Outcomes: FS-Reply, WE-Error, Cobol-File-Status.  
[Seen in: aa020-Process-Open.]

Path: File-Close  
Trigger: File-Function = 2  
Key steps: Close the Batch-File, reset status fields, and log the close event.  
I/O: Batch-File.  
Outcomes: FS-Reply, WE-Error, Cobol-File-Status.  
[Seen in: aa030-Process-Close.]

Path: Read-Next  
Trigger: File-Function = 3  
Key steps: Read the next record, detect EOF, initialize WS-Batch-Record on EOF, and set status flags.  
I/O: Batch-File.  
Outcomes: WS-Batch-Record, FS-Reply, WE-Error, Cobol-File-Status.  
[Seen in: aa040-Process-Read-Next.]

Path: Read-Indexed  
Trigger: File-Function = 4  
Key steps: Read a record by key, handle invalid key errors, and populate WS-Batch-Record.  
I/O: Batch-File.  
Outcomes: WS-Batch-Record, FS-Reply, WE-Error.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Write  
Trigger: File-Function = 5  
Key steps: Write a new record to Batch-File, handle invalid key errors, and update status.  
I/O: Batch-File.  
Outcomes: FS-Reply, WE-Error, Cobol-File-Status.  
[Seen in: aa070-Process-Write.]

Path: RDBMS Processing  
Trigger: FS-Cobol-Files-Used = false or special open-output case  
Key steps: Validate record size, load database connection parameters, call the DAL module glbatchMT, and propagate any errors.  
I/O: None directly (DAL handles DB).  
Outcomes: WE-Error, FS-Reply.  
[Seen in: ba-Process-RDBMS, ba012-Test-WS-Rec-Size-2, ba020-Process-DAL.]

5.4 Termination  
aa-Exit performs a program exit, after aa-main-exit has closed logs and reset function and access types. [Seen in: aa-Exit.]  
aa999-main-exit optionally logs the operation if Testing-1 is set before returning control to the caller. [Seen in: aa999-main-exit.]

---
## acas008
*[7/267]*

### Business/Functional Perspective
### IRS Posting File Handler  

**Program Purpose**  
The program manages the IRS posting file used by the accounting system. It opens, reads, writes, and deletes records in the file, supporting both flat‑file storage and database back‑ends. The module guarantees that the file’s record format matches the system definition, logs all activity, and reports any operational failures to the caller. By ensuring data integrity and consistent access to the posting file, the program supports accurate reporting and compliance with tax‑filing requirements.  

**Screen Interactions**  
No direct screens. This program is invoked by other modules after data has been entered or prepared, and it returns the outcome of the file operation back to that calling context.  

**Messages and Errors**  
- *File access failures*: if the file cannot be opened, does not exist, or an unexpected error occurs during open, close, read, or write.  
- *Record size mismatch*: if the record structure in the program does not match the record structure in the file, a warning is displayed and the operation stops.  
- *End‑of‑file*: when a read operation reaches the end of the file, the program indicates that no further records are available.  
- *Invalid function code*: if the caller requests an unsupported file operation, the program reports an error.  
- *Database connection errors*: when using a relational database, any failure to connect or execute a statement is reported to the caller.  

**User Flow Summary**  
A user or calling module initiates an IRS posting file operation (open, read, write, delete, or close). The program first verifies that the requested operation is valid for the file type. It then opens the file in the appropriate mode—input for reading, output for writing (which may delete all existing records), or input/output for updates. When reading, the program returns the next record; when writing, it appends a new record; when deleting, it removes the specified record. If the file is configured for database use, the program delegates the operation to the database access layer, ensuring that the same record format is used. After the operation completes, the program closes the file and reports success or any errors back to the caller. If testing or logging is enabled, detailed activity and error information is recorded in a log file.  

**Program Linkages**  
- slpostingMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **aa010-main**, setting up logging identifiers and then evaluates the File-Function to dispatch to the appropriate processing paragraph. [Seen in: aa010-main.]  
Depending on the function code, it may perform flat‑file operations such as open, close, read, write, or invoke the RDBMS processing section **ba-Process-RDBMS**. [Seen in: aa010-main.]  
After the selected operation completes, control returns to **aa999-main-exit** for optional logging and then exits via **aa-Exit**. [Seen in: aa999-main-exit.]

5.2 Initialization  
The program initializes logging parameters (WS-Log-System, WS-Log-File-No) and clears status fields (SQL-Err, SQL-Msg, SQL-State) before any file or database action. [Seen in: aa010-main.]  
It performs a record‑size consistency check by calling **ba012-Test-WS-Rec-Size-2**, which compares the lengths of the linkage and file records and sets WE-Error 901 if mismatched. [Seen in: ba012-Test-WS-Rec-Size-2.]

5.3 Core Processing  

Path: **Process-Open**  
Trigger: File‑Function = 1 (fn-input, fn-output, fn-i-o, fn-extend).  
Key steps: open the IRS‑Post‑File in the requested mode, handle errors by setting fs‑reply and we‑error, and set Cobol‑File‑Status.  
I/O: IRS‑Post‑File.  
Outcomes: file opened, status flags set, control to aa999‑main‑exit.  
[Seen in: aa020-Process-Open.]

Path: **Process-Read-Next**  
Trigger: File‑Function = 3 (fn-read-next).  
Key steps: read next record, handle EOF by setting WE‑Error 10 and fs‑reply 10, initialize record on EOF, otherwise move record to linkage.  
I/O: IRS‑Post‑File.  
Outcomes: record retrieved or EOF flagged, status set, control to aa999‑main‑exit.  
[Seen in: aa040-Process-Read-Next.]

Path: **Process-Write**  
Trigger: File‑Function = 5 (fn-write).  
Key steps: write the linkage record to IRS‑Post‑File, set status fields to zero, set Cobol‑File‑Status.  
I/O: IRS‑Post‑File.  
Outcomes: record written, status flags cleared, control to aa999‑main‑exit.  
[Seen in: aa070-Process-Write.]

Path: **Process-Delete**  
Trigger: File‑Function = 8 (fn-delete).  
Key steps: delete the current record from IRS‑Post‑File, set status fields to zero.  
I/O: IRS‑Post‑File.  
Outcomes: record deleted, status flags cleared, control to aa999‑main‑exit.  
[Seen in: aa080-Process-Delete.]

Path: **Bad-Function**  
Trigger: File‑Function not in 1‑9 (other).  
Key steps: set WE‑Error 999 and fs‑reply 99.  
I/O: none.  
Outcomes: error flagged, control to aa999‑main‑exit.  
[Seen in: aa100-Bad-Function.]

Path: **RDBMS Processing**  
Trigger: any operation when FS‑Cobol‑Files‑Used is false or when fn‑Open and fn‑Output with RDBMS.  
Key steps: call **ba-Process-RDBMS** which performs record‑size test, loads DB settings, and calls slpostingMT to interact with the database.  
I/O: none directly; slpostingMT handles database access.  
Outcomes: database operation performed, status fields set by slpostingMT, control returns to aa999‑main‑exit.  
[Seen in: ba-Process-RDBMS.]

5.4 Termination  
Upon completion of the selected operation, **aa999-main-exit** performs optional logging if Testing‑1 is true and then transfers control to **aa-main-exit**. [Seen in: aa999-main-exit.]  
**aa-main-exit** calls Ca-Process-Logs if the file was closed and finally **aa-Exit** exits the program. [Seen in: aa-main-exit, aa-Exit.]

---
## acas010
*[8/267]*

### Business/Functional Perspective
### Stock Audit File Handler

**Program Purpose**  
This program manages stock audit records by reading, writing, and deleting entries in either a flat file or a relational database table. It ensures that audit data is accurately recorded and maintained, supporting regulatory compliance and reliable financial reporting. By handling both file‑based and database operations, it provides a single interface for all stock audit activities, reducing duplication of effort and potential data inconsistencies.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Success** – Record processed successfully; no error message displayed.  
- **End‑of‑File** – No more records to read; operation ends gracefully.  
- **Invalid Key / Record Not Found** – Indicates the requested audit record does not exist.  
- **File Operation Error** – Problems opening, closing, or writing the file (e.g., permissions, file not found).  
- **Database Connection Error** – Failure to connect to the RDBMS or execute a query; typically accompanied by a brief diagnostic message.  
- **Record Length Mismatch** – The in‑memory record size does not match the defined database or file structure, triggering an error and prompting user confirmation before aborting.  
- **General Failure** – Any other unexpected issue results in a generic error code and a prompt for the user to check logs or contact support.

**User Flow Summary**  
A user initiates a stock audit operation by specifying an action such as open, close, read next, write, or delete. The program determines whether the data resides in a flat file or a database and performs the requested operation accordingly. During the process it may log actions for audit purposes. Upon completion, the program returns a status code that indicates success, an end‑of‑file condition, or a specific error. The user then reviews the status or any displayed message to confirm that the audit record was processed correctly or to take corrective action.

**Program Linkages**  
- auditMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs in **aa010-main** which sets logging parameters and validates key usage for start, read‑indexed, and delete functions. [Seen in: aa010-main.]  
Depending on **File-Function**, **aa010-main** dispatches to **aa020-Process-Open**, **aa030-Process-Close**, **aa040-Process-Read-Next**, **aa070-Process-Write**, or **aa100-Bad-Function**. [Seen in: aa010-main.]  
After the file operation, **aa999-main-exit** performs optional logging and then exits via **aa-Exit**. [Seen in: aa999-main-exit.]

5.2 Initialization  
At program start **aa010-main** initializes logging identifiers (**WS-Log-System** and **WS-Log-File-No**) and clears status fields (**SQL-Err**, **SQL-Msg**, **SQL-State**). [Seen in: aa010-main.]  
It then performs a record‑size check by calling **ba012-Test-WS-Rec-Size-2** to ensure the linkage record matches the file layout. [Seen in: ba012-Test-WS-Rec-Size-2.]

5.3 Core Processing  

Path: **Open File**  
Trigger: **File-Function = 1** (fn-input, fn-i-o, fn-output, fn-extend)  
Key steps: open **Stock-Audit** with the appropriate mode, set **Cobol-File-Status**, set **WS-File-Key**, handle errors, and go to **aa999-main-exit**.  
I/O: **Stock-Audit** file.  
Outcomes: **FS-Reply** set to 0 or error codes, **WE-Error** set if open fails.  
[Seen in: aa020-Process-Open.]

Path: **Close File**  
Trigger: **File-Function = 2** (fn-close)  
Key steps: close **Stock-Audit**, set status, call **Ca-Process-Logs**, and go to **aa-main-exit**.  
I/O: **Stock-Audit** file.  
Outcomes: **FS-Reply** cleared, **WE-Error** cleared.  
[Seen in: aa030-Process-Close.]

Path: **Read Next**  
Trigger: **File-Function = 3** (fn-read-next)  
Key steps: check EOF flag, read next record, handle EOF, move record to linkage, set **FS-Reply**, **WE-Error**.  
I/O: **Stock-Audit** file.  
Outcomes: **FS-Reply** 10 on EOF, **WE-Error** 0 on success.  
[Seen in: aa040-Process-Read-Next.]

Path: **Write Record**  
Trigger: **File-Function = 5** (fn-write)  
Key steps: write **Stock-Audit-Record** from linkage, set status, set **FS-Reply**, **WE-Error**.  
I/O: **Stock-Audit** file.  
Outcomes: **FS-Reply** 0 on success.  
[Seen in: aa070-Process-Write.]

Path: **Bad Function**  
Trigger: **File-Function** not 1, 2, 3, or 5 (e.g., 6)  
Key steps: set **WE-Error** 999, **FS-Reply** 99.  
I/O: none.  
Outcomes: error status.  
[Seen in: aa100-Bad-Function.]

Path: **RDBMS Processing**  
Trigger: **FS-Cobol-Files-Used = false** or **fn-Open** and **fn-output** with RDBMS  
Key steps: call **ba-Process-RDBMS** which tests record size, loads DB parameters, and calls **auditMT** DAL.  
I/O: **Stock-Audit** record (linkage) and database via **auditMT**.  
Outcomes: **WE-Error** and **FS-Reply** set by DAL, logging performed if **Testing-1**.  
[Seen in: ba-Process-RDBMS, ba020-Process-DAL.]

5.4 Termination  
After completing the requested operation, **aa999-main-exit** optionally logs the activity if **Testing-1** is set and then transfers control to **aa-Exit**. [Seen in: aa999-main-exit.]  
**aa-Exit** simply exits the program, returning control to the caller. [Seen in: aa-Exit.]

---
## acas011
*[9/267]*

### Business/Functional Perspective
### Stock File Handling  

#### Program Purpose  
This program manages the storage and retrieval of stock item records for the Applewood Computers Accounting System. It can work with either flat file storage or a relational database, depending on system configuration. The routine ensures that records are written, updated, read, and deleted correctly, and that any data integrity or access errors are reported back to the calling program. By handling file access and logging consistently, it supports reliable inventory management and auditability of stock movements.  

#### Screen Interactions  
No direct screens. This program is used after a separate data‑entry or navigation step and returns results back to that context.  

#### Messages and Errors  
- **Success** – the requested operation (open, close, read, write, delete, start, rewrite) completes without problems.  
- **End of File** – when a read reaches the end of the file.  
- **Invalid Key / Record Not Found** – the specified key does not match any stock record.  
- **File‑Access Error** – problems opening, closing, or performing I/O on the file (e.g., file missing, permission denied).  
- **Database Error** – failures when accessing the relational database (connection issues, SQL errors).  
- **Record‑Length Mismatch** – the size of the data record in memory does not match the definition expected by the system.  
- **Unexpected System Error** – any other internal failure that prevents completion of the operation.  

These outcomes are communicated to the calling program through the linkage area, allowing the user interface to present an appropriate message or prompt.  

#### User Flow Summary  
1. A higher‑level program (e.g., an inventory maintenance screen) calls this routine and supplies a **file‑function** code (open, read, write, etc.), a **key number** if required, and the stock record data (for write, update, or delete).  
2. The routine validates the key number and function, then decides whether to work with a flat file, a database, or both, depending on system settings.  
3. It performs the requested I/O operation: opening the file, reading a record, writing a new record, updating an existing record, or deleting a record.  
4. If an error occurs (e.g., key not found, file not accessible, or database connection failed), the routine records the error in the linkage area.  
5. After the operation, the routine logs the action (if logging is enabled) and returns control to the caller, providing status codes and, when applicable, the retrieved record data. The caller then displays a success or error message to the user.  

#### Program Linkages  
- `stockMT`  
- `fhlogger`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs at paragraph **aa010-main**, where logging is initialized and key ranges are validated. [Seen in: aa010-main.]  
The program dispatches to the appropriate processing paragraph based on the value of **File-Function** using an EVALUATE statement. [Seen in: aa010-main.]  
After the selected operation completes, control passes to **aa999-main-exit** and then to **aa-main-exit** before exiting the program. [Seen in: aa999-main-exit.]

5.2 Initialization  
Logging system parameters **WS-Log-System** and **WS-Log-File-No** are set to identify the module and log file. [Seen in: aa010-main.]  
Key ranges for read‑indexed, start, and delete functions are checked; if out of range, **WE-Error** and **fs-reply** are set and the routine exits. [Seen in: aa010-main.]  
If COBOL files are not used (**FS-Cobol-Files-Used** = false), the routine calls **ba-Process-RDBMS** to perform RDBMS processing and then exits. [Seen in: aa010-main.]  
The record size of **WS-Stock-Record** is compared with **Stock-Record**; if mismatched, an error message is displayed and the program stops. [Seen in: ba012-Test-WS-Rec-Size-2.]

5.3 Core Processing  

Path: System Setup  
Trigger: Entry to **aa010-main** when **FS-Cobol-Files-Used** is false.  
Key steps: Set RDBMS status, call **ba-Process-RDBMS**, then go to **AA-Main-Exit**.  
I/O: None (calls RDBMS module).  
Outcomes: **fs-reply** and **WE-Error** set by RDBMS; program exits.  
[Seen in: aa010-main.]

Path: Open  
Trigger: **File-Function** = 1.  
Key steps: Open **Stock-File** in input, i‑o, or output mode based on **File-Access**; handle errors; set **Cobol-File-Status**.  
I/O: **Stock-File**.  
Outcomes: File opened; **fs-reply** and **WE-Error** reflect success or failure.  
[Seen in: aa020-Process-Open.]

Path: Read-Next  
Trigger: **File-Function** = 3.  
Key steps: Read next record; handle EOF; move record to **WS-Stock-Record**; set **fs-reply** and **WE-Error**.  
I/O: **Stock-File**.  
Outcomes: **WS-Stock-Record** populated; **fs-reply** indicates success or EOF.  
[Seen in: aa040-Process-Read-Next.]

Path: Read-Indexed  
Trigger: **File-Function** = 4.  
Key steps: Evaluate **File-Key-No**; read **Stock-File** by key (Stock-Key, Stock-Abrev-Key, Stock-Desc, Stock-Location); set **fs-reply** and **WE-Error**; move record to **WS-Stock-Record**.  
I/O: **Stock-File**.  
Outcomes: **WS-Stock-Record** populated if key found; **fs-reply** indicates success or invalid key.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Start  
Trigger: **File-Function** = 9.  
Key steps: Evaluate **File-Key-No**; perform start operation with comparison operators (equal, less‑than, greater‑than, etc.); set **fs-reply** and **WE-Error**; set **WS-File-Key**.  
I/O: **Stock-File**.  
Outcomes: File positioned at first record matching criteria; **fs-reply** indicates success or invalid key.  
[Seen in: aa060-Process-Start.]

Path: Write  
Trigger: **File-Function** = 5.  
Key steps: Write **Stock-Record** to **Stock-File**; handle invalid key; set **fs-reply** and **WE-Error**; set **WS-File-Key**.  
I/O: **Stock-File**.  
Outcomes: Record written; **fs-reply** indicates success or error.  
[Seen in: aa070-Process-Write.]

5.4 Termination  
After processing, **aa999-main-exit** logs the operation if testing is enabled and then transfers control to **aa-main-exit**. [Seen in: aa999-main-exit.]  
**aa-main-exit** calls **Ca-Process-Logs** if required and then exits the program via **aa-Exit**. [Seen in: aa-main-exit.]

---
## acas012
*[10/267]*

### Business/Functional Perspective
### Sales Ledger File Handler  

**Program Purpose**  
The program manages all file operations for the Sales Ledger, including opening, closing, reading, writing, and deleting records. It works with both flat file storage and relational‑database back‑ends, ensuring that the correct data is processed regardless of the underlying medium. By validating record sizes and handling error conditions it protects data integrity and supplies reliable audit information. The module returns status codes that indicate success or the type of failure for the calling application.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *File operation failure* – the program reports that it could not open or close the Sales Ledger file.  
- *End of file reached* – indicates that a read operation has no more records to return.  
- *Invalid key or key not found* – the specified record key does not exist in the file or database.  
- *Record length mismatch* – the supplied record is too short or too long for the defined Sales Ledger format.  
- *Database connection or query error* – the program could not connect to or execute a statement against the RDBMS.  
- *Invalid parameters or access type* – the caller supplied a parameter that is outside the expected range.  
- *Unknown or unexpected error* – a generic failure that does not match any specific category.  
- *Operation succeeded* – indicates the requested action was completed without error.  

**User Flow Summary**  
A user or higher‑level application initiates a transaction that requires manipulating the Sales Ledger (for example, adding a new sales record, retrieving an existing record, updating a record, or deleting one). The request specifies the operation type (open, read, write, delete, close, etc.) and any necessary data such as a record key or the full record contents. The program performs the requested file or database operation, logs the activity, and returns status codes and, when appropriate, the requested data record. If an error occurs, the status code informs the caller of the problem so that an appropriate message can be displayed to the user or corrective action taken.  

**Program Linkages**  
- salesMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **aa010‑main**, where it validates key usage and decides whether to process a COBOL flat file or delegate to the RDBMS layer. It then evaluates **File‑Function** to dispatch to one of the file‑operation paragraphs (open, close, read‑next, read‑indexed, write, rewrite, delete, start, or a bad‑function handler). After the chosen operation completes, control returns to **aa999‑main‑exit**, where logging is performed if testing is enabled, and finally the program exits via **aa‑Exit**. [Seen in: aa010‑main.]

5.2 Initialization  
The program first checks **File‑Function** for valid key ranges for start, read‑indexed, and delete operations, setting **WE‑Error** and **fs‑reply** if out of range. If COBOL files are not in use, it calls **ba‑Process‑RDBMS** and then exits. It then tests the size of the working‑storage record against the file record, logging an error and halting if they differ. Finally, it clears status fields and prepares logging parameters before dispatching to the operation paragraph. [Seen in: aa010‑main, ba012‑Test‑WS‑Rec‑Size‑2.]

5.3 Core Processing  
Path: **Process‑Open**  
Trigger: **File‑Function = 1**  
Key steps: Set logging keys, open the Sales‑File in the requested mode (input, i‑o, output, or extend), handle open failures by closing and retrying for i‑o, and set **fs‑reply** on error.  
I/O: Sales‑File.  
Outcomes: **fs‑reply** set to 35 on input open failure; **Cobol‑File‑Status** cleared; program proceeds to exit. [Seen in: aa020‑Process‑Open.]

Path: **Process‑Read‑Next**  
Trigger: **File‑Function = 31**  
Key steps: Check EOF flag, perform a READ NEXT, set EOF status if at end, move the record to the linkage area, and clear error flags.  
I/O: Sales‑File.  
Outcomes: **fs‑reply** set to 10 on EOF; **WS‑Sales‑Record** populated; **Cobol‑File‑Status** set to 1 on EOF. [Seen in: aa040‑Process‑Read‑Next.]

Path: **Process‑Read‑Indexed**  
Trigger: **File‑Function = 4**  
Key steps: Validate key number, perform a READ KEY, set **fs‑reply** to 21 on invalid key, otherwise copy the record to the linkage area.  
I/O: Sales‑File.  
Outcomes: **fs‑reply** 21 on invalid key; **WS‑Sales‑Record** populated on success; **WE‑Error** unchanged. [Seen in: aa050‑Process‑Read‑Indexed.]

Path: **Process‑Write**  
Trigger: **File‑Function = 5**  
Key steps: Move the linkage record to the file record, write the record, and set **fs‑reply** to 22 on invalid key.  
I/O: Sales‑File.  
Outcomes: **fs‑reply** 22 on write failure; **Cobol‑File‑Status** cleared; record written on success. [Seen in: aa070‑Process‑Write.]

Path: **Process‑Delete**  
Trigger: **File‑Function = 8**  
Key steps: Set the key from the linkage area, delete the record, and set **fs‑reply** to 21 on invalid key.  
I/O: Sales‑File.  
Outcomes: **fs‑reply** 21 on delete failure; record removed on success; **Cobol‑File‑Status** cleared. [Seen in: aa080‑Process‑Delete.]

Path: **Process‑Rewrite**  
Trigger: **File‑Function = 7**  
Key steps: Move the linkage record to the file record, rewrite the record, and set **fs‑reply** to 21 on invalid key.  
I/O: Sales‑File.  
Outcomes: **fs‑reply** 21 on rewrite failure; record updated on success; **Cobol‑File‑Status** cleared. [Seen in: aa090‑Process‑Rewrite.]

5.4 Termination  
After completing the chosen operation, the program executes **aa999‑main‑exit**, performing logging if testing is enabled, then returns to **aa‑main‑exit** where it clears the function and access‑type fields and calls the log processor. Finally, control reaches **aa‑Exit**, which exits the program. [Seen in: aa999‑main‑exit, aa‑main‑exit, aa‑Exit.]

---
## acas013
*[11/267]*

### Business/Functional Perspective
### Sales Purch Value File Handler  

**Program Purpose**  
The program manages all file operations for the Sales/Purch Value data set. It supports opening, closing, reading (next or by key), writing, rewriting, deleting, and starting record operations. The routine validates keys, detects end‑of‑file conditions, and, when configured, redirects actions to a relational database instead of a flat file. By ensuring correct record sizes and handling file or database errors, it maintains data integrity and provides a reliable interface for other modules that need to access or modify sales/value records.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Success** – Operation completes with no error; data is returned or the requested action is performed.  
- **End of File** – When reading the next record after the last one, the program signals “end of file”.  
- **Invalid or Missing Key** – If a key is not found or is invalid for the requested operation, the program reports “key not found”.  
- **File Access Errors** – Problems such as an unsupported file key type, wrong access type, or file‑open failure are reported.  
- **Database Errors** – When operating through a database, connection failures, SQL errors during delete or rewrite, or other database issues are reported.  
- **Record Size Mismatch** – If the record size passed to the routine does not match the expected layout, the program alerts the user that the record structure must be corrected.  
- **General Errors** – Any other unexpected condition results in a generic error notification.  

**User Flow Summary**  
When a user initiates a transaction that requires sales or purchase value data, the application supplies the file operation type (open, close, read, write, etc.), the record data if needed, and any key values through a linkage area. The routine validates the request, performs the necessary file or database operation, and returns status codes indicating success, end of file, key errors, or any other problems. If the operation succeeds, the calling module proceeds; if an error occurs, the user is notified of the issue and can take corrective action. Each action is logged for audit purposes, allowing later review of file activity.

**Program Linkages**  
- valueMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa010-main, where it logs the operation, validates key ranges for start, read-indexed, and delete functions, and decides whether to use flat files or invoke the RDBMS path via ba-Process-RDBMS.  
If flat files are used, aa010-main performs a record-size test (ba012-Test-WS-Rec-Size-2) and then dispatches to one of the file‑operation paragraphs (aa020‑Process‑Open, aa030‑Process‑Close, aa040‑Process‑Read‑Next, aa050‑Process‑Read‑Indexed, aa060‑Process‑Start, aa070‑Process‑Write, aa080‑Process‑Delete, aa090‑Process‑Rewrite) based on the File‑Function value.  
After the operation, control returns to aa999‑main‑exit, where logging is performed if testing is enabled, and then to aa‑Exit to terminate the program. [Seen in: aa010-main.]

5.2 Initialization  
The program sets logging identifiers (WS‑Log‑System and WS‑Log‑File‑No) and checks key validity for start, read-indexed, and delete functions before any file or database action.  
If flat files are not used, it loads RDBMS connection parameters, performs a record‑size test, and calls the appropriate DAL module (valueMT) via ba‑Process‑RDBMS before exiting. [Seen in: aa010-main.]

5.3 Core Processing  

Path: Process‑Open  
Trigger: File‑Function = 1 (fn‑open)  
Key steps: Open the Value‑File in the requested mode (input, i‑o, output, extend), set Cobol‑File‑Status, and set WS‑File‑Key to “OPEN VALUE File”.  
I/O: Value‑File.  
Outcomes: FS‑Reply set to 0 on success; WE‑Error set to 999 on failure; control goes to aa999‑main‑exit. [Seen in: aa020-Process-Open.]

Path: Process‑Read‑Next  
Trigger: File‑Function = 3 (fn‑read‑next)  
Key steps: Read the next record from Value‑File; on EOF set FS‑Reply to 10 and WE‑Error to 10, otherwise copy Value‑Record to WS‑Value‑Record and clear errors.  
I/O: Value‑File.  
Outcomes: WS‑Value‑Record populated on success; FS‑Reply 10 on EOF; WE‑Error cleared. [Seen in: aa040-Process-Read-Next.]

Path: Process‑Read‑Indexed  
Trigger: File‑Function = 4 (fn‑read‑indexed)  
Key steps: Validate File‑Key‑No, perform a key‑based read of Value‑File, set FS‑Reply to 21 on invalid key, otherwise copy record to WS‑Value‑Record.  
I/O: Value‑File.  
Outcomes: WS‑Value‑Record populated on success; FS‑Reply 21 on key error; WE‑Error cleared. [Seen in: aa050-Process-Read-Indexed.]

Path: Process‑Write  
Trigger: File‑Function = 5 (fn‑write)  
Key steps: Write WS‑Value‑Record to Value‑File, set FS‑Reply to 22 on invalid key, clear errors otherwise.  
I/O: Value‑File.  
Outcomes: Record written; FS‑Reply 22 on error; WE‑Error cleared. [Seen in: aa070-Process-Write.]

Path: Process‑Delete  
Trigger: File‑Function = 8 (fn‑delete)  
Key steps: Delete WS‑Value‑Record from Value‑File, set FS‑Reply to 21 on invalid key, clear errors otherwise.  
I/O: Value‑File.  
Outcomes: Record deleted; FS‑Reply 21 on error; WE‑Error cleared. [Seen in: aa080-Process-Delete.]

Path: Process‑RDBMS  
Trigger: FS‑Cobol‑Files‑Used = false (flat files not used)  
Key steps: Load RDBMS parameters, test record size, call the DAL module valueMT with File‑Access and WS‑Value‑Record, then exit the section.  
I/O: RDBMS database via valueMT.  
Outcomes: RDBMS operation performed; any errors returned in WE‑Error, SQL‑Err, SQL‑Msg; control returns to aa‑main‑exit. [Seen in: ba-Process-RDBMS, ba020-Call.]

5.4 Termination  
After completing the requested operation, aa999‑main‑exit performs logging if testing is enabled and then transfers control to aa‑Exit, which exits the program.  
The program ensures all files are closed (aa030‑Process‑Close) and that FS‑Reply and WE‑Error are set appropriately before termination. [Seen in: aa999-main-exit, aa-Exit.]

---
## acas014
*[12/267]*

### Business/Functional Perspective
### Delivery File Record Handling  

**Program Purpose**  
The program is responsible for managing delivery records in the ACAS system. It can read, write, update, or delete individual records in a delivery file, whether the data is stored in flat files or in a relational database. The routine ensures that records are correctly processed, validates key fields, and logs all actions for audit and troubleshooting. By providing a single point of control for file and database access, it reduces the risk of data corruption and supports compliance with accounting and inventory regulations.  

**Screen Interactions**  
No direct screens. This program is invoked by other modules after a separate data‑entry step and returns status information to that context.  

**Messages and Errors**  
* **Success** – File operation completes without error (status 0).  
* **End of File** – No more records to read (status 10).  
* **Invalid Key** – Key value does not match an existing record (status 21).  
* **Missing or Out‑of‑Range Key** – Key is required but missing or out of the allowed range (error 998 or 996).  
* **Record Length Mismatch** – Internal record layout does not match the database or file definition (error 901).  
* **Database Access Failure** – Problems connecting to or executing commands in the database (error 911 and related SQL errors).  
* **General File Errors** – Issues such as file not found, write or delete failure, or unexpected I/O errors (errors 35, 99, 990‑994).  
* **User Prompt** – In the unlikely event of a record‑length mismatch, the program displays a message and waits for the user to acknowledge before terminating.  

**User Flow Summary**  
When a user or a higher‑level program needs to manage delivery records, it calls this routine with a set of parameters that indicate the desired operation (open, close, read next, read by key, write, delete, rewrite, or start a search). The routine validates the requested action, opens the delivery file or connects to the database, and then performs the requested file or database operation. All actions are logged, and the routine returns a status code and any relevant error information. If the operation succeeds, the caller can continue processing; if an error occurs, the caller receives a clear indication of the problem and can take corrective action, such as correcting data or troubleshooting connectivity.  

**Program Linkages**  
- deliveryMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph aa010‑main, initializing logging and validating key ranges for indexed read, start, and delete functions. [Seen in: aa010‑main.]  
It then handles special open‑output cases, performs RDBMS processing if flat files are not used, and checks record size before dispatching to the appropriate file operation paragraph. [Seen in: aa010‑main.]  
Based on the File‑Function value it jumps to the corresponding paragraph (aa020‑Process‑Open, aa030‑Process‑Close, aa040‑Process‑Read‑Next, aa050‑Process‑Read‑Indexed, aa060‑Process‑Start, aa070‑Process‑Write, aa080‑Process‑Delete, aa090‑Process‑Rewrite) and finally exits via aa999‑main‑exit and aa‑Exit. [Seen in: aa010‑main.]

5.2 Initialization  
The program sets logging parameters (WS‑Log‑System, WS‑Log‑File‑No) and validates key ranges for indexed read, start, and delete functions. [Seen in: aa010‑main.]  
It then handles special open‑output cases, performs RDBMS processing if flat files are not used, and checks record size before dispatching to the appropriate operation paragraph. [Seen in: aa010‑main.]

5.3 Core Processing  
Path: Open  
Trigger: File‑Function = 1 (fn‑input, fn‑i‑o, fn‑output, fn‑extend).  
Key steps: set WS‑File‑Key, open the Delivery‑File with the requested mode, handle any open errors, set Cobol‑File‑Status, and assign a descriptive WS‑File‑Key.  
I/O: Delivery‑File.  
Outcomes: FS‑Reply set to 0 on success or error code on failure; WE‑Error set to 999 on error.  
[Seen in: aa020‑Process‑Open.]  

Path: Read‑Next  
Trigger: File‑Function = 3.  
Key steps: check EOF flag, read the next record, set EOF status if at end, initialize WS‑Delivery‑Record, and set WS‑File‑Key to the record key or “EOF”.  
I/O: Delivery‑File.  
Outcomes: FS‑Reply 0 on success, 10 on EOF; WE‑Error 0.  
[Seen in: aa040‑Process‑Read‑Next.]  

Path: Read‑Indexed  
Trigger: File‑Function = 4.  
Key steps: set WS‑Deliv‑Key to Deliv‑Key, read the record by key, handle invalid key errors, move the record to WS‑Delivery‑Record, and set WS‑File‑Key.  
I/O: Delivery‑File.  
Outcomes: FS‑Reply 0 on success, 21 on invalid key; WE‑Error 0.  
[Seen in: aa050‑Process‑Read‑Indexed.]  

Path: Start  
Trigger: File‑Function = 9.  
Key steps: validate access‑type, perform a start operation with the appropriate comparison operator, handle invalid key errors, then exit.  
I/O: Delivery‑File.  
Outcomes: FS‑Reply 0 on success, 21 on invalid key; WE‑Error 0.  
[Seen in: aa060‑Process‑Start.]  

Path: Write  
Trigger: File‑Function = 5.  
Key steps: move WS‑Delivery‑Record to Delivery‑Record, write the record, handle invalid key errors, and set WS‑File‑Key.  
I/O: Delivery‑File.  
Outcomes: FS‑Reply 0 on success, 21 on invalid key; WE‑Error 0.  
[Seen in: aa070‑Process‑Write.]  

Path: Delete  
Trigger: File‑Function = 8.  
Key steps: set Deliv‑Key, delete the record, and set WS‑File‑Key.  
I/O: Delivery‑File.  
Outcomes: FS‑Reply 0 on success, 21 on invalid key; WE‑Error 0.  
[Seen in: aa080‑Process‑Delete.]  

5.4 Termination  
Upon completion of the requested operation, the program optionally logs the activity if testing is enabled before proceeding to exit. [Seen in: aa999‑main‑exit.]  
The program then exits via aa‑Exit, terminating the program. [Seen in: aa‑Exit.]

---
## acas015
*[13/267]*

### Business/Functional Perspective
### Sales/Purch Analysis File Handler  

**Program Purpose**  
The program manages all input‑output for the Sales/Purch Analysis data set. It can open, read, write, rewrite, delete, or seek records, and it supports both flat‑file and relational‑database access. By ensuring that operations complete correctly and by logging every action, the program helps maintain data integrity, supports audit requirements, and reduces the risk of corrupted or lost records.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Success** – Operation completes and the calling module receives the requested record or a success flag.  
- **End of File** – The read operation reaches the end of the data set.  
- **Key Not Found / Invalid Key** – The specified key does not exist in the file or table.  
- **File Access Error** – Problems opening, closing, writing, deleting, or rewritting a file (e.g., file not found, permission denied).  
- **Record Size Mismatch** – The supplied record is shorter than required for the file or database table.  
- **Database Connection or SQL Error** – Failure to connect to or query the underlying database.  
- **Bad Function** – The requested function code is not supported.  
- **Testing / Logging** – During debugging a log entry may be generated but no user‑visible message is shown.

**User Flow Summary**  
A higher‑level application invokes this program when it needs to interact with the Sales/Purch Analysis data. The caller specifies the desired function (open, read next, read by key, write, rewrite, delete, start, or close) and provides any necessary key or record data. The program performs the action, logs the attempt, and then returns control to the caller. If the operation succeeds, the caller receives the requested record or a success status. If it fails, an appropriate error message is displayed to the user, allowing them to correct the input or investigate the problem. The program ensures that the data remain consistent and that all actions are recorded for audit purposes.

**Program Linkages**  
- analMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in **aa-Process-Flat-File Section**, initializing logging parameters and validating the File-Function before deciding between RDBMS or flat‑file processing. [Seen in: aa-Process-Flat-File Section.]  
If **FS-Cobol-Files-Used** is false, the routine calls **ba-Process-RDBMS** to perform the requested operation on the database and then exits. [Seen in: aa-Process-Flat-File Section.]  
For flat‑file operations, the program tests the record size, then evaluates **File-Function** to dispatch to the appropriate **aa020‑Process‑Open**, **aa030‑Process‑Close**, **aa040‑Process‑Read‑Next**, **aa050‑Process‑Read‑Indexed**, **aa060‑Process‑Start**, **aa070‑Process‑Write**, **aa080‑Process‑Delete**, or **aa090‑Process‑Rewrite** paragraph. [Seen in: aa-Process-Flat-File Section.]

5.2 Initialization  
The routine sets **WS-Log-System** and **WS-Log-File-No** for logging, then checks **File-Function** for key validity on start, read‑indexed, and delete operations, setting **WE-Error** and **fs-reply** if the key number is not 1. [Seen in: aa-Process-Flat-File Section.]  
It then verifies whether flat files are used; if not, it loads RDBMS connection parameters, calls **ba-Process-RDBMS**, and jumps to **AA-Main-Exit**. [Seen in: aa-Process-Flat-File Section.]  
The program performs a record size test via **ba012-Test-WS-Rec-Size-2** before proceeding to the operation dispatch. [Seen in: aa-Process-Flat-File Section.]

5.3 Core Processing  
Path: **Open**  
Trigger: **File-Function = 1**  
Key steps: set **WS-File-Key**, open file based on **fn-input**, **fn-i-o**, **fn-output**, **fn-extend**; set status; set **WS-File-Key** to "OPEN ANALYSIS File".  
I/O: **Analysis-File**.  
Outcomes: **fs-reply** set to 35 on input error; **WE-Error** set to 999 on error; **Cobol-File-Status** zero; exit to **aa999-main-exit**.  
[Seen in: aa020-Process-Open.]

Path: **Read-Next**  
Trigger: **File-Function = 3**  
Key steps: check EOF flag; read next record; on EOF set **fs-reply** 10, **WE-Error**, set **Cobol-File-Status** 1, initialize record, set **WS-File-Key** "EOF"; else move record to **WS-Analysis-Record**, set **PA-Code** to **WS-File-Key**, **WE-Error** zero.  
I/O: **Analysis-File**.  
Outcomes: **fs-reply** 10 on EOF, otherwise zero; **WE-Error** zero; record returned.  
[Seen in: aa040-Process-Read-Next.]

Path: **Read-Indexed**  
Trigger: **File-Function = 4**  
Key steps: evaluate keys, set **WS-File-Key**, if **File-Key-No=1** read key **PA-Code**; on success move record to **WS-Analysis-Record**; on failure set **fs-reply** 21, **WE-Error**; else set error 998 if key number not 1.  
I/O: **Analysis-File**.  
Outcomes: **fs-reply** 21 on invalid key; **WE-Error** 21; record returned or spaces.  
[Seen in: aa050-Process-Read-Indexed.]

Path: **Write**  
Trigger: **File-Function = 5**  
Key steps: move **WS-Analysis-Record** to **Analysis-Record**, set **WS-File-Key** to **PA-Code**, write record; on invalid key set **fs-reply** 22.  
I/O: **Analysis-File**.  
Outcomes: **fs-reply** 22 on invalid key; **WE-Error** zero; record written.  
[Seen in: aa070-Process-Write.]

Path: **Delete**  
Trigger: **File-Function = 8**  
Key steps: move **WS-Analysis-Record** to **Analysis-Record**, set **WS-File-Key** to **PA-Code**, delete record; on invalid key set **fs-reply** 21.  
I/O: **Analysis-File**.  
Outcomes: **fs-reply** 21 on invalid key; **WE-Error** zero; record deleted.  
[Seen in: aa080-Process-Delete.]

5.4 Termination  
After processing, the program performs logging if **Testing-1** is set, then exits the program via **aa-Exit**. [Seen in: aa999-main-exit.]  
The **aa-Exit** paragraph simply executes "exit program" to return control to the caller. [Seen in: aa-Exit.]

---
## acas016
*[14/267]*

### Business/Functional Perspective
### Invoice File Handler

**Program Purpose**  
The Invoice File Handler is responsible for reading, writing, updating, and deleting sales invoice records in either a COBOL flat‑file or a database. It ensures that every invoice record is processed safely and that any file‑system or database errors are reported back to the calling application. By validating record sizes, key usage, and access types, the program reduces the risk of data corruption and helps maintain accurate financial records for audit and compliance purposes.

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
The program communicates status to the caller through two codes:

| Status | What it means for the user |
|--------|-----------------------------|
| **Success (0)** | The requested operation completed without problems. |
| **End of File (10)** | No more records to read – the requested record was not found. |
| **Invalid Key (21)** | The supplied key does not match any existing invoice record. |
| **File‑Access Error (99)** | A problem occurred while opening, closing, or otherwise accessing the file or database (e.g., file not found, permission denied, or database connection failure). |
| **Record‑Size Mismatch (901)** | The invoice record being processed does not match the expected size, indicating a configuration error. |
| **Other Errors** | Any additional database or system errors that are reported by the underlying data‑access module. |

The program does not display raw error codes to the user; instead, it returns a clear success or failure status to the calling application, which can then present an appropriate message to the end user.

**User Flow Summary**  
When a user submits an invoice operation, the system passes the invoice record and an operation code (open, close, read next, read by key, write, rewrite, or delete) to the handler.  
The handler verifies that the file or database is available, checks the record length and key validity, and then performs the requested action. If the action succeeds, the record is written to or retrieved from storage and a success code is returned. If the handler encounters an issue—such as an invalid key, end of file, or a database connection problem—it stops the operation and returns a failure code that indicates the type of error. After the operation, the handler logs the transaction details for audit purposes, then returns control to the calling application.

**Program Linkages**  
- slinvoiceMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by setting logging parameters and validating key ranges for start, read-indexed, and delete operations. [Seen in: aa010-main.]  
It then determines whether to operate on COBOL flat files or invoke the RDBMS DAL based on the FS-Cobol-Files-Used flag, performing a record size test before delegating to the appropriate routine. [Seen in: aa010-main.]  
Depending on the File-Function value, the program dispatches to one of several processing paragraphs (open, close, read-next, read-indexed, write, rewrite, delete, start) or reports an invalid function, before exiting. [Seen in: aa010-main.]

5.2 Initialization  
The program initializes logging identifiers (WS-Log-System, WS-Log-File-No), clears status fields, and checks key validity for indexed operations. [Seen in: aa010-main.]  
If COBOL files are not used, it loads RDBMS parameters, tests record size, and calls the DAL module, then exits. [Seen in: aa010-main.]

5.3 Core Processing  
Path: RDBMS Access  
Trigger: FS-Cobol-Files-Used = false (i.e., not using COBOL files). [Seen in: aa010-main.]  
Key steps: perform ba012-Test-WS-Rec-Size-2, load RDBMS parameters, call slinvoiceMT DAL. [Seen in: ba012-Test-WS-Rec-Size-2, ba015-Test-Ends.]  
I/O: RDBMS tables via DAL; no file I/O. [Seen in: ba015-Test-Ends.]  
Outcomes: WE-Error and FS-Reply set by DAL; program exits via aa999-main-exit. [Seen in: ba-rdbms-exit.]  

Path: Open File  
Trigger: File-Function = 1. [Seen in: aa020-Process-Open.]  
Key steps: open input, i-o, or output based on fn-input, fn-i-o, fn-output, fn-extend; set status; log. [Seen in: aa020-Process-Open.]  
I/O: Invoice-File. [Seen in: aa020-Process-Open.]  
Outcomes: FS-Reply indicates success or error; WE-Error set to 999 on failure; exit. [Seen in: aa020-Process-Open.]  

Path: Read-Next  
Trigger: File-Function = 34 (or 3). [Seen in: aa040-Process-Read-Next.]  
Key steps: check EOF flag; read next record; handle EOF; move record to WS-Invoice-Record; set WS-File-Key. [Seen in: aa040-Process-Read-Next.]  
I/O: Invoice-File. [Seen in: aa040-Process-Read-Next.]  
Outcomes: FS-Reply 10 on EOF; WE-Error 10; record returned; exit. [Seen in: aa040-Process-Read-Next.]  

Path: Read-Indexed  
Trigger: File-Function = 4. [Seen in: aa050-Process-Read-Indexed.]  
Key steps: evaluate keys, read key, handle invalid key, set WS-Invoice-Record. [Seen in: aa050-Process-Read-Indexed.]  
I/O: Invoice-File. [Seen in: aa050-Process-Read-Indexed.]  
Outcomes: FS-Reply 21 on invalid key; WE-Error 21; record returned if found. [Seen in: aa050-Process-Read-Indexed.]  

Path: Write  
Trigger: File-Function = 5. [Seen in: aa070-Process-Write.]  
Key steps: move WS-Invoice-Record to Invoice-Record; write record; handle invalid key. [Seen in: aa070-Process-Write.]  
I/O: Invoice-File. [Seen in: aa070-Process-Write.]  
Outcomes: FS-Reply 22 on invalid key; WE-Error 0 on success. [Seen in: aa070-Process-Write.]  

Path: Delete  
Trigger: File-Function = 8. [Seen in: aa080-Process-Delete.]  
Key steps: move WS-Invoice-Record to Invoice-Record; delete record; handle invalid key. [Seen in: aa080-Process-Delete.]  
I/O: Invoice-File. [Seen in: aa080-Process-Delete.]  
Outcomes: FS-Reply 21 on invalid key; WE-Error 0 on success. [Seen in: aa080-Process-Delete.]  

5.4 Termination  
After processing, the program performs optional logging if Testing-1 is set, then exits via aa-Exit. [Seen in: aa999-main-exit, aa-Exit.]  
The exit routine simply returns control to the caller without further cleanup. [Seen in: aa-Exit.]

---
## acas017
*[15/267]*

### Business/Functional Perspective
### Deleted Invoice Number Handler  

**Program Purpose**  
This program manages the list of invoice numbers that have been marked as deleted. It allows other parts of the system to create, read, update, and remove records in that list, ensuring that deleted invoices are tracked consistently whether the data lives in flat files or a relational database. The program guarantees that all operations are logged, validates input keys, and protects data integrity by preventing invalid or duplicate entries.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – Record processed and returned to the caller.  
- **End of File** – No more records to read.  
- **Invalid Key** – Requested invoice number does not exist or key value is out of range.  
- **File Access Issues** – Unable to open, close, or write to the file (e.g., missing file, permission denied).  
- **Record Length Mismatch** – The record supplied does not match the expected format.  
- **Database Connection Failure** – Cannot connect to the underlying database.  
- **Delete‑All Failure** – Error while removing all records from the list.  
- **General Failure** – Any other unexpected problem encountered during processing.  

**User Flow Summary**  
When an operation is required, another program supplies a record containing an invoice number and a function code indicating the desired action (open, close, read next, read by key, start a search, write, rewrite, delete, or delete‑all).  
- If the function is **open** or **close**, the program prepares the data store and informs the caller when the operation completes.  
- For **read next** or **read by key**, the program retrieves the specified record, or signals that no matching record exists.  
- **Start** operations position the system at the first record that meets a search criterion, after which a read next may follow.  
- **Write** or **rewrite** actions add a new deleted‑invoice entry or update an existing one, while **delete** removes a specific entry.  
- **Delete‑all** clears the entire list.  
After completing the requested action, the program returns status codes and any retrieved record to the calling program, which can then present the result to the user or take further business steps.  

**Program Linkages**  
- sldelinvnosMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins in the aa-Process-Flat-File Section, initializing logging and validating key parameters before any file or RDBMS action. [Seen in: aa-Process-Flat-File Section.]  
It then performs a record size test and, depending on the File-Function value, dispatches to one of the aa020-Process-Open, aa030-Process-Close, aa040-Process-Read-Next, aa050-Process-Read-Indexed, aa070-Process-Write, aa090-Process-Rewrite, aa080-Process-Delete, or aa060-Process-Start paragraphs. [Seen in: aa-Process-Flat-File Section.]  
After the selected operation completes, the program exits via aa-Exit, performing any necessary logging before terminating. [Seen in: aa-Exit.]

5.2 Initialization  
The program sets logging identifiers (WS-Log-System and WS-Log-File-No), then validates File-Key-No for read-indexed, start, and delete functions, setting error codes if out of range. [Seen in: aa-Process-Flat-File Section.]  
If an open-output request is detected and Cobol files are not used, it performs ba-Process-RDBMS to handle the RDBMS equivalent of opening the file. [Seen in: aa-Process-Flat-File Section.]  
It then checks whether Cobol files are used; if not, it calls ba-Process-RDBMS for RDBMS processing and exits. [Seen in: aa-Process-Flat-File Section.]  
Before dispatching to the operation‑specific paragraph, it performs a record size test via ba012-Test-WS-Rec-Size-2 and clears SQL error fields. [Seen in: aa-Process-Flat-File Section.]

5.3 Core Processing  
Path: Open‑Output  
Trigger: fn-Open and fn-output and not FS-Cobol-Files-Used  
Key steps: perform ba-Process-RDBMS, then go to AA-Main-Exit.  
I/O: RDBMS (via ba-Process-RDBMS), no file I/O.  
Outcomes: sets FS-Reply and WE-Error as set by ba-Process-RDBMS, then exits.  
[Seen in: aa-Process-Flat-File Section.]  

Path: File‑Function Dispatch (General)  
Trigger: evaluate File-Function value (1‑9) leading to aa020‑Process‑Open, aa030‑Process‑Close, aa040‑Process‑Read‑Next, aa050‑Process‑Read‑Indexed, aa070‑Process‑Write, aa090‑Process‑Rewrite, aa080‑Process‑Delete, or aa060‑Process‑Start.  
Key steps: call the appropriate aa0xx paragraph, then exit via aa999‑main‑exit.  
I/O: depends on paragraph – file open/close/read/write/delete, or RDBMS via ba-Process-RDBMS.  
Outcomes: sets FS-Reply, WE-Error, Cobol-File-Status, WS-File-Key, etc.  
[Seen in: aa-Process-Flat-File Section.]  

Path: Start (fn‑start)  
Trigger: File-Function = 9 (aa060‑Process‑Start)  
Key steps: validate access-type, perform start statements based on fn‑equal‑to, fn‑not‑less‑than, fn‑greater‑than, fn‑less‑than, then exit.  
I/O: start operation on Del‑Inv‑Nos‑File (no actual read).  
Outcomes: sets FS-Reply, WE-Error, may set WS-File-Key.  
[Seen in: aa060-Process-Start.]  

Path: Read‑Indexed (fn‑read-indexed)  
Trigger: File-Function = 4 (aa050‑Process‑Read‑Indexed)  
Key steps: set WS-No-Paragraph, read record by key, handle invalid key, move record to WS-Del-Inv-Nos-Record.  
I/O: read from Del‑Inv‑Nos‑File.  
Outcomes: sets FS-Reply, WE-Error, WS-File-Key.  
[Seen in: aa050-Process-Read-Indexed.]  

Path: Write (fn‑write)  
Trigger: File-Function = 5 (aa070‑Process‑Write)  
Key steps: move record to file, write record, handle invalid key.  
I/O: write to Del‑Inv‑Nos‑File.  
Outcomes: sets FS-Reply, WE-Error, WS-File-Key.  
[Seen in: aa070-Process-Write.]  

5.4 Termination  
Upon completion of the selected operation, aa999‑main‑exit performs any testing logs and then transfers control to aa‑main‑exit. [Seen in: aa999-main-exit.]  
aa‑main‑exit calls Ca‑Process‑Logs to record the transaction and then exits the program via aa‑Exit. [Seen in: aa-main-exit, aa-Exit.]

---
## acas019
*[16/267]*

### Business/Functional Perspective
### Open Item 3 File Operations  

**Program Purpose**  
The program manages the sales “Open Item 3” records, allowing records to be created, read, updated, or deleted. It validates record integrity, ensures that data is correctly stored or retrieved, and logs each action for audit purposes. By handling both file‑based and database‑based storage, it supports accurate financial reporting and reduces the risk of data corruption or loss.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- Successful completion of the requested operation.  
- End‑of‑file reached when no more records are available.  
- Record not found or key not matched.  
- File access problems (cannot open, close, or write).  
- Record size mismatch when the incoming data does not fit the expected layout.  
- Database connection or query failures.  
- Unexpected internal errors that stop the operation.  

**User Flow Summary**  
When a user or calling module requests an action—such as opening the Open Item 3 file, reading the next record, retrieving a specific record, writing a new record, updating an existing one, or deleting a record—the program performs the requested operation. If the operation succeeds, the program returns the requested record data (for reads) or confirms that the change was made. If the operation fails, the program reports the nature of the failure in plain terms, allowing the user or calling module to handle it appropriately. Throughout the process, each action is logged with a timestamp and status so that the activity can be audited later.  

**Program Linkages**  
- otm3MT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa010‑main, initializing logging and validating key parameters before dispatching based on File‑Function. [Seen in: aa010-main.]  
Depending on File‑Function, control is transferred to one of the aa0x‑Process‑… paragraphs (Open, Close, Read‑Next, Read‑Indexed, Start, Write, Delete, Rewrite) or to the RDBMS section for database access. [Seen in: aa010-main.]  
After processing, the program exits through aa‑Exit, performing any pending log processing and returning control to the caller. [Seen in: aa-Exit.]

5.2 Initialization  
Logging is configured with system identifiers (WS‑Log‑System and WS‑Log‑File‑No) and key validity is checked for start, read‑indexed, and delete operations. [Seen in: aa010-main.]  
The program verifies record size compatibility between the in‑memory record and the file record, and loads database connection parameters if RDBMS processing is required. [Seen in: ba012-Test-WS-Rec-Size-2.]

5.3 Core Processing  
Path: Open  
Trigger: File‑Function = 1 (fn‑input or fn‑i‑o etc.)  
Key steps: set WS‑File‑Key, open file with appropriate mode, handle Fs‑Reply, set Cobol‑File‑Status, set WS‑File‑Key to “OPEN SL OTM3 File”.  
I/O: Open‑Item‑File‑3.  
Outcomes: FS‑Reply set to 0 on success, WE‑Error 0, Cobol‑File‑Status 0.  
[Seen in: aa020-Process-Open.]  

Path: Read‑Next  
Trigger: File‑Function = 3 (fn‑read‑next)  
Key steps: check EOF flag, read next record, handle EOF, move record to WS‑OTM3‑Record, call aa041‑Move‑Inv‑Data.  
I/O: Open‑Item‑File‑3.  
Outcomes: FS‑Reply 10 on EOF, WE‑Error 0, Cobol‑File‑Status 1 on EOF, record returned.  
[Seen in: aa040-Process-Read-Next.]  

Path: Read‑Indexed  
Trigger: File‑Function = 4 (fn‑read‑indexed)  
Key steps: evaluate keys, read record by key OI3‑Key, handle invalid key, move record to WS‑OTM3‑Record.  
I/O: Open‑Item‑File‑3.  
Outcomes: FS‑Reply 21 on invalid key, WE‑Error 0, record returned if found.  
[Seen in: aa050-Process-Read-Indexed.]  

Path: Start  
Trigger: File‑Function = 9 (fn‑start)  
Key steps: evaluate keys, validate access‑type, perform start with key and comparison type, move record to WS‑OTM3‑Record.  
I/O: Open‑Item‑File‑3.  
Outcomes: FS‑Reply 21 on invalid key, WE‑Error 0, record returned if start succeeds.  
[Seen in: aa060-Process-Start.]  

Path: Write  
Trigger: File‑Function = 5 (fn‑write)  
Key steps: move WS‑OTM3‑Record to file record, write record, handle invalid key.  
I/O: Open‑Item‑File‑3.  
Outcomes: FS‑Reply 22 on invalid key, WE‑Error 0, record written.  
[Seen in: aa070-Process-Write.]  

Path: Delete  
Trigger: File‑Function = 8 (fn‑delete)  
Key steps: move WS‑OTM3‑Record to file record, delete record, handle invalid key.  
I/O: Open‑Item‑File‑3.  
Outcomes: FS‑Reply 21 on invalid key, WE‑Error 0, record deleted.  
[Seen in: aa080-Process-Delete.]  

Path: Rewrite  
Trigger: File‑Function = 7 (fn‑rewrite)  
Key steps: move WS‑OTM3‑Record to file record, rewrite record, handle invalid key.  
I/O: Open‑Item‑File‑3.  
Outcomes: FS‑Reply 21 on invalid key, WE‑Error 0, record rewritten.  
[Seen in: aa090-Process-Rewrite.]  

Path: RDBMS Access  
Trigger: not FS‑Cobol‑Files‑Used (i.e., RDBMS mode).  
Key steps: perform ba‑Process‑RDBMS, which tests record size, loads DB params, calls otm3MT DAL.  
I/O: none directly, but DAL interacts with database.  
Outcomes: WE‑Error set by DAL, FS‑Reply set accordingly.  
[Seen in: ba-Process-RDBMS.]  

5.4 Termination  
Upon exit, aa999‑main‑exit performs log processing if testing is enabled and then transfers control to aa‑main‑exit. [Seen in: aa999-main-exit.]  
The program concludes by executing aa‑Exit, which simply exits the program. [Seen in: aa-Exit.]

---
## acas022
*[17/267]*

### Business/Functional Perspective
### Purchase Ledger File Operations  

**Program Purpose**  
This program handles all create, read, update, and delete (CRUD) actions for the Purchase Ledger. It can work with either flat file storage or a relational database, ensuring the record is written, updated, or removed correctly. The module logs each operation and returns clear status codes so that calling applications can report success or failure to the user. It also checks that the record length matches the expected definition and verifies that database connections are available, protecting data integrity and reducing audit risk.  

**Screen Interactions**  
No direct screens. This program is invoked by another component that supplies the data record and the desired file operation; it returns status information to that component.  

**Messages and Errors**  
The program signals the following outcomes to the caller:  
* **Success** – the requested operation completed without issues.  
* **End of file** – a read operation reached the last record.  
* **Record not found / invalid key** – the specified key does not exist in the file or database.  
* **File access error** – problems opening, closing, or accessing the file (e.g., wrong access type, file not found).  
* **Record size mismatch** – the supplied record is shorter than the defined structure, which can corrupt data.  
* **Database connection error** – the system cannot reach the configured database.  
* **Unexpected error** – any other failure that prevents the operation from completing.  
These statuses are conveyed through standard reply codes rather than detailed technical messages.  

**User Flow Summary**  
1. The user or calling application provides a purchase ledger record (or just the key) and selects an operation such as open, read next, read by key, write, update, delete, or start.  
2. The program opens the file or database connection if required, performs the requested operation, and records the action in the log.  
3. After the operation, the program returns status codes that indicate whether it succeeded, hit the end of the file, could not find the record, or encountered an error.  
4. If a read operation succeeds, the record data is supplied back to the caller for display or further processing.  
5. The caller interprets the status codes and presents an appropriate message to the end‑user, such as “Record updated successfully” or “Record not found.”  

**Program Linkages**  
- purchMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the aa-Process-Flat-File section, setting up logging and validating key usage for certain functions. [Seen in: aa-Process-Flat-File]  
If COBOL files are not in use, the routine calls ba-Process-RDBMS and then exits. [Seen in: aa-Process-Flat-File]  
After record‑size validation, the program dispatches to the appropriate file‑operation paragraph based on the File‑Function value. [Seen in: aa-Process-Flat-File]  

5.2 Initialization  
The entry routine checks that File‑Key‑No is 1 for read‑indexed, start, and delete functions, setting error codes if not. [Seen in: aa-Process-Flat-File]  
It then verifies that the size of the working‑storage record matches the file record, loading database connection parameters if needed. [Seen in: ba012-Test-WS-Rec-Size-2]  

5.3 Core Processing  

Path: File‑Function 1 – Open  
Trigger: File‑Function = 1  
Key steps: Open the Purchase‑File in the mode specified by File‑Access, handle open errors, set Cobol‑File‑Status, and log the operation.  
I/O: Purchase‑File  
Outcomes: fs‑Reply set to 0 on success or error code on failure; WE‑Error updated accordingly.  
[Seen in: aa020-Process-Open]  

Path: File‑Function 5 – Write  
Trigger: File‑Function = 5  
Key steps: Move the supplied record to Purch‑Record, write it, handle invalid‑key errors, and reset status variables.  
I/O: Purchase‑File  
Outcomes: fs‑Reply set to 22 on invalid key, otherwise 0; WE‑Error cleared.  
[Seen in: aa070-Process-Write]  

Path: File‑Function 4 – Read‑Indexed  
Trigger: File‑Function = 4  
Key steps: Read the record by key Purch‑Key, set ws‑Purch‑Record on success, or clear the record on failure.  
I/O: Purchase‑File  
Outcomes: fs‑Reply set to 21 on invalid key, otherwise 0; WE‑Error cleared.  
[Seen in: aa050-Process-Read-Indexed]  

Path: File‑Function 8 – Delete  
Trigger: File‑Function = 8  
Key steps: Delete the record identified by Purch‑Key, handling invalid‑key errors and resetting status.  
I/O: Purchase‑File  
Outcomes: fs‑Reply set to 21 on invalid key, otherwise 0; WE‑Error cleared.  
[Seen in: aa080-Process-Delete]  

Path: File‑Function 9 – Start  
Trigger: File‑Function = 9  
Key steps: Validate access‑type bounds, then start the file at the specified key using the appropriate comparison operator, handling invalid‑key errors.  
I/O: Purchase‑File  
Outcomes: fs‑Reply set to 21 on invalid key, otherwise 0; WE‑Error cleared.  
[Seen in: aa060-Process-Start]  

Path: RDBMS Processing  
Trigger: Cobol files not used (FS‑Cobol‑Files‑Used = false)  
Key steps: Load DB connection parameters, test record size, and call the RDBMS DAL module purchMT with the record and access data.  
I/O: None directly (DAL handles DB access)  
Outcomes: WE‑Error and fs‑Reply set by the DAL; logging performed if Testing‑1.  
[Seen in: ba-Process-RDBMS]  

5.4 Termination  
After completing the chosen operation, aa‑999‑main‑exit performs logging if Testing‑1 and then transfers control to aa‑main‑exit, which calls Ca‑Process‑Logs and finally exits the program. [Seen in: aa-999-main-exit, aa-main-exit, aa-Exit]

---
## acas023
*[18/267]*

### Business/Functional Perspective
### Purchase Ledger File Handler

**Program Purpose**  
This program manages the underlying record set for the Purchase Ledger. It opens the file, reads, writes, updates, and deletes records, and ensures that data is stored consistently whether in flat files or a relational database. By validating keys, checking record sizes, and logging all activity, it protects the integrity of ledger entries and supports audit and compliance requirements.

**Screen Interactions**  
No direct screens. This program is invoked by other parts of the application after data has been entered elsewhere, and it returns results or error signals to that calling context.

**Messages and Errors**  
The program reports whether the requested operation succeeded or failed. Typical failure reasons include:
- **File access errors** (e.g., cannot open or write to the file).
- **Key or record errors** (e.g., key not found, invalid key format, or end‑of‑file reached unexpectedly).
- **Record size mismatch** (the data supplied does not match the expected record layout).
- **Access‑type problems** (unsupported operation requested for the file).
- **Database connectivity or query errors** when operating via the relational‑database layer.
- **General system errors** that prevent completion of the requested action.

When an error occurs, the program logs detailed information and may display a brief message prompting the user to acknowledge the problem before returning control.

**User Flow Summary**  
A user or a higher‑level program initiates an operation such as opening the ledger file, reading a specific record, writing a new record, updating an existing record, or deleting a record. The handler receives the requested action and the relevant data record. It performs the operation on the appropriate storage medium—either a flat file or, when configured, the database—while validating key values and record sizes. After completion, it returns a status indicating success or the type of failure, and any retrieved data is placed back into the caller’s data structures. Throughout, the handler logs the activity for audit and troubleshooting purposes.

**Program Linkages**  
- delfolioMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **aa010‑main**, initializing logging and validating key parameters before deciding whether to process a COBOL flat file or delegate to the RDBMS layer. The **File‑Function** evaluate dispatches to the appropriate paragraph (e.g., **aa020‑Process‑Open**, **aa030‑Process‑Close**, **aa040‑Process‑Read‑Next**, **aa050‑Process‑Read‑Indexed**, **aa060‑Process‑Start**, **aa070‑Process‑Write**, **aa080‑Process‑Delete**, **aa090‑Process‑Rewrite**) to perform the requested file operation. After the operation, the program exits through **aa‑Exit**, performing any necessary logging and returning control to the caller. [Seen in: aa010-main.]

5.2 Initialization  
The program sets up logging identifiers (WS‑Log‑System, WS‑Log‑File‑No) and validates that the File‑Key‑No is 1 for indexed operations, setting **WE‑Error** 998 or 996 and **FS‑Reply** 99 if not. It then checks whether COBOL files are used; if not, it performs **ba‑Process‑RDBMS** to handle the operation via the DAL. Record size is verified by **ba012‑Test‑WS‑Rec‑Size‑2** before any file or database action. [Seen in: aa010-main, ba012-Test-WS-Rec-Size-2.]

5.3 Core Processing  

Path: **Auto‑Run (Program Entry)**  
Trigger: Program start at **aa010‑main**.  
Key steps: Initialize logging, validate key, decide on RDBMS or flat‑file processing, perform record‑size test, dispatch to File‑Function evaluate.  
I/O: None until dispatch.  
Outcomes: Sets **WE‑Error**, **FS‑Reply**, and **Cobol‑File‑Status** appropriately; may invoke **ba‑Process‑RDBMS**.  
[Seen in: aa010-main, ba012-Test-WS-Rec-Size-2, ba-Process-RDBMS.]

Path: **File‑Function Dispatch**  
Trigger: Evaluate of **File‑Function** in **aa010‑main**.  
Key steps: Jump to one of the operation paragraphs (Open, Close, Read‑Next, Read‑Indexed, Start, Write, Rewrite, Delete).  
I/O: Depends on chosen operation; may involve **Del‑Inv‑Nos‑File**.  
Outcomes: Sets **FS‑Reply**, **WE‑Error**, **Cobol‑File‑Status**, and writes/reads/deletes records.  
[Seen in: aa010-main, aa020-Process-Open, aa030-Process-Close, aa040-Process-Read-Next, aa050-Process-Read-Indexed, aa060-Process-Start, aa070-Process-Write, aa080-Process-Delete, aa090-Process-Rewrite, aa100-Bad-Function.]

Path: **Read‑Next Operation**  
Trigger: **aa040‑Process‑Read‑Next** invoked via File‑Function 3.  
Key steps: Check EOF flag, perform READ NEXT, handle end‑of‑file or error, copy record to linkage area.  
I/O: **Del‑Inv‑Nos‑File** read.  
Outcomes: Sets **FS‑Reply** 10 on EOF, **WE‑Error** 0 on success, populates **WS‑Del‑Inv‑Nos‑Record**.  
[Seen in: aa040-Process-Read-Next, aa041-Reread.]

Path: **Write Operation**  
Trigger: **aa070‑Process‑Write** invoked via File‑Function 5.  
Key steps: Move record from linkage to file record, write with invalid‑key handling, set status.  
I/O: **Del‑Inv‑Nos‑File** write.  
Outcomes: **FS‑Reply** 0 on success, **WE‑Error** 0, **Cobol‑File‑Status** 0.  
[Seen in: aa070-Process-Write.]

Path: **Delete Operation**  
Trigger: **aa080‑Process‑Delete** invoked via File‑Function 8.  
Key steps: Move key to file record, delete, set status.  
I/O: **Del‑Inv‑Nos‑File** delete.  
Outcomes: **FS‑Reply** 0 on success, **WE‑Error** 0, **Cobol‑File‑Status** 0.  
[Seen in: aa080-Process-Delete.]

Path: **RDBMS Processing**  
Trigger: **ba‑Process‑RDBMS** called from **aa010‑main** or **ba015‑Test‑Ends**.  
Key steps: Load DB connection parameters, call **delfolioMT** DAL with file access and record, handle errors.  
I/O: DAL module **delfolioMT** (database access).  
Outcomes: Sets **WE‑Error**, **FS‑Reply**, **SQL‑Err**, **SQL‑Msg** as returned by DAL.  
[Seen in: ba-Process-RDBMS, ba020-Process-DAL.]

5.4 Termination  
After completing the requested operation, the program performs any pending logging via **Ca-Process-Logs** if testing is enabled, then exits through **aa‑Exit** which performs a **GOBACK** to the caller. The final status flags (**FS‑Reply**, **WE‑Error**, **Cobol‑File‑Status**) are left in the linkage area for the caller to inspect. [Seen in: aa999-main-exit, aa-main-exit, aa-Exit.]

---
## acas026
*[19/267]*

### Business/Functional Perspective
### Invoice File Handler  

**Program Purpose**  
This program manages purchase‑invoice records stored in a file or database table. It can open, close, read (next or by key), write, update, or delete invoices. The goal is to provide reliable data access and integrity for accounting processes, ensuring that invoices are stored, retrieved, and maintained correctly while logging all operations for audit and troubleshooting purposes.  

**Screen Interactions**  
1. **Record‑size mismatch screen** – When the internal record format does not match the file format, the program displays a warning message on the screen and waits for the user to press return before continuing.  

**Messages and Errors**  
- **Success** – Operation completes and status codes indicate “0” for OK.  
- **End of file** – No more records are available to read; status indicates “10”.  
- **Key not found** – Search or start operations fail to locate the requested invoice; status indicates “21”.  
- **File access errors** – Problems opening, closing, or writing to the file produce an error status (“35” for open failures, “22” for write errors, “21” for delete errors, etc.).  
- **Record‑size mismatch** – The program shows a warning that the temporary record length differs from the invoice record length and pauses for the user to acknowledge.  
- **Database connection or SQL errors** – When the program attempts to use the database layer, any failure (e.g., cannot connect, SQL error) results in a generic error status, and the operation is aborted.  

**User Flow Summary**  
A higher‑level program requests an invoice operation by supplying the desired file function (open, read, write, delete, etc.) and any necessary key values. The Invoice File Handler processes the request, accessing either a flat file or a database table as directed. For read operations, the requested invoice record is returned to the calling program; for write, update, or delete, the handler performs the action and reports success or failure. The user typically sees no screen unless an error occurs—most notably a record‑size mismatch or an unrecoverable database error, which triggers a brief screen with a message and a prompt to press return. After handling the request, the program returns status codes that the caller can use to decide next steps.  

**Program Linkages**  
- plinvoiceMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry begins at aa010‑main which sets up logging and validates key parameters before dispatching based on File‑Function. [Seen in: aa010-main.]  
The File‑Function value determines the path (open, close, read‑next, read‑indexed, start, write, rewrite, delete, or bad‑function) and the corresponding paragraph is performed. [Seen in: aa010-main.]  
After the selected operation completes, control returns to aa‑Exit which exits the program. [Seen in: aa-Exit.]

5.2 Initialization  
Logging parameters WS‑Log‑System and WS‑Log‑File‑No are initialized, and key checks for start, read‑indexed, and delete functions are performed early in aa010‑main. [Seen in: aa010-main.]  
If the program is configured to use RDBMS instead of COBOL files, ba‑Process‑RDBMS is called and the routine exits before any file operations. [Seen in: aa010-main.]

5.3 Core Processing  

Path: Process‑Open  
Trigger: File‑Function = 1 (open) in aa010‑main.  
Key steps: set WS‑File‑Key, open Invoice‑File in appropriate mode, handle Fs‑Reply errors, set Cobol‑File‑Status.  
I/O: Invoice‑File.  
Outcomes: FS‑Reply set to 0 on success or error codes (35, 999) and WE‑Error set accordingly.  
[Seen in: aa020-Process-Open.]

Path: Process‑Read‑Next  
Trigger: File‑Function = 34 (read‑next‑header) in aa010‑main.  
Key steps: check EOF flag, read next record, handle EOF, move record to WS‑PInvoice‑Record, call aa041‑Move‑Inv‑Data.  
I/O: Invoice‑File.  
Outcomes: FS‑Reply 10 on EOF, WE‑Error cleared, WS‑File‑Key set to record key.  
[Seen in: aa040-Process-Read-Next.]

Path: Process‑Read‑Indexed  
Trigger: File‑Function = 4 (read‑indexed) in aa010‑main.  
Key steps: evaluate keys, read Invoice‑File by key WS‑Invoice‑Key, handle invalid key, move record to WS‑PInvoice‑Record.  
I/O: Invoice‑File.  
Outcomes: FS‑Reply 21 on invalid key, WE‑Error cleared, WS‑File‑Key set appropriately.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Process‑Write  
Trigger: File‑Function = 5 (write) in aa010‑main.  
Key steps: move WS‑PInvoice‑Record to Invoice‑Record, write record, handle invalid key.  
I/O: Invoice‑File.  
Outcomes: FS‑Reply 22 on invalid key, WE‑Error cleared, WS‑File‑Key set.  
[Seen in: aa070-Process-Write.]

Path: Process‑Delete  
Trigger: File‑Function = 8 (delete) in aa010‑main.  
Key steps: move WS‑PInvoice‑Record to Invoice‑Record, delete record, handle invalid key.  
I/O: Invoice‑File.  
Outcomes: FS‑Reply 21 on invalid key, WE‑Error cleared, WS‑File‑Key set.  
[Seen in: aa080-Process-Delete.]

Path: Process‑Rewrite  
Trigger: File‑Function = 7 (rewrite) in aa010‑main.  
Key steps: move WS‑PInvoice‑Record to Invoice‑Record, rewrite record, handle invalid key.  
I/O: Invoice‑File.  
Outcomes: FS‑Reply 21 on invalid key, WE‑Error cleared, WS‑File‑Key set.  
[Seen in: aa090-Process-Rewrite.]

Path: RDBMS Processing  
Trigger: FS‑Cobol‑Files‑Used = false in aa010‑main.  
Key steps: perform ba012‑Test‑WS‑Rec‑Size‑2, set DB connection parameters, call plinvoiceMT DAL, exit section.  
I/O: none directly; DAL interacts with database.  
Outcomes: WE‑Error set by DAL, FS‑Reply unchanged, program exits to AA‑Main‑Exit.  
[Seen in: aa010-main, ba-Process-RDBMS.]

5.4 Termination  
The aa‑Exit paragraph simply exits the program, optionally performing log processing if Testing‑1 is set. [Seen in: aa-Exit.]  
The aa999‑main‑exit paragraph performs log processing when Testing‑1 is true before returning to the caller. [Seen in: aa999-main-exit.]

---
## acas029
*[20/267]*

### Business/Functional Perspective
### Sales Invoice File Handler  

#### Program Purpose  
The program manages the Sales Invoice (Open Item 5) data set. It opens, reads, writes, updates, and deletes invoice records, ensuring that each operation is correctly logged and that data integrity is maintained. By validating record sizes, key ranges, and access types, it protects against duplicate entries, missing records, and database connection failures, thereby reducing risk and supporting audit trails for financial reporting.  

#### Screen Interactions  
No direct screens. This program is invoked by other modules after a separate data‑entry step and returns results back to that context.  

#### Messages and Errors  
- **File access errors** – indicates problems opening, closing, or writing to the file (e.g., file not found, permissions issue).  
- **End‑of‑file reached** – informs the caller that no more records are available for reading.  
- **Record not found / invalid key** – the requested invoice or key does not exist in the file.  
- **Duplicate key** – an attempt to write a record that already exists.  
- **Access‑type or key‑number out of range** – the operation requested uses an unsupported key or access type.  
- **Database connection or SQL error** – the underlying database could not be accessed or returned an error.  
- **Unexpected or unknown error** – any other failure not covered above, prompting a general failure notification.  

#### User Flow Summary  
When a user or calling module needs to work with Sales Invoice data, it specifies an operation code (open, read next, read by key, write, update, delete, or close) and provides the necessary key or record data. The program performs the requested action: it opens the file, fetches the next record, retrieves a specific record, adds a new record, updates an existing one, or removes a record. Upon completion, it returns the data record (for reads) or a status code indicating success, failure, or special conditions such as end‑of‑file or duplicate key. If any error occurs, the program supplies a clear message describing the issue so the calling module can decide whether to retry, alert the user, or log the problem.  

#### Program Linkages  
- otm5MT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa010-main, setting up logging and validating key parameters before routing to the appropriate file‑oriented paragraph based on File‑Function. [Seen in: aa010-main.]  
If FS‑Cobol‑Files‑Used is false, the routine immediately delegates to the RDBMS layer via ba-Process‑RDBMS and then exits. [Seen in: aa010-main.]  
Otherwise, the routine evaluates File‑Function and performs one of the open, close, read, write, delete, or rewrite operations, each ending in aa999‑main‑exit before the program terminates. [Seen in: aa010-main.]

5.2 Initialization  
aa010-main initializes logging identifiers (WS‑Log‑System and WS‑Log‑File‑No) and validates File‑Key‑No for start, read‑indexed, and delete functions. [Seen in: aa010-main.]  
It checks FS‑Cobol‑Files‑Used; if false, it calls ba‑Process‑RDBMS and jumps to AA‑Main‑Exit. [Seen in: aa010-main.]  
The routine performs ba012‑Test‑WS‑Rec‑Size‑2 to ensure the working‑storage record length matches the file record length before any file access. [Seen in: aa012-Test‑WS‑Rec‑Size‑2.]  
After these checks, it evaluates File‑Function to dispatch to the appropriate processing paragraph. [Seen in: aa010-main.]

5.3 Core Processing  

Path: Open File  
Trigger: File‑Function = 1 (fn‑open)  
Key steps: Set WS‑File‑Key to spaces, open the file in the requested mode (input, i‑o, output, or extend), handle open errors by setting FS‑Reply and WE‑Error, and set Cobol‑File‑Status to zero.  
I/O: Open‑Item‑File‑5.  
Outcomes: File opened successfully or error status returned; control proceeds to aa999‑main‑exit.  
[Seen in: aa020-Process-Open.]

Path: Read Next Record  
Trigger: File‑Function = 3 (fn‑read‑next)  
Key steps: Check for EOF flag; if not EOF, perform READ NEXT, set EOF flag on end, initialize record, move data to WS‑OTM5‑Record, and call aa041‑Move‑Inv‑Data.  
I/O: Open‑Item‑File‑5.  
Outcomes: Record read into linkage area or EOF status set; control proceeds to aa999‑main‑exit.  
[Seen in: aa040-Process-Read-Next.]

Path: Read Indexed Record  
Trigger: File‑Function = 4 (fn‑read‑indexed)  
Key steps: Evaluate keys, perform READ with key OI5‑Key, handle invalid key by setting FS‑Reply and WE‑Error, or move record to WS‑OTM5‑Record and call aa041‑Move‑Inv‑Data.  
I/O: Open‑Item‑File‑5.  
Outcomes: Record retrieved or error status set; control proceeds to aa999‑main‑exit.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Write Record  
Trigger: File‑Function = 5 (fn‑write)  
Key steps: Move WS‑OTM5‑Record to Open‑Item‑Record‑5, write record, handle invalid key by setting FS‑Reply, then call aa041‑Move‑Inv‑Data.  
I/O: Open‑Item‑File‑5.  
Outcomes: Record written or error status set; control proceeds to aa999‑main‑exit.  
[Seen in: aa070-Process-Write.]

Path: Delete Record  
Trigger: File‑Function = 8 (fn‑delete)  
Key steps: Move WS‑OTM5‑Record to Open‑Item‑Record‑5, delete record, handle invalid key by setting FS‑Reply, then call aa041‑Move‑Inv‑Data.  
I/O: Open‑Item‑File‑5.  
Outcomes: Record deleted or error status set; control proceeds to aa999‑main‑exit.  
[Seen in: aa080-Process-Delete.]

Path: RDBMS Processing  
Trigger: FS‑Cobol‑Files‑Used = false (or explicit call to ba‑Process‑RDBMS)  
Key steps: Test record size with ba012‑Test‑WS‑Rec‑Size‑2, load DB connection parameters, call the DAL module otm5MT with linkage data, and propagate any errors.  
I/O: None directly; DAL accesses database tables.  
Outcomes: RDBMS operation performed; status returned via linkage areas; control returns to aa999‑main‑exit.  
[Seen in: ba-Process-RDBMS.]

5.4 Termination  
aa999‑main‑exit performs optional logging if Testing‑1 is set and then transfers control to aa‑Exit. [Seen in: aa999-main-exit.]  
aa‑Exit simply exits the program, completing cleanup. [Seen in: aa-Exit.]

---
## acas030
*[21/267]*

### Business/Functional Perspective
### Invoice File Handling

#### Program Purpose  
The program opens, reads, writes, updates, and deletes invoice records stored in a COBOL flat file or, if configured, in a relational database. It validates that the data record matches the expected layout, logs each operation, and returns status information to the calling application. By ensuring records are written and retrieved correctly, the program supports accurate financial reporting, audit trails, and risk reduction.

#### Screen Interactions  
No direct screens. This program is invoked by another process that supplies the invoice data and receives the status codes; any user prompts occur only in rare error conditions.

#### Messages and Errors  
- **Success** – the requested file operation completes and a success status is returned.  
- **File access issues** – problems opening, closing, or otherwise accessing the file (e.g., file not found, permission denied).  
- **Record errors** – invalid key values, duplicate keys, or mismatched record length that prevents the operation.  
- **End‑of‑file** – attempting to read past the last record.  
- **Unexpected failures** – database connection problems or internal errors that halt processing.  
- **User acknowledgment** – when a critical error occurs, a brief message is shown and the user is prompted to press return before the program terminates.

#### User Flow Summary  
1. A calling program supplies an invoice record and specifies the desired file function (open, read, write, delete, etc.).  
2. The program validates the record size, attempts the requested operation, and logs the action.  
3. If the operation succeeds, status codes indicating success are returned to the caller, and the caller continues its workflow.  
4. If an error occurs, the program displays an informative message, may request a key press to acknowledge, then returns error codes so the caller can decide how to proceed.  

#### Program Linkages  
- `plautogenMT`  
- `fhlogger`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in **aa010-main**, initializing logging and validating the function parameters. [Seen in: aa010-main.]  
If Cobol files are not used, it delegates to the RDBMS routine via **ba-Process-RDBMS** and then exits. [Seen in: aa010-main.]  
Otherwise, it dispatches to the appropriate file operation paragraph (open, close, read, write, delete, etc.) based on **File-Function**. [Seen in: aa010-main.]  
Each operation paragraph performs the file action, sets status codes, and then returns to **aa999-main-exit** for optional logging before exiting. [Seen in: aa020-Process-Open, aa030-Process-Close, aa040-Process-Read-Next, aa050-Process-Read-Indexed, aa060-Process-Start, aa070-Process-Write, aa080-Process-Delete, aa090-Process-Rewrite.]

5.2 Initialization  
The program sets logging parameters (**WS-Log-System**, **WS-Log-File-No**) and validates **File-Function** and **File-Key-No** for indexed operations. [Seen in: aa010-main.]  
It checks whether Cobol files are used; if not, it calls the RDBMS processing routine and bypasses file handling. [Seen in: aa010-main.]  
It performs a record size test via **ba012-Test-WS-Rec-Size-2** to ensure the in‑memory record matches the file record. [Seen in: ba012-Test-WS-Rec-Size-2.]  
It then evaluates **File-Function** to dispatch to the appropriate operation paragraph. [Seen in: aa010-main.]

5.3 Core Processing  
Path: RDBMS Processing  
Trigger: **FS-Cobol-Files-Used = false**  
Key steps: call **ba-Process-RDBMS**, which tests record size, sets DB connection parameters, and calls the DAL routine **plautogenMT**.  
I/O: none (database access via DAL).  
Outcomes: sets **FS-Reply**, **WE-Error**, and any RDBMS error codes.  
[Seen in: aa010-main, ba-Process-RDBMS.]

Path: File Open  
Trigger: **File-Function = 1**  
Key steps: open the file in input or i‑o mode, set status codes, and handle open errors.  
I/O: **Agen-Invoice-File**.  
Outcomes: **FS-Reply**, **WE-Error**, **Cobol-File-Status**.  
[Seen in: aa020-Process-Open.]

Path: File Read-Next  
Trigger: **File-Function = 34**  
Key steps: read the next record, handle EOF, move record to **WS-PInvoice-Record**, and call **aa041-Move-Inv-Data**.  
I/O: **Agen-Invoice-File**.  
Outcomes: **FS-Reply**, **WE-Error**, **WS-PInvoice-Record**.  
[Seen in: aa040-Process-Read-Next.]

Path: File Write  
Trigger: **File-Function = 5**  
Key steps: write the record, set status codes, and call **aa041-Move-Inv-Data**.  
I/O: **Agen-Invoice-File**.  
Outcomes: **FS-Reply**, **WE-Error**.  
[Seen in: aa070-Process-Write.]

Path: File Delete  
Trigger: **File-Function = 8**  
Key steps: delete the record, set status codes, and call **aa041-Move-Inv-Data**.  
I/O: **Agen-Invoice-File**.  
Outcomes: **FS-Reply**, **WE-Error**.  
[Seen in: aa080-Process-Delete.]

5.4 Termination  
After each operation, the program returns to **aa999-main-exit**, which performs optional logging if **Testing-1** is set and then proceeds to **aa-main-exit**. [Seen in: aa999-main-exit.]  
**aa-main-exit** calls **aa-Exit**, which exits the program. [Seen in: aa-main-exit, aa-Exit.]

---
## acas032
*[22/267]*

### Business/Functional Perspective
### Payments File Handling  

**Program Purpose**  
The program manages payment records by performing create, read, update, and delete operations on either flat files or a relational database. It validates record lengths, checks key ranges, and ensures that each operation is logged and that errors are reported back to the calling context. This guarantees accurate and auditable handling of payment data, supports compliance, and reduces the risk of data corruption.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- Invalid or out‑of‑range key values cause the operation to fail with an error message.  
- When the end of a file is reached, the program reports that no more records are available.  
- If the supplied record does not match the expected size, an error is shown and processing stops.  
- Database connection or SQL errors are reported to the caller.  
- General file open, close, or access errors result in a failure status.  

**User Flow Summary**  
A user or calling program supplies a payment record and a function code (such as read, write, delete, or start). The program checks that the request is valid, accesses the payment file or database, performs the requested action, logs the operation, and returns a status code indicating success or the type of failure. The caller then uses that status to determine the next step, such as displaying a message, retrying the operation, or aborting the transaction.  

**Program Linkages**  
- paymentsMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs at aa010‑main which initializes logging, validates key parameters, and determines whether to use flat file or RDBMS processing. [Seen in: aa010-main.]  
Depending on the File‑Function value, control is transferred to one of the flat‑file operation paragraphs (open, close, read, write, delete, etc.) or to the RDBMS section for database access. [Seen in: aa010-main.]  
After the operation completes, the program exits through aa999‑main‑exit, aa‑main‑exit, and aa‑Exit, returning FS‑Reply and WE‑Error status to the caller. [Seen in: aa999-main-exit.]

5.2 Initialization  
aa010‑main sets the log system and file numbers, checks that File‑Key‑No is 1 for indexed operations, and verifies that the key type is valid for the requested function. [Seen in: aa010-main.]  
It then tests the record size with ba012‑Test‑WS‑Rec‑Size‑2, loads RDBMS connection parameters, and if flat files are not used, invokes ba‑Process‑RDBMS before proceeding to the operation paragraph. [Seen in: ba012-Test-WS-Rec-Size-2, ba-Process-RDBMS.]

5.3 Core Processing  

Path: Flat File Open  
Trigger: File‑Function = 1  
Key steps: open input, i‑o, output, or extend file as requested; set status and log.  
I/O: Pay‑File.  
Outcomes: FS‑Reply set (0 or error), Cobol‑File‑Status zero, WS‑File‑Key set to “OPEN Payment File”.  
[Seen in: aa020-Process-Open.]

Path: Flat File Read Next  
Trigger: File‑Function = 3  
Key steps: read next record, handle EOF, populate WS‑Pay‑Record, set WS‑File‑Key.  
I/O: Pay‑File.  
Outcomes: FS‑Reply 0 or 10 for EOF, WE‑Error zero, WS‑Pay‑Record contains data.  
[Seen in: aa040-Process-Read-Next.]

Path: Flat File Read Indexed  
Trigger: File‑Function = 4  
Key steps: read record by key, set error if invalid key.  
I/O: Pay‑File.  
Outcomes: FS‑Reply 0 or 21 for invalid key, WS‑Pay‑Record populated.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Flat File Write  
Trigger: File‑Function = 5  
Key steps: write record, set error on invalid key.  
I/O: Pay‑File.  
Outcomes: FS‑Reply 0 or 21, WS‑File‑Key set to Pay‑Key.  
[Seen in: aa070-Process-Write.]

Path: Flat File Delete  
Trigger: File‑Function = 8  
Key steps: delete current record.  
I/O: Pay‑File.  
Outcomes: FS‑Reply 0 or 21, WS‑File‑Key set.  
[Seen in: aa080-Process-Delete.]

Path: RDBMS Processing  
Trigger: FS‑Cobol‑Files‑Used = false (i.e., flat files not used)  
Key steps: test record size, load DB parameters, call paymentsMT DAL, propagate errors.  
I/O: DAL module via call to paymentsMT; database accessed internally.  
Outcomes: FS‑Reply and WE‑Error set by DAL, SQL‑Err and SQL‑Msg may be populated.  
[Seen in: ba-Process-RDBMS, ba020-Process-DAL.]

5.4 Termination  
aa999‑main‑exit performs optional logging if Testing‑1 is set and then transfers control to aa‑main‑exit. [Seen in: aa999-main-exit.]  
aa‑main‑exit calls Ca‑Process‑Logs if needed, clears File‑Function and Access‑Type, and finally aa‑Exit exits the program. [Seen in: aa-main-exit, aa-Exit.]

---
## acasconvert1
*[23/267]*

### Business/Functional Perspective
### Posting Data Conversion  

**Program Purpose**  
This program converts the company’s posting records from the legacy file format to the current system layout. It reads each existing transaction, rewrites it into the updated structure, and writes the results to a new file. By automating this migration, the program ensures that all financial entries remain accurate and compliant with the latest reporting requirements. The conversion runs in the background, providing only a final summary of how many records were processed.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- Startup message indicating the program has begun.  
- Completion message displaying the total number of records written.  
- Error notification if the input postings file cannot be opened, causing the program to stop.  
- Error notification if the output file cannot be opened, causing the program to stop.  
- Error notification if a record cannot be read from the input file, causing the program to stop.  
- Error notification if a record cannot be written to the output file, causing the program to stop.  
- A brief progress indicator (a star) shown for each record processed.  

**User Flow Summary**  
When a user starts the conversion, the program announces its initiation and begins reading the existing postings file. Each transaction is rewritten into the new format and written to the destination file. The user sees a quick progress symbol for each record processed. Once all records have been handled, a final message appears showing how many records were written, after which the program terminates. No further interaction is required from the user during the run.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph AA000-Start, opening the input postings file and preparing the output postings file. [Seen in: AA000-Start.]  
It then enters the AA010-Read paragraph, which loops reading each posting record until end‑of‑file. [Seen in: AA010-Read.]  
Upon completion, the program displays a completion message and terminates. [Seen in: AA010-Read.]

5.2 Initialization  
The AA000-Start paragraph performs file open operations for post‑In and postings, checking fs‑reply for errors and displaying error messages if necessary. [Seen in: AA000-Start.]  
It also displays the program name and a start message before proceeding to the read loop. [Seen in: AA000-Start.]

5.3 Core Processing  
Path: Read Loop  
Trigger: Execution of AA010-Read after a successful read of a posting record.  
Key steps: Read next record, move fields from input record to working variables, write to output posting‑record, increment rec‑count, loop back to AA010-Read.  
I/O: post‑In (input), postings (output).  
Outcomes: rec‑count incremented, record written to output.  
[Seen in: AA010-Read.]

Path: End of File  
Trigger: Read statement reaches end‑of‑file condition.  
Key steps: Close post‑In and postings, display completion message with rec‑count, display program end, stop run.  
I/O: post‑In, postings.  
Outcomes: program terminates after closing files.  
[Seen in: AA010-Read.]

Path: Read Error  
Trigger: fs‑reply not zero after a read attempt.  
Key steps: Display error message with fs‑reply, stop run.  
I/O: none beyond display.  
Outcomes: program terminates with error.  
[Seen in: AA010-Read.]

Path: Write Record  
Trigger: Successful write of posting‑record after moving fields.  
Key steps: Write posting‑record, check fs‑reply, if zero increment rec‑count.  
I/O: postings.  
Outcomes: record written, rec‑count updated.  
[Seen in: AA010-Read.]

Path: Write Error  
Trigger: fs‑reply not zero after write.  
Key steps: Display error message, close post‑In and postings, stop run.  
I/O: post‑In, postings.  
Outcomes: program terminates with error.  
[Seen in: AA010-Read.]

5.4 Termination  
The program closes both input and output files and displays a final completion message before stopping. [Seen in: AA010-Read.]  
The stop run statement ends execution, returning control to the operating system. [Seen in: AA010-Read.]

---
## acasconvert2
*[24/267]*

### Business/Functional Perspective
### ACAS System File Conversion  

**Program Purpose**  
The program updates the ACAS system configuration file from version 1.2 to 1.3. It reads the existing file, adjusts the version numbers, and rewrites the record with any new fields. The update ensures that the system’s flat‑file layout remains compatible with later modules and that the file size matches the new structure. This safeguards the integrity of critical configuration data and allows the accounting system to run without data‑corruption risks.  

**Screen Interactions**  
No dedicated screens are defined. The program runs as a console utility, displaying status messages and accepting a single “return” key press to finish.  

**Messages and Errors**  
- **File open failure** – the system file cannot be accessed.  
- **Record size mismatch** – the existing record does not match the required new size; conversion is aborted.  
- **Record read error** – the first record cannot be located.  
- **Disk write error** – the updated record could not be written.  
- **Success** – the file conversion completes successfully and the user is advised to review system setup.  

**User Flow Summary**  
The operator starts the utility from a terminal or batch job. The program immediately checks that the system file’s record size matches the expected new layout; if not, it reports the mismatch and stops. If the size is correct, it opens the file, reads the first record, copies its data into a new structure, updates the version numbers to 1.3, and rewrites the record. Any file‑access or write problems are reported, after which the utility terminates. When the operation succeeds, a completion message is shown and the user is prompted to press return, after which the program ends. The operator then proceeds with the normal system‑setup procedures to confirm that all configuration data are intact.  

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **AA000-Start**, performing a size check of the old and new system record structures, opening the system file, and displaying a start message. [Seen in: AA000-Start.]  
It then reads the first record from the system file, copies it into a new record structure, updates the version fields, and rewrites the record, displaying a completion message before exiting. [Seen in: AA010-Read.]  
Any disk errors encountered during opening, reading, or rewriting are handled by the **Disk-Error-Display** and **Disk-Error** paragraphs, which display error messages and halt execution. [Seen in: AA010-Read.]

5.2 Initialization  
The program verifies that the old and new system record lengths match; if not, it displays an error and stops. [Seen in: AA000-Start.]  
It opens the system file for I/O, initializing the display block and setting the record number to 1 before reading. [Seen in: AA000-Start.]

5.3 Core Processing  
Path: Size Verification  
Trigger: Program start  
Key steps: compute lengths of Old-System-Record and System-Record, compare, display error if mismatch, stop.  
I/O: none  
Outcomes: stops program if mismatch.  
[Seen in: AA000-Start.]

Path: File Open  
Trigger: After size check  
Key steps: open system-file for i-o, check fs-reply, display error if non-zero, stop.  
I/O: system-file  
Outcomes: sets fs-reply, may stop.  
[Seen in: AA000-Start.]

Path: Record Read & Conversion  
Trigger: After file open  
Key steps: set rrn to 1, read system-file into Old-System-Record, initialize System-Record, copy corresponding, set version fields, rewrite System-Record, perform Disk-Error-Display.  
I/O: system-file  
Outcomes: updates record, may trigger error display.  
[Seen in: AA010-Read.]

Path: Disk Error Handling  
Trigger: fs-reply not zero after rewrite or open  
Key steps: display SY103, fs-reply, call Disk-error.  
I/O: none  
Outcomes: prompts user, may stop.  
[Seen in: Disk-Error-Display.]

Path: Program Termination  
Trigger: After successful rewrite  
Key steps: display completion message, stop run.  
I/O: none  
Outcomes: program ends.  
[Seen in: AA010-Read.]

5.4 Termination  
Upon successful completion, the program displays a completion message and stops, after closing the system file. [Seen in: AA010-Read.]  
If any disk error occurs, the program displays error messages, prompts for input, and stops. [Seen in: Disk-Error-Display.]

---
## acasconvert3
*[25/267]*

### Business/Functional Perspective
### Invoice File Conversion  

**Program Purpose**  
The program updates the stored invoice data to a newer file layout. It renames the existing invoice file, reads each record in the old format, rewrites it in the new format, and writes the result to a new file. The conversion preserves all business information while ensuring the data file is compatible with newer reporting and processing routines, reducing the risk of data loss during system upgrades.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- A brief start message displays the program name.  
- If the program cannot rename or delete the existing invoice file, it stops and notifies the user of a renaming error.  
- If it cannot open the old invoice file, it stops and reports an opening error.  
- If any read or write operation fails, it stops and displays a read or write error message.  
- Upon successful completion, it displays a confirmation that the conversion to v3.02 finished.  

**User Flow Summary**  
The user (typically a system administrator or batch operator) initiates the program. It first backs up the current invoice data by deleting any existing backup and renaming the active file. The program then reads each record from the old file, converts it to the new format, and writes the converted record to a new invoice file. After all records are processed, it closes both files and shows a completion message. If any step fails, the program stops and informs the user of the issue, allowing corrective action before restarting the process.  

**Program Linkages**  
- CBL_DELETE_FILE  
- CBL_RENAME_FILE

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by deleting any existing backup file, renaming the current invoice file to a backup, and opening the old and new invoice files. [Seen in: AA000-Start.]  
It then enters a read loop that processes each record from the old file, distinguishing between header and line records based on the item number field. [Seen in: AA010-Read.]  
Upon reaching end‑of‑file, the program closes both files, displays a completion message, and exits. [Seen in: AA020-End.]

5.2 Initialization  
The start paragraph deletes any existing backup file, renames the current invoice file to a backup, and opens the old invoice file for input and the new invoice file for output. [Seen in: AA000-Start.]  
It also displays the program name and a start message before entering the processing loop. [Seen in: AA000-Start.]

5.3 Core Processing  
Path: Header Record Processing  
Trigger: Old‑Item‑Nos = zero (no line records for the invoice).  
Key steps: move record to SInvoice‑Header, initialize Invoice‑Header, move corresponding fields, move sih‑Test to ih‑Test, write Invoice‑Header.  
I/O: Old‑Invoice‑File (read), Invoice‑File (write).  
Outcomes: new header record written; ih‑Test set.  
[Seen in: AA010-Read.]

Path: Line Record Processing  
Trigger: Old‑Item‑Nos ≠ zero (line records present).  
Key steps: move record to SInvoice‑Bodies, initialize Invoice‑Line, move corresponding fields, set il‑Line, write Invoice‑Line.  
I/O: Old‑Invoice‑File (read), Invoice‑File (write).  
Outcomes: new line record written.  
[Seen in: AA010-Read.]

Path: Read Error Handling  
Trigger: fs‑reply ≠ zero after a read.  
Key steps: display error message, stop run, close Invoice‑File and Old‑Invoice‑File.  
I/O: Old‑Invoice‑File (read).  
Outcomes: program aborts immediately.  
[Seen in: AA010-Read.]

Path: Write Error Handling  
Trigger: fs‑reply ≠ zero after a write.  
Key steps: display error message, stop run, close Invoice‑File and Old‑Invoice‑File.  
I/O: Invoice‑File (write).  
Outcomes: program aborts immediately.  
[Seen in: AA010-Read.]

Path: End‑of‑File  
Trigger: fs‑reply = 10 after a read.  
Key steps: go to AA020-End.  
I/O: Old‑Invoice‑File (read).  
Outcomes: exit processing loop.  
[Seen in: AA010-Read.]

5.4 Termination  
The AA020-End paragraph closes the old and new invoice files, displays a completion message, and stops the program. [Seen in: AA020-End.]  
If an error occurs during reading or writing, the program displays an error message, closes the files, and stops immediately. [Seen in: AA010-Read.]

---
## acas-get-params
*[26/267]*

### Business/Functional Perspective
### Get RDBMS Parameters  

**Program Purpose**  
The program retrieves database connection settings from a configuration file (`acas.param`) and places them into a linkage area that other modules can use. This ensures that database‑dependent processes receive the correct host, user, password, database name, port, and socket information without requiring manual entry. By automating this step, the system reduces the risk of misconfiguration, supports smooth database connectivity, and maintains consistency across modules that load tables from COBOL files.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – All parameters were read and stored correctly.  
- **File not found** – The `acas.param` file does not exist.  
- **Syntax error** – A line in the file does not contain a valid “=” or “:” separator.  
- **Unknown keyword** – A line contains a keyword that the program does not recognize (e.g., not one of DBHOST, DBUSER, DBPASS, DBNAME, DBPORT, DBSOCK).  

**User Flow Summary**  
When a database‑dependent module starts, it calls this program. The program first checks whether the required database settings are available; if they are not, it looks for the `acas.param` file. It reads the file line by line, splits each line at the “=” or “:” delimiter, and copies the value of each recognized keyword into the linkage area. If the file is missing, a line is malformed, or an unexpected keyword appears, the program stops and returns an error code that the calling module can interpret. The calling module then proceeds or aborts based on the returned status, ensuring that only valid, complete database connection data are used.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by checking for existence of acas.param file and returns error if not found. [Seen in: aa000-Main.]  
If the file exists, it opens the file and reads each record, parsing key‑value pairs into linkage variables. [Seen in: aa000-Main.]  
After processing all records, it closes the file and returns control to the caller. [Seen in: aa000-Main.]

5.2 Initialization  
The program initializes the return code to zero and clears the linkage RDB variables before any processing. [Seen in: aa000-Main.]  
It then calls the file existence routine and opens the ACAS‑Params file for input. [Seen in: aa000-Main.]

5.3 Core Processing  
Path: File Not Found  
Trigger: CBCheckFileExist returns non‑zero.  
Key steps: set LK‑Return to 8 and goback.  
I/O: none.  
Outcomes: caller receives return code 8 indicating missing file.  
[Seen in: aa000-Main.]

Path: Invalid Terminator  
Trigger: Unstring finds delimiter not '=' or ':'.  
Key steps: set LK‑Return to 1 and goback.  
I/O: none.  
Outcomes: caller receives return code 1 indicating bad terminator.  
[Seen in: aa000-Main.]

Path: Invalid Keyword  
Trigger: Evaluate finds keyword not among expected DBHOST, DBUSER, DBPASS, DBNAME, DBPORT, DBSOCK.  
Key steps: set LK‑Return to 2 and goback.  
I/O: none.  
Outcomes: caller receives return code 2 indicating unknown keyword.  
[Seen in: aa000-Main.]

Path: Successful Read  
Trigger: Each record read with FS‑Reply zeros and valid keyword and terminator.  
Key steps: unstring record, evaluate keyword, move value to appropriate linkage variable.  
I/O: ACAS‑Params file.  
Outcomes: linkage variables populated, LK‑Return remains zero.  
[Seen in: aa000-Main.]

5.4 Termination  
The program closes the ACAS‑Params file and performs a GOBACK to return control to the caller. [Seen in: aa000-Main.]  
The final LK‑Return value indicates success (0) or the specific error code. [Seen in: aa000-Main.]

---
## acasirsub1
*[27/267]*

### Business/Functional Perspective
### Nominal Ledger File Handler  

**Program Purpose**  
This program provides the core read, write, delete and navigation functions for the Nominal Ledger. It validates keys, prevents duplicate entries, and records each operation for audit and troubleshooting. By guaranteeing that ledger entries are accurately stored and retrieved, it supports compliance, financial integrity and smooth downstream reporting.  

**Screen Interactions**  
No direct screens. This program is invoked by other modules that supply data and an operation code, then receives status information and any retrieved record in return.  

**Messages and Errors**  
- **Success** – operation completed.  
- **End of file** – no more records to read.  
- **Record not found** – key does not match any existing entry.  
- **Duplicate key** – attempt to add a record that already exists.  
- **Permission denied** – file cannot be opened for the requested mode (input, output, read‑write).  
- **File access error** – the file is not open, or an unexpected I/O failure occurs.  
- **Database error** – an error occurred while communicating with the underlying database.  
- **Unexpected failure** – an unspecified problem prevented the requested action.  

**User Flow Summary**  
A higher‑level program calls this handler with a record (or a key) and a function code such as “open”, “read next”, “write”, “rewrite”, “delete” or “close”. The handler opens the file if needed, performs the requested action, and returns the status and, for reads, the record data. If the operation is successful the user sees the updated ledger or the retrieved record; if not, the handler supplies a clear message indicating why the action could not be completed. All operations are logged for audit purposes.  

**Program Linkages**  
- irsnominalMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph aa010‑main, initializing logging and validating key parameters for start, read‑indexed and delete operations. It then handles a special open‑output case, performs any required RDBMS processing, and tests the record size before dispatching to the appropriate function paragraph based on File‑Function. Finally, it executes the selected operation paragraph and exits via aa‑Exit. [Seen in: aa010-main.]

5.2 Initialization  
The entry paragraph aa010‑main sets logging identifiers, checks that File‑Key‑No is 1 for start, read‑indexed and delete functions, and sets error codes if not. It then performs a special delete‑all routine for open‑output requests, invokes RDBMS processing if FS‑Cobol‑Files‑Used is false, and calls ba012‑Test‑WS‑Rec‑Size‑2 to verify record length. [Seen in: aa010-main.]

5.3 Core Processing  

Path: Open  
Trigger: File‑Function = 1 (fn‑Open)  
Key steps: set WS‑File‑Key, open the nominal‑ledger file in the requested mode (input, i‑o, or output), handle duplicate‑open or permission errors, and set error codes accordingly.  
I/O: nominal‑ledger file.  
Outcomes: file opened, FS‑Reply and WE‑Error set, logging performed, then exit to aa‑Exit.  
[Seen in: aa020-Process-Open.]

Path: Close  
Trigger: File‑Function = 2 (fn‑Close)  
Key steps: close nominal‑ledger file, reset status, log closure, and perform log processing.  
I/O: nominal‑ledger file.  
Outcomes: file closed, FS‑Reply and WE‑Error cleared, program exits.  
[Seen in: aa030-Process-Close.]

Path: Read‑Next  
Trigger: File‑Function = 3 (fn‑Read‑Next)  
Key steps: read next record, handle EOF, ignore sub‑nominal pointers, initialize record if EOF, and set WS‑NL‑Record.  
I/O: nominal‑ledger file.  
Outcomes: WS‑NL‑Record populated, FS‑Reply and WE‑Error set for EOF or read failure.  
[Seen in: aa040-Process-Read-Next.]

Path: Read‑Indexed  
Trigger: File‑Function = 4 (fn‑Read‑Indexed)  
Key steps: copy key to Key‑1, read record by key, handle invalid key, resolve sub‑nominal pointer if present, and set WS‑NL‑Record.  
I/O: nominal‑ledger file.  
Outcomes: WS‑NL‑Record populated, FS‑Reply and WE‑Error set for invalid key.  
[Seen in: aa050-Process-Read-Indexed.]

Path: Write  
Trigger: File‑Function = 5 (fn‑Write)  
Key steps: write record, handle duplicate key error, if owner then exit, otherwise write sub‑nominal record, set pointers, and log each write.  
I/O: nominal‑ledger file.  
Outcomes: record written (or error), FS‑Reply and WE‑Error set for duplicate key, WS‑File‑Key updated.  
[Seen in: aa070-Process-Write.]

Path: Delete  
Trigger: File‑Function = 8 (fn‑Delete)  
Key steps: delete primary record, if owner then exit, otherwise delete sub‑nominal pointer record.  
I/O: nominal‑ledger file.  
Outcomes: record(s) deleted, FS‑Reply and WE‑Error cleared, WS‑File‑Key updated.  
[Seen in: aa080-Process-Delete.]

5.4 Termination  
After completing the selected operation, the program performs any pending log processing in aa‑999‑main‑exit, then exits the program via aa‑Exit, ensuring all resources are released. [Seen in: aa-Exit.]

---
## acasirsub3
*[28/267]*

### Business/Functional Perspective
### IRS Default File Processing  

**Program Purpose**  
The program provides a single point of access to the IRS default data file. It supports reading the next record and writing a record while maintaining consistent file handling and basic error reporting. By centralizing file access, the system ensures that default data is read and written correctly, which is essential for accurate tax processing and compliance reporting.  

**Screen Interactions**  
No direct screens. This program is invoked by other components after a data‑entry step and returns the result back to that context.  

**Messages and Errors**  
- **File open failure** – if the program cannot open the default file for reading or writing.  
- **Read failure** – if a record cannot be read (e.g., file is missing or corrupted).  
- **Write failure** – if a record cannot be written to the file.  
- **End‑of‑file** – the program indicates that no more records are available.  
- **Record length mismatch** – the incoming record size does not match the expected size.  
- **Invalid function** – an unsupported file‑function code is supplied.  

**User Flow Summary**  
When a calling routine wants to access the IRS default file it supplies a record (or an empty placeholder for reading) and a function code:  
1. **Read next (code 3)** – The program opens the file, reads the next record, closes the file, and returns the record to the caller along with a status flag.  
2. **Write (code 5)** – The program opens the file, writes the supplied record, closes the file, and signals success or failure.  
The program also handles logging for auditing purposes, but the caller sees only the record data and a simple success/failure indicator.  

**Program Linkages**  
- irsdfltMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph **aa010-main**, setting logging parameters and determining whether to process a COBOL flat file or delegate to the RDBMS layer. If COBOL files are not used, **ba-Process-RDBMS** is performed and the program exits. Otherwise, the record size is validated and the **File-Function** value selects one of the read, write, or error paths, after which the program terminates. [Seen in: aa010-main.]

5.2 Initialization  
The routine **aa010-main** initializes logging fields, checks the **FS-Cobol-Files-Used** flag, and if false performs **ba-Process-RDBMS** to handle RDBMS operations. It then calls **ba012-Test-WS-Rec-Size-2** to verify record lengths and clears error/status fields before dispatching to the appropriate file‑function paragraph. [Seen in: aa010-main.]

5.3 Core Processing  

Path: Read‑Next  
Trigger: **File-Function = 3**  
Key steps: open **Default-File** for input, create the file with a default record if the file is missing, read the next record, handle EOF or read errors, and close the file.  
I/O: **Default-File**.  
Outcomes: **FS-Reply**, **WE-Error**, **Cobol-File-Status**, and **WS-File-Key** are set to indicate success, EOF, or errors.  
[Seen in: aa040-Process-Read-Next.]

Path: Write  
Trigger: **File-Function = 7**  
Key steps: open **Default-File** for output, write the supplied record, close the file, and set status flags.  
I/O: **Default-File**.  
Outcomes: **FS-Reply**, **WE-Error**, and **WS-File-Key** reflect write success or failure.  
[Seen in: aa070-Process-Write.]

Path: Bad‑Function  
Trigger: any **File-Function** value other than 1, 2, 3, 5, or 7.  
Key steps: set **WE-Error** to 999 and **FS-Reply** to 99 to indicate an unsupported function.  
I/O: none.  
Outcomes: error status codes are returned to the caller.  
[Seen in: aa100-Bad-Function.]

Path: RDBMS‑Read‑Next  
Trigger: **fn-read-next** flag set in **ba-Process-RDBMS**.  
Key steps: set open/read flags, call **ba020-Call-DAL** to open the table, perform a read via the DAL, capture **FS-Reply** and **WE-Error**, close the table, and log the operation.  
I/O: implicit database access via the DAL.  
Outcomes: **FS-Reply**, **WE-Error**, and **WS-File-Key** indicate the result of the read operation.  
[Seen in: ba020-Call-DAL.]

Path: RDBMS‑Write  
Trigger: **fn-write** flag set in **ba-Process-RDBMS**.  
Key steps: open the table, perform a write via the DAL, capture status codes, close the table, and log the operation.  
I/O: implicit database access via the DAL.  
Outcomes: **FS-Reply**, **WE-Error**, and **WS-File-Key** reflect the write result.  
[Seen in: ba020-Call-DAL.]

5.4 Termination  
After completing the requested operation, the program performs any pending log processing in **aa999-main-exit** if **Testing-1** is set, then exits via **aa-Exit**. No explicit file close is required for COBOL files because each operation opens and closes the file locally. [Seen in: aa999-main-exit, aa-Exit.]

---
## acasirsub4
*[29/267]*

### Business/Functional Perspective
### IRS Posting File Handler  

---

**Program Purpose**  
The program manages IRS posting records stored in a file. It allows the user or a calling system to open, close, read, write, update, and delete posting entries, and to start positioned reads. The routine validates record structure, ensures keys are within the allowed range, and coordinates with a relational database layer when required. By enforcing correct file operations, it supports accurate tax reporting and audit‑ready data handling.  

---

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry step and returns results back to that context.  

---

**Messages and Errors**  
- **Invalid Operation** – If the requested file function is unsupported or the key value is out of range, the routine signals an error and halts.  
- **File Access Errors** – Problems opening, closing, or writing to the file (e.g., file not found, disk full) cause a stop with a descriptive message.  
- **Record‑Length Mismatch** – If the internal record format does not match the defined structure, the program displays a warning, asks the user to acknowledge, and then stops.  
- **Key Errors** – Attempts to start, read, or delete using an invalid key produce an error code and stop the process.  
- **General Failure** – Any other unexpected error is reported with a generic error code and the program exits.  

The user‑visible messages are plain English prompts such as “Note error and hit return” or “Programming error: temporary record length is wrong.”  

---

**User Flow Summary**  
1. The user or a calling routine supplies the desired file function (open, close, read, write, etc.) along with any required key or record data.  
2. The program opens the IRS posting file if necessary, then performs the requested action.  
3. For read operations, the program returns the requested posting record; for write, update, or delete operations, it confirms the action through a status code.  
4. If an error occurs, the program presents a clear message, may wait for the user to acknowledge, and then stops.  
5. Upon successful completion, control returns to the caller or the next step in the batch process.  

---

**Program Linkages**  
- irspostingMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **aa010-main**, initializing logging and validating the file key before dispatching to the appropriate file operation paragraph. [Seen in: aa010-main.]  
Depending on the **File-Function** value, it performs one of the file operations (open, close, read, write, delete, etc.) or invokes the RDBMS routine **ba-Process-RDBMS** when Cobol files are not used. [Seen in: aa010-main.]  
After completing the requested operation, the program logs the result (if testing enabled) and exits via **aa-Exit**. [Seen in: aa999-main-exit.]

5.2 Initialization  
**aa010-main** sets the logging system identifiers (**WS-Log-System** and **WS-Log-File-No**) and clears status variables such as **WE-Error** and **Cobol-File-Status**. [Seen in: aa010-main.]  
It then verifies that the **File-Key-No** is 1 for start, read-indexed, and delete operations, setting error 998 or 996 and exiting if not. [Seen in: aa010-main.]  
If the program is called for an output open without Cobol files, it performs the RDBMS routine **ba-Process-RDBMS** and exits; otherwise it performs a record‑size test **ba012-Test-WS-Rec-Size-2** before dispatching to the file‑function paragraph. [Seen in: aa010-main.]

5.3 Core Processing  
Path: **Open**  
Trigger: **File-Function = 1** (fn-input, fn-i-o, fn-output, fn-extend)  
Key steps: open the Posting‑File in the requested mode, set **WS-File-Key** for logging, and handle **Fs-Reply** errors.  
I/O: **Posting-File**.  
Outcomes: **WE-Error** set if **Fs-Reply** non‑zero; **Cobol-File-Status** cleared; control returns to **aa999-main-exit**.  
[Seen in: aa020-Process-Open.]

Path: **Read‑Next**  
Trigger: **File-Function = 3**  
Key steps: check EOF flag, read the next record, handle EOF by setting **WE-Error** 10 and **Cobol-File-Status** 1, initialize **Posting-Record**, and set **WS-File-Key**.  
I/O: **Posting-File**.  
Outcomes: **Posting-Record** populated; **WE-Error** cleared on success; control returns to **aa999-main-exit**.  
[Seen in: aa040-Process-Read-Next / aa041-Reread.]

Path: **Start**  
Trigger: **File-Function = 9**  
Key steps: validate **access-type**, perform a **START** on **Posting-File** with the appropriate key comparison (equal, not‑less‑than, greater‑than, less‑than), then perform **aa999-main-exit** and jump to **aa041-Reread** to read the first record.  
I/O: **Posting-File**.  
Outcomes: **WE-Error** set if the start fails; **Posting-Record** read after start; control proceeds to **aa999-main-exit**.  
[Seen in: aa060-Process-Start / aa041-Reread.]

Path: **Write**  
Trigger: **File-Function = 5**  
Key steps: write **Record-4** (containing **Posting-Record**) to **Posting-File**, increment **Post-Key**, and loop until an invalid key error occurs.  
I/O: **Posting-File**.  
Outcomes: **WE-Error** cleared; **Cobol-File-Status** zero; control returns to **aa999-main-exit**.  
[Seen in: aa070-Process-Write.]

Path: **Delete**  
Trigger: **File-Function = 8**  
Key steps: delete the record at **Post-Key** from **Posting-File**.  
I/O: **Posting-File**.  
Outcomes: **WE-Error** cleared; **Cobol-File-Status** zero; control returns to **aa999-main-exit**.  
[Seen in: aa080-Process-Delete.]

Path: **RDBMS**  
Trigger: **FS-Cobol-Files-Used = false** (or special open‑output without Cobol files)  
Key steps: perform **ba-Process-RDBMS**, which calls the DAL routine **irspostingMT** with **Posting-Record** and system data.  
I/O: RDBMS via the DAL (no explicit file).  
Outcomes: **WE-Error** may be set by the DAL; program exits to **aa-Exit**.  
[Seen in: aa010-main / ba-Process-RDBMS.]

5.4 Termination  
After each operation, **aa999-main-exit** logs the result if testing is enabled and then transfers control to **aa-main-exit**. [Seen in: aa999-main-exit.]  
**aa-main-exit** performs any final log processing via **Ca-Process-Logs**, clears **File-Function** and **Access-Type**, and then calls **aa-Exit** to terminate the program. [Seen in: aa-main-exit.]

---
## acasirsub5
*[30/267]*

### Business/Functional Perspective
### IRS Final File Handling  

#### Program Purpose  
The program manages IRS Final records by reading, writing, or rewriting individual records in a flat file or via a database layer. It validates record sizes, handles file access errors, and logs each operation for audit purposes. This ensures that final tax data is transferred accurately, meets regulatory compliance, and reduces the risk of data corruption.  

#### Screen Interactions  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

#### Messages and Errors  
- **File access errors** – If the final file cannot be opened for reading or writing, the program stops and informs the user that the file could not be accessed.  
- **Record size mismatch** – If the internal record size does not match the expected size, the user is notified, prompted to acknowledge, and the program halts to prevent corrupted data.  
- **Unexpected end‑of‑file** – If the program reaches the end of the file when a record was expected, it reports the condition and stops the operation.  
- **Read or write failures** – Any failure during a read or write operation results in a clear error message and the program terminates the current action.  
- **General operational errors** – Any other errors encountered during processing are reported with a brief description, after which the user is asked to press return to exit.  

#### User Flow Summary  
1. The user initiates a file operation (read next, write, or rewrite) through the calling application.  
2. The program opens the IRS Final file, checks the record size, and proceeds with the requested action.  
3. If the operation succeeds, the program displays a success message (e.g., “Open Final, Read, Close on 1”) and closes the file.  
4. If any error occurs—such as a file access issue, record size mismatch, or read/write failure—the user sees an explanatory message, may press return to acknowledge, and the program terminates that operation.  
5. After completion, control returns to the calling context, which may display the final status to the user or continue with subsequent steps.  

#### Program Linkages  
- irsfinalMT  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs at paragraph **aa010-main**, which sets logging identifiers and determines whether to process Cobol flat files or delegate to the RDBMS module. [Seen in: aa010-main.]  
If Cobol files are used, the routine performs a record‑size test, initializes error variables, and dispatches to the appropriate file operation paragraph based on the File‑Function value. [Seen in: aa010-main.]  
After the file operation completes, the program performs any required logging, exits the RDBMS section if invoked, and terminates via **aa-Exit**. [Seen in: aa999-main-exit, aa-Exit.]

5.2 Initialization  
The program initializes logging identifiers (**WS-Log-System**, **WS-Log-File-No**) and clears error and status fields before any file processing. [Seen in: aa010-main.]  
It checks the **FS-Cobol-Files-Used** flag; if false, it forwards control to the RDBMS processing section **ba-Process-RDBMS** and exits the flat‑file path. [Seen in: aa010-main.]

5.3 Core Processing  
Path: Read‑Next  
Trigger: **File‑Function = 3** (or **fn‑read‑next** in RDBMS path). [Seen in: aa010-main.]  
Key steps: open input **Final‑File**, read next record, handle EOF or read errors, write error messages, close file, set status. [Seen in: aa040-Process-Read-Next.]  
I/O: **Final‑File**. [Seen in: aa040-Process-Read-Next.]  
Outcomes: **FS‑Reply**, **WE‑Error**, **Cobol‑File‑Status**, **WS‑File‑Key**. [Seen in: aa040-Process-Read-Next.]

Path: Write  
Trigger: **File‑Function = 7** (or **fn‑Write** in RDBMS path). [Seen in: aa010-main.]  
Key steps: open output **Final‑File**, write **Record‑5** from **Final‑Record**, handle write errors, close file. [Seen in: aa070-Process-Write.]  
I/O: **Final‑File**. [Seen in: aa070-Process-Write.]  
Outcomes: **FS‑Reply**, **WE‑Error**, **WS‑File‑Key**. [Seen in: aa070-Process-Write.]

Path: Bad‑Function  
Trigger: any other **File‑Function** value or invalid function. [Seen in: aa010-main.]  
Key steps: set **WE‑Error** to 999, **FS‑Reply** to 99. [Seen in: aa100-Bad-Function.]  
I/O: none. [Seen in: aa100-Bad-Function.]  
Outcomes: **WE‑Error**, **FS‑Reply**. [Seen in: aa100-Bad-Function.]

Path: RDBMS‑Read‑Next  
Trigger: **fn‑read‑next** flag set. [Seen in: ba-Process-RDBMS.]  
Key steps: set **fn‑Open**, **fn‑Input**, call DAL to open, log, set **fn‑Read‑Next**, call DAL to read, save statuses, log, set **fn‑Close**, call DAL to close, restore statuses, log. [Seen in: ba-Process-RDBMS.]  
I/O: RDBMS via DAL (**irsfinalMT**). [Seen in: ba020-Call-DAL.]  
Outcomes: **FS‑Reply**, **WE‑Error**, **WS‑File‑Key**. [Seen in: ba020-Call-DAL.]

Path: RDBMS‑Write  
Trigger: **fn‑Write** flag set. [Seen in: ba-Process-RDBMS.]  
Key steps: set **fn‑Open**, **fn‑I‑O**, call DAL to open, check errors, set **fn‑Write**, call DAL to write, save statuses, set **fn‑Close**, call DAL to close, restore statuses, log, set flags if failure. [Seen in: ba-Process-RDBMS.]  
I/O: RDBMS via DAL (**irsfinalMT**). [Seen in: ba020-Call-DAL.]  
Outcomes: **FS‑Reply**, **WE‑Error**, **WS‑File‑Key**. [Seen in: ba020-Call-DAL.]

Path: RDBMS‑Rewrite  
Trigger: **fn‑Re‑write** flag set. [Seen in: ba-Process-RDBMS.]  
Key steps: similar to write but with **fn‑Re‑write**. [Seen in: ba-Process-RDBMS.]  
I/O: RDBMS via DAL (**irsfinalMT**). [Seen in: ba020-Call-DAL.]  
Outcomes: **FS‑Reply**, **WE‑Error**, **WS‑File‑Key**. [Seen in: ba020-Call-DAL.]

5.4 Termination  
The program performs any pending logging via **Ca-Process-Logs** if testing is enabled, then exits the RDBMS section and returns to the flat‑file exit path. [Seen in: aa999-main-exit.]  
Finally, **aa-Exit** is invoked to terminate the program cleanly. [Seen in: aa-Exit.]

---
## ACAS-Sysout
*[31/267]*

### Business/Functional Perspective
### System Output Logging  

**Program Purpose**  
The program records messages from other parts of the system into a text log file, adding a date‑time stamp to each entry. It ensures that every line of output is preserved in order for later review or audit. When a special “CLOSE ” command is received, it writes a final “Process Ended.” record and safely closes the log. This provides a reliable, tamper‑evident trail of system activity that supports compliance and troubleshooting.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
* Each supplied line is written to the log file with a timestamp.  
* If the line begins with “CLOSE ”, a “Process Ended.” record is written and the log file is closed.  
* Any file‑open issues are handled internally; no user‑visible error messages are generated.  

**User Flow Summary**  
A calling routine sends a line of text to the program. The program attaches the current date and time, writes the record to the log file, and returns control. When the routine sends a line that starts with “CLOSE ”, the program writes a final termination record, closes the log file, and exits. The user can then review the complete log file to verify the recorded activity.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program receives a 160‑character string via the linkage variable LS‑SO‑Print, obtains the current date and time, and prepares a log record header. [Seen in: Procedure division using LS-SO-Print.]  
If the output file has not yet been opened (SO‑Closed flag zero), it performs the zz010‑Open‑File routine to open the file in extend mode and then proceeds to write the record. [Seen in: Procedure division using LS-SO-Print; zz010-Open-File.]  
When the incoming string begins with the literal “CLOSE ” and the file is open, the program writes a “Process Ended.” message, closes the file, clears the linkage variable, and exits; otherwise it writes the supplied string as a log entry and exits. [Seen in: Procedure division using LS-SO-Print.]

5.2 Initialization  
At program start, SO‑Closed is initialized to zero, indicating the output file is not yet open. [Seen in: Working-storage section.]  
The program obtains the current date and time via the intrinsic function and copies them into the working‑storage record WS‑CDT, then transfers those values to the log record fields. [Seen in: Procedure division using LS-SO-Print.]  
If the file is closed, the program performs zz010‑Open‑File which opens the file in extend mode, and if the open fails it reopens it in output mode. [Seen in: Procedure division using LS-SO-Print; zz010-Open-File.]

5.3 Core Processing  
Path: File Open  
Trigger: SO-Closed flag zero at entry  
Key steps: perform zz010-Open-File; open file in extend mode; if FS-Status not zero close and reopen output; set SO-Open true.  
I/O: Screen-Output file  
Outcomes: File opened; SO-Open set; file ready for writing.  
[Seen in: Procedure division using LS-SO-Print; zz010-Open-File.]  

Path: Normal Write  
Trigger: LS-SO-Print does not start with "CLOSE " and file is open  
Key steps: move LS-SO-Print to SO-Print; set log date/time; write SO-Record; clear LS-SO-Print; goback.  
I/O: Screen-Output file  
Outcomes: Log record written; program exits.  
[Seen in: AA010-Process.]  

Path: Close Command  
Trigger: LS-SO-Print (1:6) = "CLOSE " and SO-Open true  
Key steps: set SO-Print to "Process Ended."; set log date/time; write SO-Record; close Screen-Output; set SO-Closed true; clear LS-SO-Print; goback.  
I/O: Screen-Output file  
Outcomes: File closed; SO-Closed set; program exits.  
[Seen in: Procedure division using LS-SO-Print.]

5.4 Termination  
The program terminates by executing a GOBACK statement, returning control to the caller. [Seen in: AA010-Process; Procedure division using LS-SO-Print.]  
When a “CLOSE ” command is received, the program additionally closes the output file, sets the SO-Closed flag, and clears the linkage variable before exiting. [Seen in: Procedure division using LS-SO-Print.]

---
## acas-test-takeon-1
*[32/267]*

### Business/Functional Perspective
### Sales Ledger Transfer  

**Program Purpose**  
The program reads a plain‑text customer file and converts each record into a sales‑ledger entry suitable for later database import. It validates and cleans key fields—such as phone numbers and addresses—applies default sales parameters, and writes the results to a Cobol sales file. The process ensures that only records meeting the required format are retained, providing a reliable test data set for the accounting system.  

**Screen Interactions**  

1. **Header Screen** – Displays the program name “SL Takeon‑1 3.02.03)” and the title “Cust. TAKE‑ON”.  
2. **Status Summary Screen** – After all records are processed, a report appears showing:  
   * Maximum record size  
   * Total customers read  
   * Maximum address length  
   * Number of records written, rewritten, or deleted  
   * Counts of short addresses and missing phone numbers  
   * Final record‑count totals.  
   The screen ends with the message “Note counts and hit return” prompting the user to press any key to exit.  

**Messages and Errors**  

* **File Access Problems** – If the customer file or required system file cannot be opened, a clear error message is shown and the program terminates.  
* **Delimiter Not Set** – When the sales‑ledger delimiter is missing, the program aborts and asks the user to correct the setting.  
* **Invalid Records** – Records that lack an address or contain an empty phone number are skipped and counted as deleted; a note is displayed after processing.  
* **Processing Failures** – Write or delete failures are reported with a descriptive message and stop further processing.  

**User Flow Summary**  
The user initiates the program, which automatically reads each customer line from “customer.txt”. For each line, the program extracts fields, cleans and validates them, assigns default sales parameters, and writes the cleaned record to a Cobol sales ledger file. Records that fail validation (e.g., missing address or phone number) are discarded, and counts of such incidents are tracked. Upon completion, the program presents a concise summary of all records processed, indicating how many were written, rewritten, or deleted, and then waits for the user to press return before exiting.  

**Program Linkages**  
- acas012  
- maps04  
- maps09

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in **la-main**, displays header, obtains program arguments, opens the system file, reads the first record, verifies SL‑Delim, then calls **lc-extract** to process customer data. [Seen in: la-main.]  
**lc-extract** invokes **lcb-proc-customers** which opens the customer input file and prepares the sales ledger environment. [Seen in: lc-extract, lcb-proc-customers.]  
**lcb-proc-customers** loops through each customer record, parses fields, cleans data, writes or deletes records to the sales file via acas012 calls, and accumulates statistics before exiting. [Seen in: lcb-proc-customers, lcb020-read, lcb070-Write, lcb080-Delete-Rec.]

5.2 Initialization  
**la-main** performs **zz020-Get-Program-Args** to load command line parameters, then opens the system file and reads the first record to obtain default values. [Seen in: la-main.]  
It checks that SL‑Delim is defined; if not, it displays an error, closes the system file via **acas012-Close**, and aborts. [Seen in: la-main.]  
**lc-extract** calls **lcb-proc-customers**, which opens the customer input file, sets duplicate handling flags to zero, and initializes counters and file access flags. [Seen in: lc-extract, lcb-proc-customers.]

5.3 Core Processing  

Path: System File Read  
Trigger: **la-main** after opening system file  
Key steps: open system file, read first record, verify reply, close file  
I/O: System-File  
Outcomes: loads system defaults into working storage, sets SL‑Delim, prepares for customer processing  
[Seen in: la-main, acas012-Open, acas012-Close.]

Path: Customer Record Processing  
Trigger: **lcb020-read** loop in **lcb-proc-customers**  
Key steps: read customer record, increment counters, initialise sales record defaults, parse fields with UNSTRING, validate date, clean phone number, clean address, decide to write or delete  
I/O: customersin, sales file via acas012  
Outcomes: records written or deleted, counters updated, status flags set  
[Seen in: lcb020-read, lcb030-ReDo, lcb040-Done, lcb050-Load-Address, lcb060-Abbrev-Address, lcb070-Write, lcb080-Delete-Rec.]

Path: Address Loading  
Trigger: **lcb050-Load-Address** after parsing address fields  
Key steps: assemble Sales-Address from ws-addr1..4 and tmp address parts, handle overflow, set Sales-Name  
I/O: none (in‑memory)  
Outcomes: Sales-Address and Sales-Name populated for write  
[Seen in: lcb050-Load-Address.]

Path: Record Write  
Trigger: **lcb070-Write** after address assembly  
Key steps: set File-Key-No, perform **acas012-Write**, on error perform **acas012-Rewrite**, update counters  
I/O: sales file via acas012  
Outcomes: record persisted, write counter incremented, rewrite counter incremented if needed  
[Seen in: lcb070-Write, acas012-Write, acas012-Rewrite.]

Path: Record Delete  
Trigger: **lcb080-Delete-Rec** when phone number invalid or no address  
Key steps: set File-Key-No, perform **acas012-Delete**, increment Deleted-Recs counter  
I/O: sales file via acas012  
Outcomes: record removed from sales file, delete counter updated  
[Seen in: lcb080-Delete-Rec, acas012-Delete.]

5.4 Termination  
After processing all customers, **lcb020-read** displays statistics, closes the customer file, and calls **acas012-Close** to close the sales file. [Seen in: lcb020-read, acas012-Close.]  
The program then stops run with **STOP RUN**, returning control to the operating system. [Seen in: la-main.]

---
## acas-test-takeon-2
*[33/267]*

### Business/Functional Perspective
### Purchase Ledger Transfer

**Program Purpose**  
This utility converts old sales‑ledger customer records into purchase‑ledger records for testing purposes. It reads a legacy customer file, cleans and reformats address and phone data, assigns purchase keys, writes each record into a new purchase ledger file, and removes the corresponding sales‑ledger entry. The program ensures that each new record is inactive and fully validated before being written, thereby providing a reliable test data set for downstream applications.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *Missing system parameters*: If required system settings (such as the purchase‑ledger delimiter) are not set, the program stops with a clear message and waits for the user to acknowledge.  
- *File access problems*: Errors opening or reading the system file or the customer input file are displayed, and the program aborts after user acknowledgment.  
- *Duplicate keys or write failures*: If a record cannot be written to the purchase ledger due to a duplicate key or other write error, the program displays an error message and stops after user acknowledgment.  
- *Data validation issues*: Records with invalid or missing phone numbers, or with no address information, are skipped; the program counts and reports these exclusions in the final summary.  
- *General processing errors*: Any unexpected internal error triggers an error message and stops the run, allowing the user to investigate before continuing.  

**User Flow Summary**  
A user starts the batch job, which immediately displays the program name and a short “Purch TAKE‑ON” banner. The program then reads system parameters and verifies that the required delimiter is defined. It opens the legacy customer file and processes each line one at a time: it cleans the address and phone fields, converts dates, assigns a purchase key, writes the new purchase record, and deletes the old sales‑ledger record. Throughout the run the program keeps running counters for total records processed, records written, records rewritten, short addresses, missing phone numbers, and deletions. When all records have been handled, the program prints a concise summary of these statistics and pauses, prompting the user to press return to finish.  

**Program Linkages**  
- acas022  
- maps04  
- maps09

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph **la-main**, where it obtains command‑line arguments, opens the system file, reads the system record, verifies the PL‑Delim value, and then calls **lc-extract** to start data extraction. [Seen in: la-main.]  
**lc-extract** invokes **lc-main**, which in turn calls **lcb-proc-customers** to process the customer input file and write purchase ledger records. [Seen in: lc-extract.]  
After all customers are processed, the program reaches **lcb999-exit** and terminates with a STOP RUN. [Seen in: lcb999-exit.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to capture any command‑line parameters. [Seen in: la-main.]  
It opens the system file, reads the system record, checks for errors, and validates that **PL-Delim** is set before proceeding. [Seen in: la-main.]

5.3 Core Processing  

Path: Customer Record Processing  
Trigger: **lcb020-read** loop reads each record from **customersin**.  
Key steps: read record, parse fields with UNSTRING, validate and convert the date, clean phone numbers, clean and assemble address lines, write the purchase record, and delete the corresponding SL key.  
I/O: **customersin** (input), **acas022** (purchase file).  
Outcomes: counters for records in/out, address overflow, deleted records, and status flags are updated.  
[Seen in: lcb020-read.]

Path: Delete Record  
Trigger: **lcb080-Delete-Rec** invoked when a phone number is missing or all address lines are blank.  
Key steps: call **acas022-Delete** and increment **Deleted-Recs**.  
I/O: **acas022**.  
Outcomes: **Deleted-Recs** counter increased; record removed from purchase file.  
[Seen in: lcb080-Delete-Rec.]

Path: Write Record  
Trigger: **lcb070-Write** after address assembly.  
Key steps: call **acas022-Write**; if **FS-Reply** non‑zero, perform **acas022-Rewrite** and increment **ws-Rec-Cnt-R-Out**; otherwise increment **ws-Rec-Cnt-Out**.  
I/O: **acas022**.  
Outcomes: record written or rewritten, counters updated.  
[Seen in: lcb070-Write.]

Path: Validate Date  
Trigger: **zz050-Validate-Date** called when a non‑zero date is present.  
Key steps: normalize date separators, convert to UK format, call **maps03**, and set **u-bin** if valid.  
I/O: none.  
Outcomes: **u-bin** set, **Purch-Create-Date** updated if valid.  
[Seen in: zz050-Validate-Date.]

Path: Error Handling  
Trigger: **aa100-Check-4-Errors** after any acas022 call.  
Key steps: display error messages, accept user reply, and exit via **lcb999-exit**.  
I/O: none.  
Outcomes: program terminates on error.  
[Seen in: aa100-Check-4-Errors.]

5.4 Termination  
Upon completion of the customer loop, **lcb999-exit** is executed, closing files and performing a STOP RUN to exit the program. [Seen in: lcb999-exit.]  
The program also exits early from **la-main** if system file errors or missing PL‑Delim are detected. [Seen in: la-main.]

---
## analLD
*[34/267]*

### Business/Functional Perspective
### Analysis Table Load  

**Program Purpose**  
This program loads records from an Analysis file into the MySQL Analysis table used by the accounting system. It validates that the system and database configuration is present, establishes a connection, and processes each record, handling duplicates and logging outcomes. The program ensures that the Analysis table is up‑to‑date, supports audit trails, and reduces the risk of data inconsistencies in the financial reports.  

**Screen Interactions**  
No direct screens. This program is run as a background job after a separate data‑entry step and returns results via the system log.  

**Messages and Errors**  
- Failure to read the system parameter file (missing or corrupt).  
- Database configuration missing or invalid.  
- Unable to open the Analysis file or the Analysis table.  
- Duplicate record detected (record already exists).  
- General database write errors (SQL or connection problems).  
- Commit or rollback failures.  
- Summary of records processed, rewritten, and logged at completion.  

**User Flow Summary**  
A system administrator or batch scheduler initiates the program, optionally passing a file name and an overwrite flag. The program reads the system parameter file to obtain database connection details, then connects to the MySQL database and opens the Analysis file. It reads each record, attempts to insert it into the Analysis table, and handles duplicate keys by updating existing records. Any errors encountered are logged and cause the program to stop or continue depending on the error type. Upon completion, the program logs the total number of records read, written, and rewritten, then closes all connections and exits.  

**Program Linkages**  
- acas015  
- acas-get-params  
- ACAS-Sysout  
- MySQL_rollback  
- MySQL_commit

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **aa000-main-start**, performing argument parsing and system parameter retrieval. [Seen in: aa000-main-start.]  
It opens the system file, reads the system record, and loads RDB connection parameters, optionally overriding with acas.param if needed. [Seen in: aa000-main-start.]  
The program then opens the analysis file via **acas015-Open-Input**, and if the file is empty or missing, it terminates early. [Seen in: aa010-Proc-Override.]  
Otherwise it opens the RDB table via **acas015-Open**, then enters a loop in **aa010-Read** that reads each analysis record, writes it to the database, handles duplicate keys by rewriting or skipping, and continues until EOF. [Seen in: aa010-Read.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to capture command line arguments, then displays the program name via **Call-Sysout**. [Seen in: aa000-main-start.]  
It sets logging parameters **WS-Log-System** and **WS-Log-File-No**, then opens the system file for input and reads the first record to populate RDB settings. [Seen in: aa000-main-start.]  
If the system record indicates that only Cobol files are in use, it attempts to read **acas.param** to obtain RDB credentials; failure results in early exit. [Seen in: aa000-main-start.]  
After loading RDB parameters, it initializes file control flags, opens the analysis file (**acas015-Open-Input**), and prepares for reading. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: Analysis File Empty / No Records  
Trigger: **acas015-Open-Input** returns **FS-Reply 35** (file empty)  
Key steps: Display message, close files, goback  
I/O: System-File, Analysis file  
Outcomes: Program exits with no processing  
[Seen in: aa010-Proc-Override.]  

Path: Normal Record Processing  
Trigger: **acas015-Read-Next** returns **FS-Reply not 10** (not EOF) and not error  
Key steps: Read record, write to RDB, handle duplicates, increment counters, loop  
I/O: Analysis file, RDB table  
Outcomes: **ws-Rec-Cnt-In**, **ws-Rec-Cnt-Out**, **ws-Rec-Cnt-R-Out** updated; continues until EOF  
[Seen in: aa010-Read.]  

Path: Duplicate Key Handling  
Trigger: **SQL-State = "23000"** or **FS-Reply 22/99** or **SQL-Err 1062/1022**  
Key steps: Reset **FS-Reply**, **WE-Error**, rewrite record, increment rewrite counter, continue loop  
I/O: Analysis file, RDB table  
Outcomes: **ws-Rec-Cnt-R-Out** incremented; duplicate record rewritten  
[Seen in: aa010-Read.]  

Path: Error Handling and Abort  
Trigger: **FS-Reply not zero** after write or read  
Key steps: Log error messages, optionally rollback, set return-code, finish  
I/O: System-File, Analysis file, RDB table  
Outcomes: Program terminates with error status  
[Seen in: aa010-Read.]  

Path: End-of-Cycle Finalization  
Trigger: EOF (**FS-Reply 10**) or error leading to **aa999-Finish**  
Key steps: Log record counts, close RDB and analysis file, close system file, output EOJ message  
I/O: System-File, Analysis file, RDB table  
Outcomes: Program exits cleanly  
[Seen in: aa999-Finish.]  

Path: Rollback on Error  
Trigger: **aa020-Rollback** called after error  
Key steps: Call **MySQL_rollback**  
I/O: RDB  
Outcomes: RDB state rolled back  
[Seen in: aa020-Rollback.]

5.4 Termination  
Upon completion, **aa999-Finish** logs record counts, closes the RDB and analysis files, closes the system file, and outputs an EOJ message before gobacking. [Seen in: aa999-Finish.]  
If an error occurs during processing, the program logs the error, may perform a rollback, sets an appropriate return-code, and then exits via **aa999-Finish**. [Seen in: aa010-Read.]

---
## analMT
*[35/267]*

### Business/Functional Perspective
### Analysis File RDB Operations

**Program Purpose**  
The program is a data‑access layer that lets other parts of the ACAS system perform all required file operations on the *Analysis‑Rec* table.  It opens and closes a database connection, retrieves records by key or range, writes new records, updates or deletes existing ones, and reports any errors back to the caller.  By centralising the database logic the application ensures consistent validation, unique key enforcement and reliable error handling, supporting auditability and reducing the risk of data corruption.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
| Result | Description |
|--------|-------------|
| **Success** | The requested operation completes and the record (if applicable) is returned. |
| **End of File** | No more records are available after a read‑next operation. |
| **Invalid key or key not found** | The supplied key does not match any record. |
| **Duplicate key** | A write or update attempts to insert a record that already exists. |
| **Database error** | A MySQL error occurs (connection failure, SQL syntax error, etc.). |
| **Open/Close error** | The program cannot open or close the database connection. |
| **Unsupported function** | An unknown File‑Function code is supplied. |

**User Flow Summary**  
A caller supplies an *Analysis‑Rec* record and a File‑Function code (1 = Open, 2 = Close, 3 = Read‑Next, 4 = Read‑Indexed, 5 = Write, 7 = Rewrite, 8 = Delete, 9 = Start).  
The program first opens a connection to the database if requested.  For read operations it builds a SELECT statement based on the key or range provided, fetches the first matching row, and returns the record data.  For write, update or delete it constructs the appropriate INSERT, UPDATE or DELETE SQL command, executes it, and reports whether the operation succeeded or if a duplicate key or other database error occurred.  When closing it frees any open cursor and closes the connection.  After each operation the caller receives status codes (Fs‑Reply and We‑Error) and any database error text, allowing the calling module to present a clear message to the end‑user.

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger   (called via Ca‑Process‑Logs)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in **ba-ACAS-DAL-Process**, accepting the number of environment lines and setting screen exception flags. [Seen in: ba-ACAS-DAL-Process.]  
It clears all error, status, and SQL‑related fields, then evaluates the **File-Function** to dispatch to one of the process paragraphs (Open, Close, Read‑Next, Read‑Indexed, Start, Write, Delete, Rewrite). [Seen in: ba-ACAS-DAL-Process.]  
After the selected process paragraph completes, control returns to **ba999-end** where any logging is performed before exiting the program. [Seen in: ba999-end.]

5.2 Initialization  
The program accepts the number of environment lines, adjusts **ws-lines** if less than 24, and sets COBOL screen exception and escape flags. [Seen in: ba-ACAS-DAL-Process.]  
It clears all error, status, and SQL‑related fields to spaces or zero before evaluating the **File-Function**. [Seen in: ba-ACAS-DAL-Process.]

5.3 Core Processing  

Path: **Open**  
Trigger: **File-Function = 1**  
Key steps: Build MySQL connection parameters from linkage areas, perform **MYSQL-1000-OPEN**, set cursor inactive, set **WS-File-Key** to "OPEN Analysis". [Seen in: ba020-Process-Open.]  
I/O: **MYSQL-OPEN** procedure (no table).  
Outcomes: **fs-reply** set to zero on success, otherwise jumps to **ba999-end**. [Seen in: ba020-Process-Open.]

Path: **Close**  
Trigger: **File-Function = 2**  
Key steps: If a cursor is active, free it via **ba998-Free**, perform **MYSQL-1980-CLOSE**, set **WS-File-Key** to "CLOSE Analysis". [Seen in: ba030-Process-Close.]  
I/O: **MYSQL-CLOSE** procedure.  
Outcomes: **fs-reply** remains zero; control goes to **ba999-end**. [Seen in: ba030-Process-Close.]

Path: **Read-Next**  
Trigger: **File-Function = 3**  
Key steps: If no cursor active, construct a SELECT query for Pa‑Code > "000", execute SELECT, store result, set cursor active; otherwise fetch next record from cursor; handle EOF or errors, unload HVs to **Analysis-Rec**, set **FS-Reply** and **WE-Error** accordingly. [Seen in: ba040-Process-Read-Next.]  
I/O: **MYSQL-SELECT**, **MYSQL-FETCH**, **MYSQL-FREE**.  
Outcomes: **FS-Reply** 0 on success, 10 on EOF, **WE-Error** set for errors. [Seen in: ba040-Process-Read-Next.]

Path: **Start**  
Trigger: **File-Function = 9**  
Key steps: Validate **access-type**, clear any active cursor, build SELECT with relation operator based on **access-type**, execute SELECT, set cursor active if rows found, set **FS-Reply** and **WE-Error**, build status message. [Seen in: ba060-Process-Start.]  
I/O: **MYSQL-SELECT**.  
Outcomes: **FS-Reply** 0 if rows found, 21 if none, **WE-Error** set for SQL errors. [Seen in: ba060-Process-Start.]

Path: **Write**  
Trigger: **File-Function = 5**  
Key steps: Load HVs from **Analysis-Rec**, build INSERT statement, execute, check row count, handle duplicate key errors by setting **FS-Reply** 22, otherwise set **FS-Reply** 99 on other errors. [Seen in: ba070-Process-Write.]  
I/O: **MYSQL-INSERT**.  
Outcomes: **FS-Reply** 0 on success, 22 on duplicate, 99 on other errors. [Seen in: ba070-Process-Write.]

Path: **Delete**  
Trigger: **File-Function = 8**  
Key steps: Build DELETE WHERE clause using key, execute DELETE, check row count, set **FS-Reply** 99 and **WE-Error** 995 on failure. [Seen in: ba080-Process-Delete.]  
I/O: **MYSQL-DELETE**.  
Outcomes: **FS-Reply** 0 on success, 99 on failure. [Seen in: ba080-Process-Delete.]

Path: **Rewrite**  
Trigger: **File-Function = 7**  
Key steps: Load HVs, build UPDATE statement with WHERE clause, execute UPDATE, handle errors, set **FS-Reply** 99 on failure. [Seen in: ba090-Process-Rewrite.]  
I/O: **MYSQL-UPDATE**.  
Outcomes: **FS-Reply** 0 on success, 99 on failure. [Seen in: ba090-Process-Rewrite.]

5.4 Termination  
At **ba999-end**, if **testing-1** is set, logs are written via **Ca-Process-Logs** before proceeding. [Seen in: ba999-end.]  
The program then exits with **ba999-exit**, completing the transaction. [Seen in: ba999-exit.]

---
## analRES
*[36/267]*

### Business/Functional Perspective
### Analysis File Backup  

**Program Purpose**  
The program copies all records from the current Analysis data file into a new sequential backup file. It ensures that a complete, reliable copy of the analysis data is available for restoration or audit purposes. By producing this backup, the program supports compliance, provides a safety net against accidental data loss, and facilitates future data recovery.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- “No Analysis file to process” – the source file is missing or empty.  
- “Failed to open analysis file” – the program cannot open the input or output file.  
- “Problem reading input file” – an unexpected read error occurs.  
- “Write error on output file” – a write failure prevents the backup from completing.  
- “Program arguments incorrect” – the command‑line parameters are not valid.  
- “Environment variables not yet set” – required runtime settings are missing.  

**User Flow Summary**  
The user launches the program, which attempts to open the Analysis source file. It reads each record sequentially, writes it to a backup file, and keeps a count of processed records. All actions, including successes and failures, are logged to SYS‑DISPLAY.log via ACAS‑Sysout. When finished, the program logs a summary of records read and written and then exits. If any error occurs (missing file, read/write problems, or configuration issues), an error message is logged and the program stops.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by performing argument retrieval and initializing logging parameters before opening the analysis sequential file for input. [Seen in: aa000-Main-Start.]  
If the input file opens successfully, the program enters a loop that reads each record, writes it to an output ISAM file, and counts processed records. [Seen in: aa010-Read-Recs.]  
Upon reaching end of file or encountering an error, the program closes both files, outputs a summary of records processed, and terminates. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The main entry performs zz020-Get-Program-Args, sets logging system and file numbers, and prepares a status message before calling Call-Sysout. [Seen in: aa000-Main-Start.]  
It then opens the input analysis file for reading, checks FS-Reply for errors, and if successful opens the output analysis file for writing, initializing record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Input-Open-Error  
Trigger: FS-Reply not zero after opening input file.  
Key steps: set error message, call Call-Sysout, close Analysis-File, set close message, call Call-Sysout, goback.  
I/O: Analysis-File-Seq (input).  
Outcomes: program exits with error status.  
[Seen in: aa000-Main-Start.]

Path: Output-Open-Error  
Trigger: FS-Reply not zero after opening output file.  
Key steps: set error message, call Call-Sysout, close Analysis-File, set close message, call Call-Sysout, goback.  
I/O: Analysis-File (output).  
Outcomes: program exits with error status.  
[Seen in: aa000-Main-Start.]

Path: Read-Records-Loop  
Trigger: successful opening of both input and output files.  
Key steps: read next record, check FS-Reply, on error write SY003 message, call Call-Sysout, exit loop; otherwise write record to output, check FS-Reply, on error write SY006 message, call Call-Sysout, exit loop; increment input and output counters.  
I/O: Analysis-File-Seq (input), Analysis-File (output).  
Outcomes: counters updated, errors handled, loop continues until end of file or error.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: end of file or error during read/write loop.  
Key steps: close both files, build summary string with record counts, call Call-Sysout, output close message, call Call-Sysout, set Return-Code to zero, goback.  
I/O: Analysis-File-Seq, Analysis-File.  
Outcomes: program terminates cleanly with summary.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both the input and output analysis files, outputs a summary of records processed, and sets the Return-Code to zero before exiting. [Seen in: aa020-Finish-Off.]  
All status messages are sent to the system log via the Call-Sysout routine before the program terminates. [Seen in: aa020-Finish-Off.]

---
## analUNL
*[37/267]*

### Business/Functional Perspective
### Analysis File Unload  

**Program Purpose**  
This program backs up the Analysis data by copying every record from the existing ISAM Analysis file into a new sequential file named *analysis.seq*. It creates a reliable, restorable copy of the data that can be used for recovery or migration. All operations are logged to a system display log for audit and troubleshooting purposes. The routine is part of ACAS v3.02 and later environments.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- Indicates when the original Analysis file cannot be found or opened.  
- Reports any errors that occur while reading from the source file.  
- Reports write errors when attempting to create the sequential backup file.  
- Signals that program arguments are incorrect.  
- Alerts that required environment variables are missing, causing the program to abort.  
- Logs the total number of records read and written upon completion.  

**User Flow Summary**  
The user launches the program (typically via a batch or command line). It validates its environment, logs a start message, and opens the source Analysis file. It then reads each record in turn, writes it to *analysis.seq*, and keeps a running count of records processed. If an error occurs at any point, the program writes an appropriate message to the log and stops. When all records have been processed, it logs the final counts, closes the files, and exits. No interactive input is required from the user during execution.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments, setting logging parameters, and displaying a start message. [Seen in: aa000-Main-Start.]  
It then opens the source Analysis file for input, checks for existence, and opens a sequential output file for writing the records. [Seen in: aa000-Main-Start.]  
The main loop reads each record from the Analysis file, writes it to the sequential file, counts records, handles any I/O errors, and finally closes both files and reports the totals before exiting. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command‑line arguments and sets logging system and file numbers for FHlogger. [Seen in: aa000-Main-Start.]  
It initializes the SO-Print buffer, logs a message indicating the COBOL files in use, and calls ACAS‑Sysout to output the message. [Seen in: aa000-Main-Start.]  
It opens the Analysis‑File for input and verifies the status; if the file is missing, it logs an error and exits. [Seen in: aa000-Main-Start.]  
It opens the Analysis‑File‑Seq for output and initializes record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read‑Recs  
Trigger: Successful opening of both input and output files.  
Key steps: Loop forever reading next record from Analysis‑File; on end‑of‑file go to Finish‑Off; on read error log SY003 and exit loop; increment input counter; write record to Analysis‑File‑Seq; on write error log SY006 and exit loop; increment output counter.  
I/O: Analysis‑File (input), Analysis‑File‑Seq (output).  
Outcomes: Record counts updated; error status may cause early exit; control passes to Finish‑Off.  
[Seen in: aa010-Read-Recs.]

Path: Error‑Read  
Trigger: FS‑Reply not zero during a read operation.  
Key steps: Construct error message with SY003 and FS‑Reply, log via Call‑Sysout, and jump to Finish‑Off.  
I/O: None beyond logging.  
Outcomes: Program terminates after reporting error, with zero return code.  
[Seen in: aa010-Read-Recs.]

Path: Error‑Write  
Trigger: FS‑Reply not zero during a write operation.  
Key steps: Set SO‑Print to SY006, log via Call‑Sysout, and jump to Finish‑Off.  
I/O: None beyond logging.  
Outcomes: Program terminates after reporting write error, with zero return code.  
[Seen in: aa010-Read-Recs.]

Path: Finish‑Off  
Trigger: End‑of‑file reached or an error causes exit from read loop.  
Key steps: Close both files, build a summary string with record counts, log via Call‑Sysout, set Return‑Code to zero, and goback.  
I/O: Analysis‑File, Analysis‑File‑Seq.  
Outcomes: Files closed, summary logged, program exits with success status.  
[Seen in: aa020-Finish-Off.]

Path: Main‑Start  
Trigger: Program entry point.  
Key steps: Retrieve arguments, set logging, open files, initialize counters, handle missing file.  
I/O: None beyond file opens.  
Outcomes: Program ready to enter read loop or exit if file missing.  
[Seen in: aa000-Main-Start.]

5.4 Termination  
After closing the files, the program logs a final summary of records processed and exits with a zero return code. [Seen in: aa020-Finish-Off.]  
The goback statement terminates the program, returning control to the caller. [Seen in: aa020-Finish-Off.]

---
## auditLD
*[38/267]*

### Business/Functional Perspective
### Audit Table Loading  

**Program Purpose**  
The program loads transaction audit records from a flat audit file into a MySQL audit table. It validates that the database configuration is correct, reads each audit record, writes it to the table, and logs the number of records processed and any errors. By ensuring all audit data is stored reliably in the database, the program supports compliance, traceability, and risk management for the accounting system.  

**Screen Interactions**  
No direct screens. This program runs as a background task after a separate data‑entry step and returns status information back to that context.  

**Messages and Errors**  
- Failure to read the system configuration file.  
- Failure to open or read the audit file.  
- Failure to open the audit table in the database.  
- Duplicate record detection (the record is updated instead of inserted).  
- General database write errors (other SQL errors).  
- Missing audit file (no records to load).  
- Any database rollback or commit failures (reported as a process abort).  

**User Flow Summary**  
When the program starts, it loads the system configuration and verifies that the database connection parameters are available. It then opens the audit file and the MySQL audit table. For each record in the audit file, the program attempts to insert it into the table; if the record already exists, it updates the existing row. All successes, duplicates, and errors are counted and logged. When all records have been processed or an unrecoverable error occurs, the program closes the files, performs any necessary database commit or rollback, outputs a summary of records processed, and exits.  

**Program Linkages**  
- acas-get-params  
- acas010  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-main-start, parses command line arguments, opens the system parameter file, and loads database configuration. [Seen in: aa000-main-start.]  
It then proceeds to aa010-Proc-Override to open the Cobol audit file and initialize the RDB connection via acas010. [Seen in: aa010-Proc-Override.]  
The main processing loop in aa010-Read reads each audit record, writes it to the database, handles duplicates, and continues until EOF, after which aa999-Finish performs cleanup and exits. [Seen in: aa010-Read, aa999-Finish.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture up to two command line arguments and displays the program name via Call-Sysout. [Seen in: aa000-main-start.]  
It opens the System-File, reads the first record, validates that RDBMS-DB-Name is set, and if necessary invokes acas-get-params to load missing database parameters. [Seen in: aa000-main-start.]  
After loading parameters, it sets logging identifiers (WS-Log-System and WS-Log-File-No) and prepares for file and database operations. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: Program start (aa000-main-start)  
Key steps: perform zz020-Get-Program-Args, open System-File, read system record, validate RDBMS-DB-Name, optionally call acas-get-params, set logging values.  
I/O: System-File  
Outcomes: RDBMS parameters loaded into working storage, logging identifiers set, program proceeds to file and RDB open.  
[Seen in: aa000-main-start.]

Path: File and RDB Open  
Trigger: After system parameters loaded (aa010-Proc-Override)  
Key steps: perform acas010-Open-Input to open Cobol audit file, check FS-Reply, perform acas010-Open to open RDB connection, set Access-Type to zero, go to aa010-Read.  
I/O: Cobol audit file (via acas010-Open-Input), RDB connection (via acas010-Open)  
Outcomes: Cobol audit file opened, RDB connection established, ready to process records.  
[Seen in: aa010-Proc-Override.]

Path: Record Processing Loop  
Trigger: aa010-Read after file and RDB open  
Key steps: read next audit record, handle EOF, on error display messages and rollback, increment input counter, write record to RDB, handle duplicate key by rewriting, increment rewrite counter, increment output counter, loop back to aa010-Read.  
I/O: Cobol audit file (acas010-Read-Next), RDB (acas010-Write, acas010-Rewrite)  
Outcomes: Records transferred to RDB, counters updated, duplicates handled, errors cause rollback and exit.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: During write when SQL-State = "23000" or FS-Reply = 22 or 99 or SQL-Err indicates duplicate key  
Key steps: reset FS-Reply and WE-Error, perform acas010-Rewrite to update existing record, if rewrite fails log duplicate key message, else increment rewrite counter, continue loop.  
I/O: RDB (acas010-Rewrite)  
Outcomes: Duplicate records updated, counter incremented, processing continues.  
[Seen in: aa010-Read.]

Path: Finish and Cleanup  
Trigger: EOF or error leading to aa999-Finish  
Key steps: print record counts and log rec count, close RDB via acas010-Close, close System-File, close Cobol audit file via acas010-close, display EOJ message, goback.  
I/O: System-File, Cobol audit file, RDB  
Outcomes: Files closed, program exits cleanly.  
[Seen in: aa999-Finish.]

5.4 Termination  
Upon reaching aa999-Finish, the program prints summary statistics, closes the RDB and system files, and then performs a final goback to terminate. [Seen in: aa999-Finish.]  
No explicit commit or rollback is performed after the final record processing; any pending transaction is left to the MySQL commit/rollback calls invoked during processing. [Seen in: aa020-Rollback, aa030-Commit.]

---
## auditLD2
*[39/267]*

### Business/Functional Perspective
### Stock Audit Table Load

#### Program Purpose  
The program imports stock audit records from a local file into the MySQL audit table. It ensures that every record is recorded accurately, handles duplicate entries gracefully, and provides a clear audit trail of the operation. The load is performed in a single, repeatable batch that logs progress and reports totals so that administrators can verify completeness and timing. This helps maintain data integrity, supports compliance audits, and reduces manual record‑keeping errors.

#### Screen Interactions  
1. **Start Screen** – Displays the program name and begins the load process.  
2. **Progress Screen** – Shows a dot for every ten records processed and prints any error messages that occur during reading or writing.  
3. **Final Summary Screen** – Presents the number of input records, number of records written to the database, log‑file records generated, and elapsed time.  
4. **Error Screen** – If a problem is detected (e.g., file read failure, duplicate key, write error), a concise message is shown and the program pauses, waiting for the user to press Return to exit.

#### Messages and Errors  
- **Read Errors** – If the source file cannot be read, the program informs the user that the file was unreadable and stops.  
- **Duplicate Records** – When a duplicate key is found, the program notifies the user, skips the duplicate, and continues loading.  
- **Write Errors** – If a record cannot be written to the database, the program reports the failure, rolls back any pending changes, and exits after the user acknowledges the message.  
- **Commit/Rollback Issues** – Should a database commit or rollback fail, the program alerts the user before terminating.  
- **Generic Failures** – Any other unexpected condition triggers a message, rollback, and user confirmation before the program ends.

#### User Flow Summary  
The user starts the load program from the command line or batch system. Upon launch, the program reads system settings, opens the audit file, and begins transferring each record to the MySQL audit table. Progress is displayed in real time; every ten records a dot appears, and any duplicates or errors are reported immediately. After all records are processed, the program shows totals, log‑file count, and the time taken, then waits for the user to press Return to finish. The user can review the summary to confirm that the load completed successfully and that all expected records were transferred.

#### Program Linkages  
- acas010  
- MySQL_rollback  
- MySQL_commit  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at aa000-main-start, where it obtains command‑line arguments, sets up environment variables, and opens the system configuration file. [Seen in: aa000-main-start.]  
It then opens the Stock‑Audit COBOL file and initializes the MySQL database connection via acas010‑Open before entering the main record‑processing loop. [Seen in: aa000-main-start.]  
During the loop (aa010‑Read) each record is read from the Stock‑Audit file, written to the RDB table, and any duplicate or SQL errors are handled; the loop continues until EOF or a fatal error occurs. [Seen in: aa010-Read.]  
After processing all records, aa999‑Finish reports counts, closes files, commits or rolls back the transaction, and exits. [Seen in: aa999-Finish.]

5.2 Initialization  
The program first performs zz020‑Get‑Program‑Args to load environment variables and construct file paths. [Seen in: zz020-Get-Program-Args.]  
It then opens the System‑File, reads the system record, and opens the Stock‑Audit file and the RDB connection via acas010‑Open, setting File‑System‑Used flags accordingly. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: Record‑Processing Loop  
Trigger: aa010‑Read is performed after opening files.  
Key steps: read next Stock‑Audit record; increment input count; write record to RDB via acas010‑Write; handle duplicate key (fs‑reply = 22 or SQL‑Err = 1062) by skipping to next read; on other errors, rollback and exit.  
I/O: Stock‑Audit file, RDB table via acas010.  
Outcomes: updates ws‑Rec‑Cnt‑In/Out, Log‑File‑Rec‑Written, sets fs‑reply status for error handling.  
[Seen in: aa010-Read.]

Path: Error‑Handling / Rollback  
Trigger: aa020‑Rollback is called when fs‑reply ≠ 0 during write or during aa100‑Check‑4‑Errors.  
Key steps: invoke MySQL_rollback; display error messages; optionally accept user input; then exit to aa999‑Finish.  
I/O: MySQL transaction.  
Outcomes: transaction rolled back, program terminates.  
[Seen in: aa020-Rollback.]

Path: Finalization / Finish  
Trigger: aa999‑Finish is performed after EOF or fatal error.  
Key steps: display record counts and elapsed time; close RDB via acas010‑Close; close System‑File and Stock‑Audit file; close log file via fhlogger; commit if needed.  
I/O: System‑File, Stock‑Audit file, RDB, log file.  
Outcomes: all resources released, program exits with GOBACK.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program ends by closing all open files, committing or rolling back the MySQL transaction, and issuing GOBACK after displaying final statistics. [Seen in: aa999-Finish.]  
Any remaining errors trigger a rollback and the program exits with an error status. [Seen in: aa020-Rollback.]

---
## auditMT
*[40/267]*

### Business/Functional Perspective
### Stock Audit Operations  

**Program Purpose**  
The program provides a complete set of database operations for the Stock Audit table. It allows other application modules to open and close the audit data set, add new audit entries, modify or delete existing records, and retrieve records either sequentially or by key. By ensuring that all operations are performed against the database in a controlled, error‑checked manner, the program maintains data integrity, supports audit trails, and facilitates compliance reporting.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – Operations complete normally; record data is returned for reads, or status codes indicate insertion, update, or deletion.  
- **End‑of‑File** – When a sequential read reaches the last record, the program signals end of data.  
- **Key Not Found** – If a requested record does not exist (e.g., read indexed, delete, or rewrite), the program reports a “not found” status.  
- **Duplicate Key** – Attempts to insert a record that would violate a unique key generate a duplicate‑key error.  
- **Invalid Function or Parameters** – Unsupported file functions or wrong access types result in a generic invalid‑operation error.  
- **Database Errors** – Any MySQL‑level errors (e.g., connection failures, SQL syntax problems) are reported through standard error codes and descriptive messages.  

**User Flow Summary**  
A calling module supplies a Stock Audit record and indicates the desired file function (open, close, read next, read indexed, start, write, delete, delete all, rewrite).  
1. If opening, the program establishes a connection to the database and prepares the table for use.  
2. For reads, it executes a SELECT query based on the supplied key or sequential position and returns the matching record or signals that no data remains.  
3. For writes, it constructs and issues an INSERT statement; if the record already exists, a duplicate‑key error is returned.  
4. For updates or rewrites, it issues an UPDATE statement and reports success or a key‑not‑found error.  
5. For deletes, it executes a DELETE statement and reports success or a missing key error.  
6. When closing, it releases any open cursor or database connection.  
After each operation, the program returns status indicators (Fs‑Reply, WE‑Error) and, for reads, the requested record.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the ba-ACAS-DAL-Process section, where it accepts environment lines, sets screen exception flags, and clears status fields. [Seen in: ba-ACAS-DAL-Process.]  
It evaluates the File-Function value and dispatches to one of the specific process paragraphs (Open, Close, Read‑Next, Read‑Indexed, Start, Write, Delete, Delete‑ALL, Rewrite, or Bad‑Function). [Seen in: ba-ACAS-DAL-Process.]  
Each dispatched paragraph performs its database operation, then returns to the common termination paragraph ba999‑end, where any final logging is performed before exiting. [Seen in: ba999-end.]

5.2 Initialization  
The program accepts the number of environment lines, sets screen exception and escape flags, and initializes all status and error fields to spaces or zero. [Seen in: ba010-Initialise.]  
If the File‑Function is 1 (Open), it constructs the MySQL connection parameters, performs MYSQL‑1000‑OPEN, and sets the cursor state before proceeding to termination. [Seen in: ba020-Process-Open.]

5.3 Core Processing  

Path: Open  
Trigger: File‑Function = 1  
Key steps: Build connection strings, perform MYSQL‑1000‑OPEN, check fs‑reply, set cursor inactive.  
I/O: MYSQL‑1000‑OPEN (database connection).  
Outcomes: Successful connection sets fs‑reply 0; on error sets fs‑reply non‑zero and jumps to ba999‑end.  
[Seen in: ba020-Process-Open.]

Path: Read‑Next  
Trigger: File‑Function = 3  
Key steps: If no cursor active, build SELECT with key “00000000”, execute MYSQL‑1210‑COMMAND, store result, set cursor active. Then fetch next record with MYSQL‑fetch_record, unload HVs, set file‑key and reply.  
I/O: MYSQL‑1210‑COMMAND, MYSQL‑1220‑STORE‑RESULT, MYSQL‑fetch_record, TP‑STOCKAUDIT‑REC.  
Outcomes: Returns next record; on EOF sets fs‑reply 10 and WE‑Error 10; on error sets appropriate SQL error codes.  
[Seen in: ba040-Process-Read-Next.]

Path: Start  
Trigger: File‑Function = 9  
Key steps: Validate access‑type, clear any active cursor, build SELECT with comparison operator based on access‑type, execute command, set cursor active if rows returned, otherwise set error status.  
I/O: MYSQL‑1210‑COMMAND, MYSQL‑1220‑STORE‑RESULT.  
Outcomes: Cursor ready for subsequent Read‑Next; if no rows, fs‑reply 21 and WE‑Error 0.  
[Seen in: ba060-Process-Start.]

Path: Write  
Trigger: File‑Function = 5  
Key steps: Load HV fields from record, build INSERT command, execute MYSQL‑1210‑COMMAND, check row count and SQL error codes, set reply and error status.  
I/O: MYSQL‑1210‑COMMAND, TP‑STOCKAUDIT‑REC.  
Outcomes: Record inserted; on duplicate key sets fs‑reply 22; on other error sets fs‑reply 99.  
[Seen in: ba070-Process-Write.]

Path: Delete‑ALL  
Trigger: File‑Function = 6  
Key steps: Set audit‑id to a sentinel value, build DELETE command with key condition, execute MYSQL‑1210‑COMMAND, check row count and errors.  
I/O: MYSQL‑1210‑COMMAND, TP‑STOCKAUDIT‑REC.  
Outcomes: All rows deleted; on error sets fs‑reply 99 and WE‑Error 995; otherwise sets fs‑reply 0.  
[Seen in: ba085-Process-Delete-ALL.]

5.4 Termination  
After any operation, the program reaches ba999‑end where it optionally logs the transaction via Ca‑Process‑Logs and then exits. [Seen in: ba999-end.]  
The cursor is freed in ba998‑Free if active, and the program terminates with an exit statement in ba999‑exit. [Seen in: ba998-Free, ba999-exit.]

---
## auditRES
*[41/267]*

### Business/Functional Perspective
### Audit Restore Program

**Program Purpose**  
The program rebuilds the audit ISAM table from a backup sequential file. It reads records from `staudit.seq` and writes them into the primary audit file, creating a fresh copy of the audit trail. This function is critical for data integrity and compliance, ensuring that audit records can be recovered after a system failure or data corruption. By generating a detailed log of the process, it provides traceability and supports regulatory audits.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- *File missing*: Notifies that the source audit file is not present.  
- *Read error*: Indicates an unexpected issue while reading a record.  
- *Write error*: Reports a failure to write a record to the audit file.  
- *Argument error*: Signals that required command‑line arguments are missing or invalid.  
- *Environment error*: Warns that necessary environment settings are not configured.  
- *Completion summary*: Reports the number of records read and written successfully.

**User Flow Summary**  
1. The user launches the program (typically via a command line).  
2. The program attempts to open the source audit file `staudit.seq`. If the file is absent, it logs an error and stops.  
3. It then opens the target audit file for writing. If opening fails, an error is logged and the program stops.  
4. The program reads each record from the source file, writes it to the target file, and counts both input and output records. If any read or write operation fails, an appropriate error message is logged and the process halts.  
5. When all records are processed, the program closes both files, logs a completion message showing the total records processed, and terminates with a zero return code.  
Throughout the run, status messages are sent to the system log via the `ACAS‑Sysout` routine, giving the user a real‑time audit trail of the restoration.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph aa000-Main-Start, performing argument retrieval, logging setup, and opening the source Audit-File-Seq for reading. [Seen in: aa000-Main-Start.]  
It then enters a loop in aa010-Read-Recs that reads each record from Audit-File-Seq, writes it to the destination Stock-Audit file, and counts input and output records, handling any read or write errors by logging and aborting. [Seen in: aa010-Read-Recs.]  
Upon reaching end‑of‑file or encountering an error, the program executes aa020‑Finish‑Off to close both files, log the record counts, set the return code to zero, and terminate with a GOBACK. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The initialization phase performs zz020-Get-Program-Args to capture command line arguments and sets logging parameters WS-Log-System and WS-Log-File-no. [Seen in: aa000-Main-Start.]  
It initializes counters ws-Rec-Cnt-In and ws-Rec-Cnt-Out to zero and prepares the SO-Print buffer for status messages. [Seen in: aa000-Main-Start.]  
The program opens Audit-File-Seq for input; if the file is missing or unreadable, it logs an error and exits. [Seen in: aa000-Main-Start.]  
It then opens Stock-Audit for output; failure to open results in an error log and exit. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Read Loop  
Trigger: Successful read of Audit-File-Seq record.  
Key steps: Increment input counter, write to Stock-Audit, increment output counter.  
I/O: Audit-File-Seq, Stock-Audit.  
Outcomes: Counters updated; continue loop.  
[Seen in: aa010-Read-Recs.]  

Path: Read Error  
Trigger: FS-Reply not zero after read.  
Key steps: Log error message with SY003 and FS-Reply, go to aa020-Finish-Off.  
I/O: Audit-File-Seq.  
Outcomes: Program terminates after cleanup.  
[Seen in: aa010-Read-Recs.]  

Path: Write Error  
Trigger: FS-Reply not zero after write.  
Key steps: Log SY006, go to aa020-Finish-Off.  
I/O: Stock-Audit.  
Outcomes: Program terminates after cleanup.  
[Seen in: aa010-Read-Recs.]  

Path: End-of-File  
Trigger: read at end.  
Key steps: go to aa020-Finish-Off.  
I/O: Audit-File-Seq.  
Outcomes: Program proceeds to finish.  
[Seen in: aa010-Read-Recs.]  

Path: Open Input File Failure  
Trigger: FS-Reply not zero after opening Audit-File-Seq.  
Key steps: Log "No STaudit file to process", close Stock-Audit, goback.  
I/O: Audit-File-Seq.  
Outcomes: Program exits.  
[Seen in: aa000-Main-Start.]  

Path: Open Output File Failure  
Trigger: FS-Reply not zero after opening Stock-Audit.  
Key steps: Log error, goback.  
I/O: Stock-Audit.  
Outcomes: Program exits.  
[Seen in: aa000-Main-Start.]

5.4 Termination  
The termination phase closes Audit-File-Seq and Stock-Audit, logs the total records processed, sets Return-Code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]  
Any early exit due to file open failures also performs a GOBACK after logging the error. [Seen in: aa000-Main-Start.]

---
## auditUNL
*[42/267]*

### Business/Functional Perspective
### Audit File Unload  

**Program Purpose**  
The program copies the contents of an audit ISAM file into a sequential backup file with a `.seq` extension. It provides a reliable, one‑time backup that can be used to restore the audit file if the original data becomes corrupted or is lost. By logging each step, it helps maintain compliance and traceability of audit data and reduces the risk of data loss.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the audit file cannot be opened, a message stating “No STaudit file to process” is logged.  
- Read failures in the audit file produce a message indicating the problem reading the file.  
- Write failures to the sequential backup file generate a “write error on .seq file” message.  
- Incorrect program arguments trigger a message that the arguments are incorrect.  
- Missing environment variables cause an abort with a message about environment setup.  
- Upon successful completion, a message reports the number of records read and written.

**User Flow Summary**  
The user launches the program, optionally supplying command‑line arguments that the program accepts. The program opens the source audit file and the destination sequential file. It then reads each audit record, writes it to the sequential file, and logs the operation. If any error occurs—such as a missing source file, read or write error, or bad arguments—the program logs an explanatory message and stops. After all records are processed, the program closes the files, logs a final summary of records transferred, and exits.

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **aa000-Main-Start**, where it parses command‑line arguments, sets logging parameters, and writes an initial log message. [Seen in: aa000-Main-Start.]  
It opens the source audit file **Stock‑Audit** for input, checks for errors, and if the file is missing or unreadable logs a message and exits. [Seen in: aa000-Main-Start.]  
It then opens the destination sequential file **Audit‑File‑Seq** for output and enters a loop that reads records from **Stock‑Audit**, writes each to **Audit‑File‑Seq**, and counts records while handling read/write errors. [Seen in: aa010-Read-Recs.]  
Upon reaching the end of the source file or encountering an error, it closes both files, logs the record counts, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to parse command‑line arguments and sets the logging system and file numbers. [Seen in: aa000-Main-Start.]  
It initializes working‑storage variables such as **WS-Log-System**, **WS-Log-File-no**, and clears **SO-Print**. [Seen in: aa000-Main-Start.]  
It opens **Stock‑Audit** for input and verifies the status; if the file is missing or unreadable, it logs a message and terminates. [Seen in: aa000-Main-Start.]  
It then opens **Audit‑File‑Seq** for output and resets the record counters. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal-Processing  
Trigger: Successful open of **Stock‑Audit** and **Audit‑File‑Seq**.  
Key steps: Loop reading each record from **Stock‑Audit**, writing it to **Audit‑File‑Seq**, incrementing input and output counters, and checking for read/write errors.  
I/O: **Stock‑Audit**, **Audit‑File‑Seq**.  
Outcomes: Record counts are maintained; on error the flow jumps to finish.  
[Seen in: aa010-Read-Recs.]

Path: File-Open-Error  
Trigger: **Stock‑Audit** fails to open (FS‑Reply not zero).  
Key steps: Log error message, close **Stock‑Audit**, and exit.  
I/O: **Stock‑Audit**.  
Outcomes: Program terminates with an error status.  
[Seen in: aa000-Main-Start.]

Path: Read-Error  
Trigger: **FS‑Reply** not zero during a read from **Stock‑Audit**.  
Key steps: Log error with **SY003** and **FS‑Reply**, then go to finish.  
I/O: **Stock‑Audit**.  
Outcomes: Program exits with an error status.  
[Seen in: aa010-Read-Recs.]

Path: Write-Error  
Trigger: **FS‑Reply** not zero after writing to **Audit‑File‑Seq**.  
Key steps: Log **SY006**, then go to finish.  
I/O: **Audit‑File‑Seq**.  
Outcomes: Program exits with an error status.  
[Seen in: aa010-Read-Recs.]

Path: End-of-File  
Trigger: Read reaches end of **Stock‑Audit**.  
Key steps: Jump to **aa020-Finish-Off**, close files, log record counts.  
I/O: **Stock‑Audit**, **Audit‑File‑Seq**.  
Outcomes: Normal exit with record counts logged.  
[Seen in: aa010-Read-Recs and aa020-Finish-Off.]

5.4 Termination  
The program closes **Audit‑File‑Seq** and **Stock‑Audit**, logs the total records processed, performs a final **Call‑Sysout**, sets **Return‑Code** to zero, and exits via **GOBACK**. [Seen in: aa020-Finish-Off.]  
If an error occurs earlier, the program logs the error, closes any opened files, and exits immediately via **GOBACK**. [Seen in: aa010-Read-Recs.]

---
## cbl_oc_dump
*[43/267]*

### Business/Functional Perspective
### Memory Hex Dump

**Program Purpose**  
The program provides a quick visual inspection of a memory buffer by printing its contents in hexadecimal form, along with any printable characters. It automatically determines whether the data is in ASCII or EBCDIC and whether the system uses little‑ or big‑endian byte order. This allows developers or support staff to verify that the data they are working with is correct and to spot anomalies that could affect application correctness. The optional extended information can also be shown to confirm the system’s architecture and character set.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- The program displays a header that includes the starting memory address (if requested), the total length of the data, and, when enabled, the architecture, character set, and endian order.  
- If the buffer length is greater than 999,998 bytes, it warns that only the first 999,998 bytes will be shown.  
- When the buffer is empty, it reports “Nothing to dump.”  
- In all other cases, it prints a formatted hex dump table with offsets, hex byte values, and printable character columns.

**User Flow Summary**  
A user invokes the program with a memory buffer supplied as a parameter. The program first determines the length of that buffer and automatically detects the system’s character set and byte order. If the user has requested extended information via an environment variable, the program shows the memory address, length, architecture, character set, and endian order. It then prints a neatly formatted table: each line lists an offset, sixteen hex byte values, and a side column of printable characters (dots for non‑printable data). If the supplied data is empty, the user sees a simple “Nothing to dump.” message; if the data is very large, a warning is displayed before the truncated dump.

**Program Linkages**  
- C$PARAMSIZE

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by performing the STARTING-ADDRESS section to determine the buffer length, character set, endian order, and other environment settings. [Seen in: STARTING-ADDRESS SECTION.]  
It then enters the main dump loop in the MAIN SECTION, iterating over the buffer in 16‑byte blocks, converting each byte to hexadecimal and printable character form, and displaying the formatted line. [Seen in: MAIN SECTION.]  
After completing the dump, the program exits cleanly with an EXIT PROGRAM statement, terminating the execution. [Seen in: MAIN SECTION.]

5.2 Initialization  
The STARTING-ADDRESS section calls the C$PARAMSIZE routine to obtain the transmitted buffer length and accepts environment variables for dot character and extended information flags. [Seen in: STARTING-ADDRESS SECTION.]  
It performs character set detection (TEST-ASCII), endian detection (TEST-ENDIAN), and sets address pointers for the buffer and address display, preparing all variables for the dump operation. [Seen in: STARTING-ADDRESS SECTION.]

5.3 Core Processing  
Path: Starting-Address-Processing  
Trigger: Program entry (performed before dump loop).  
Key steps: call C$PARAMSIZE, accept environment variables, test ASCII, test endian, set address pointers, display address hex line, display extended info if requested.  
I/O: environment variables, buffer length, address display.  
Outcomes: len, addr, addr2addr, char-set, architecture, endian-order, extended-infos flags set.  
[Seen in: STARTING-ADDRESS SECTION.]

Path: Dump-Loop  
Trigger: Varying counter loop in MAIN SECTION.  
Key steps: for each 16‑byte block, build hex-line and show string, compute hex values via CALC-HEX-VALUE, determine printable characters, display offset, hex, and chars.  
I/O: buffer, hex-line, show, SYSERR output.  
Outcomes: formatted dump lines printed to SYSERR.  
[Seen in: MAIN SECTION.]

Path: Test-ASCII  
Trigger: Called from STARTING-ADDRESS.  
Key steps: evaluate space to set is-ascii, is-ebdic, or is-unknown.  
I/O: none.  
Outcomes: character set flag set.  
[Seen in: TEST-ASCII SECTION.]

Path: Test-Endianness  
Trigger: Called from STARTING-ADDRESS.  
Key steps: set address of byte to byline, inspect ord(byte) to set is-big-endian-yes or is-big-endian-no.  
I/O: byline, byte.  
Outcomes: endian-order flag set.  
[Seen in: TEST-ENDIAN SECTION.]

Path: Test-64bit  
Trigger: Executed when extended info level requires architecture details.  
Key steps: compare function length of addr to determine 32‑bit or 64‑bit.  
I/O: addr.  
Outcomes: architecture flag set.  
[Seen in: TEST-64BIT SECTION.]

Path: Calc-hex-value  
Trigger: Invoked from both dump loop and starting-address address display.  
Key steps: subtract 1 from ord(byte), divide by 16 to get high and low nibbles, string hex-digit characters into hex-line.  
I/O: byte, hex-line.  
Outcomes: hex-line updated with two hex digits and a space.  
[Seen in: CALC-HEX-VALUE SECTION.]

5.4 Termination  
After completing the dump, the program issues an EXIT PROGRAM statement and ends with END PROGRAM CBL_OC_DUMP, performing no additional cleanup. [Seen in: MAIN SECTION.]

---
## cobdump
*[44/267]*

### Business/Functional Perspective
### Hexadecimal Character Dump  

**Program Purpose**  
This subroutine generates a formatted hexadecimal and ASCII dump of a data buffer, aiding developers and support staff in inspecting raw memory contents. By supplying a data item and an optional length, the routine outputs the specified bytes to standard error, which can be redirected to a file or console. The resulting dump provides a clear, line‑by‑line view of each byte’s address, numeric value, hex representation, and printable character (or a placeholder for non‑displayable bytes). This tool is valuable for debugging, data validation, and troubleshooting.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
The routine always completes successfully, printing the formatted dump to standard error. If a length argument is omitted, the entire buffer is dumped. No error messages are displayed to the user.  

**User Flow Summary**  
A user calls the subroutine with a buffer and, optionally, a length. The program determines the number of bytes to display, writes a header with column labels, and then processes each byte of the buffer. For each line, it shows the memory address, the byte’s numeric value, two hexadecimal digits, and the corresponding ASCII character (or a special symbol for non‑displayable bytes). Once all specified bytes have been processed, the program ends, leaving the complete dump available on standard error.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph 000-COBDUMP, determining the buffer length and initializing display structures. [Seen in: 000-COBDUMP.]  
It then enters a VARYING loop that processes each byte of the buffer, building a formatted hex/ASCII line in Output-Detail. [Seen in: 000-COBDUMP.]  
Whenever 16 bytes are accumulated, the line is displayed to SYSERR and the address pointer is advanced; after the loop any remaining bytes are displayed before the program exits. [Seen in: 000-COBDUMP.]

5.2 Initialization  
The program checks the number of call parameters; if only one, it uses LENGTH(Buffer) as Buffer-Length, otherwise it uses the supplied Buffer-Len. [Seen in: 000-COBDUMP.]  
It clears Output-Detail, sets Addr-Pointer to the address of Buffer, performs 100-Generate-Address to format the starting address, sets Output-Sub to zero, and writes the header lines to SYSERR. [Seen in: 000-COBDUMP.]

5.3 Core Processing  
Path: Setup  
Trigger: Program entry  
Key steps: Determine Buffer-Length, clear Output-Detail, set Addr-Pointer, perform 100-Generate-Address, set Output-Sub, display headers.  
I/O: None  
Outcomes: Buffer-Length set, Addr-Pointer set, Output-Detail cleared, Output-Sub=0, headers displayed.  
[Seen in: 000-COBDUMP.]

Path: Byte-Processing  
Trigger: Each iteration of the VARYING loop  
Key steps: Increment Output-Sub, set OD-Byte if first byte, load PIC-X from Buffer, set OD-ASCII, compute hex digits, update hex fields.  
I/O: Buffer (read), Output-Detail (write)  
Outcomes: Output-Detail populated per byte, Output-Sub incremented.  
[Seen in: 000-COBDUMP.]

Path: Line-Flush  
Trigger: Output-Sub equals 16  
Key steps: Display Output-Detail, clear Output-Detail, reset Output-Sub, advance Addr-Pointer by 16, perform 100-Generate-Address.  
I/O: Output-Detail (display), Addr-Pointer (update)  
Outcomes: One line of dump displayed, address updated for next line.  
[Seen in: 000-COBDUMP.]

Path: Final-Flush  
Trigger: After loop, if Output-Sub > 0  
Key steps: Display remaining Output-Detail.  
I/O: Output-Detail (display)  
Outcomes: Final partial line displayed.  
[Seen in: 000-COBDUMP.]

Path: Exit  
Trigger: End of procedure  
Key steps: EXIT PROGRAM.  
I/O: None  
Outcomes: Program terminates.  
[Seen in: 000-COBDUMP.]

5.4 Termination  
After any final line is displayed, the program executes EXIT PROGRAM, terminating without closing any files or freeing resources. [Seen in: 000-COBDUMP.]  
No status flags are set beyond the display output. [Seen in: 000-COBDUMP.]

---
## delfolioLD
*[45/267]*

### Business/Functional Perspective
### DelFolio Table Load  

**Program Purpose**  
The program loads transaction data from a DelFolio file into the MySQL purchase‑ledger table. It reads system configuration, establishes a database connection, processes each record, and writes or updates the table while handling duplicate keys. By ensuring the table reflects the most recent transaction data, it supports accurate reporting, audit trails, and reduces the risk of data inconsistencies.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the system configuration file cannot be opened or contains errors, the program aborts and reports the problem.  
- If required database settings are missing, the program displays a warning and stops.  
- When the DelFolio file is missing or unreadable, an error message is logged and the program ends.  
- Duplicate records in the database are detected; the program attempts to rewrite the existing record and notes any key adjustments.  
- Any other write or database error causes a detailed message with the error description, and the program terminates with an error status.  
- At completion, the program outputs a summary of records read, records written, and records rewritten.  

**User Flow Summary**  
The user runs the program, optionally providing command‑line arguments. The program reads system settings to obtain database connection details. It then opens the DelFolio file and the target MySQL table. For each record, it attempts to write the data; if a duplicate key is found, it rewrites the existing entry. Throughout the process, messages are logged but no interactive prompts appear. After all records are processed, the program displays a final tally of processed and updated records and exits, ready for the next operational step.  

**Program Linkages**  
- acas023  
- acas-get-params  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **aa000-main-start**, performing argument parsing, system file opening, and system record reading before configuring database parameters. [Seen in: aa000-main-start.]  
It then overrides file and duplicate handling settings, opens the DelFolio COBOL file and the MySQL table via acas023 calls, and enters a loop that reads each DelFolio record and writes it to the database. [Seen in: aa010-Proc-Override, aa010-Read.]  
Duplicate key errors trigger a rewrite of the record with a modified key, while other database errors cause rollback and program termination. [Seen in: aa010-Read, aa020-Rollback.]  
Upon reaching end‑of‑file or encountering a fatal error, the program commits any pending changes, closes all files, logs summary statistics, and exits. [Seen in: aa999-Finish.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args**, sets logging parameters, and opens the system file to read configuration records. [Seen in: aa000-main-start.]  
It validates the system record, loads RDBMS connection details either from the record or from **acas-get-params**, and initializes file and duplicate flags before proceeding to file opening. [Seen in: aa000-main-start, aa010-Proc-Override.]

5.3 Core Processing  

Path: Record Read & Write  
Trigger: Successful read of a DelFolio record (FS-Reply not 10 or 0)  
Key steps: read next record via **acas023-Read-Next**, increment input count, set file system flags, write to RDB via **acas023-Write**, handle duplicate key or other SQL errors, increment output count, loop back to read next.  
I/O: DelFolio COBOL file, MySQL table via acas023.  
Outcomes: successful write increments **ws-Rec-Cnt-Out**; duplicate key triggers rewrite and increments **ws-Rec-Cnt-R-Out**; non‑duplicate errors cause rollback and exit. [Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: FS-Reply = 22 or 99 or SQL-STATE = "23000" or SQL-ERR 1062/1022  
Key steps: clear FS-Reply and WE-Error, perform **acas023-Rewrite**, if rewrite fails output key error message, otherwise increment rewrite count, continue reading.  
I/O: DelFolio COBOL file, MySQL table.  
Outcomes: record rewritten, counts updated, loop continues. [Seen in: aa010-Read.]

Path: Error Handling  
Trigger: FS-Reply not zero and not duplicate key (e.g., SQL error)  
Key steps: output error messages via **Call-Sysout**, optionally rollback via **aa020-Rollback**, set return-code 16, go to **aa999-Finish**.  
I/O: none beyond logging.  
Outcomes: program terminates with error status. [Seen in: aa010-Read, aa020-Rollback, aa999-Finish.]

Path: End-of-File  
Trigger: FS-Reply = 10 (EOF)  
Key steps: go to **aa999-Finish**, output summary counts, close files, commit/rollback as needed.  
I/O: close DelFolio file, close MySQL table, system file.  
Outcomes: program exits normally. [Seen in: aa010-Read, aa999-Finish.]

Path: Override Setup  
Trigger: after system record read and DB parameters loaded  
Key steps: set file system and duplicate flags to zero, set File-Key-No to 1, open input file via **acas023-Open-Input**, open RDB via **acas023-Open**, handle open errors, set Access-Type to zero, go to **aa010-Read**.  
I/O: system file, DelFolio file, MySQL table.  
Outcomes: ready to process records. [Seen in: aa010-Proc-Override.]

5.4 Termination  
The **aa999-Finish** paragraph logs record counts, closes the RDB and DelFolio files, closes the system file, and calls **Call-Sysout** to indicate completion. [Seen in: aa999-Finish.]  
The program then returns control to the caller via GOBACK, leaving the return-code set to indicate success or failure. [Seen in: aa999-Finish.]

---
## delfolioMT
*[46/267]*

### Business/Functional Perspective
### Deleted Folio Number Management  

**Program Purpose**  
The program handles the storage, retrieval, updating and removal of deleted folio numbers used by the purchase module of the ACAS system. It provides a single point of access to the PUDELINV‑REC table, ensuring that all deleted folio records are entered, maintained, and deleted consistently and that the database remains in a valid state. By logging operations and catching duplicate or invalid requests, it supports auditability and reduces the risk of data corruption in the accounting records.  

**Screen Interactions**  
No direct screens are presented to the user. The program may display diagnostic information during debugging, but it is invoked by other ACAS modules and simply returns status codes and updated record data.  

**Messages and Errors**  
- **Success** – Operation completes without issue.  
- **No Data** – Requested record does not exist or the table is empty.  
- **Duplicate Key** – Attempt to write a record that already exists.  
- **Record Not Found** – Read or delete request for a non‑existent key.  
- **Invalid Function** – Unsupported file function or bad parameters.  
- **Database Error** – Connection problems, SQL errors, or internal failures.  
- **Unexpected Error** – Any other error that prevents completion.  

These messages are returned in the linkage area (e.g., FS‑Reply, WE‑Error, SQL‑Err, SQL‑Msg) and may be logged for audit purposes.  

**User Flow Summary**  
1. A calling module supplies the deleted folio record (folio number, date, customer) and a file function code (open, close, read next, read indexed, start, write, delete, delete‑all, rewrite).  
2. The program opens the MySQL connection if needed, then performs the requested operation:  
   * **Read** – Retrieves the next or indexed record and returns it.  
   * **Write** – Inserts a new record, checking for duplicates.  
   * **Delete** – Removes the specified record.  
   * **Delete‑All** – Clears the entire table.  
   * **Rewrite** – Updates an existing record.  
   * **Open/Close** – Manages the database session.  
3. After the action, the program sets status codes and, if applicable, populates the record buffer with the retrieved data.  
4. Any errors are captured, logged, and reported back via the status fields, allowing the calling module to inform the user or take corrective action.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs in the PROCEDURE DIVISION, which evaluates the File‑Function to dispatch to one of the process paragraphs. [Seen in: ba-ACAS-DAL-Process]  
Each process paragraph performs the requested database operation and then performs ba999‑end for cleanup and exit. [Seen in: ba999-end]  
The program uses a cursor flag to manage result sets across read operations. [Seen in: Cursor-Active variable usage in ba040‑Process‑Read‑Next and ba041‑Reread]

5.2 Initialization  
On entry, ws‑env‑lines is accepted and environment variables for screen exceptions are set. [Seen in: ba010‑Initialise]  
All key status variables (WS‑MYSQL‑Error‑Message, WS‑MYSQL‑Error‑Number, SQL‑Msg, SQL‑Err, SQL‑State) are cleared and Cursor‑Active is set to false. [Seen in: ba010‑Initialise]

5.3 Core Processing  

Path: Process‑Open  
Trigger: File‑Function = 1  
Key steps: Build MySQL connection parameters, perform MYSQL‑1000‑OPEN, set cursor inactive, set WS‑File‑Key to “OPEN Delfolio”. [Seen in: ba020‑Process‑Open]  
I/O: MySQL connection (WS‑MYSQL‑BASE‑NAME, WS‑MYSQL‑HOST‑NAME, etc.) [Seen in: ba020‑Process‑Open]  
Outcomes: FS‑Reply set to 0 on success, WE‑Error remains 0; cursor inactive. [Seen in: ba020‑Process‑Open]  

Path: Process‑Read‑Next  
Trigger: File‑Function = 3  
Key steps: If cursor inactive, construct WHERE clause for key >= “00000000”, perform SELECT, store result, set cursor active; otherwise fetch next record. [Seen in: ba040‑Process‑Read‑Next, ba041‑Reread]  
I/O: PUDELINV‑REC table via SELECT and FETCH. [Seen in: ba040‑Process‑Read‑Next, ba041‑Reread]  
Outcomes: FS‑Reply 0 with record data, or 10/EOF if no more rows; WE‑Error 0 unless error. [Seen in: ba040‑Process‑Read‑Next, ba041‑Reread]  

Path: Process‑Start  
Trigger: File‑Function = 9  
Key steps: Validate access‑type, clear cursor, build WHERE clause with relation operator, perform SELECT, set cursor active if rows found. [Seen in: ba060‑Process‑Start]  
I/O: PUDELINV‑REC table via SELECT. [Seen in: ba060‑Process‑Start]  
Outcomes: FS‑Reply 0 with row count, WE‑Error 0; if no rows, FS‑Reply 21. [Seen in: ba060‑Process‑Start]  

Path: Process‑Write  
Trigger: File‑Function = 5  
Key steps: Load host variables from record, perform INSERT via bb200‑Insert, check affected rows, handle duplicate key error. [Seen in: ba070‑Process‑Write, bb200‑Insert]  
I/O: PUDELINV‑REC table via INSERT. [Seen in: bb200‑Insert]  
Outcomes: FS‑Reply 0 on success, WE‑Error 0; on duplicate key, FS‑Reply 22. [Seen in: ba070‑Process‑Write]  

Path: Process‑Delete  
Trigger: File‑Function = 8  
Key steps: Build WHERE clause for key, perform DELETE, check affected rows. [Seen in: ba080‑Process‑Delete]  
I/O: PUDELINV‑REC table via DELETE. [Seen in: ba080‑Process‑Delete]  
Outcomes: FS‑Reply 0 on success, WE‑Error 0; if not exactly one row deleted, FS‑Reply 99. [Seen in: ba080‑Process‑Delete]  

Path: Process‑Delete‑ALL  
Trigger: File‑Function = 6  
Key steps: Set key to maximum value, build WHERE clause for key < max, perform DELETE, check affected rows. [Seen in: ba085‑Process‑Delete‑ALL]  
I/O: PUDELINV‑REC table via DELETE. [Seen in: ba085‑Process‑Delete‑ALL]  
Outcomes: FS‑Reply 0 on success, WE‑Error 0; if no rows deleted, FS‑Reply 99. [Seen in: ba085‑Process‑Delete‑ALL]  

5.4 Termination  
The ba999‑end paragraph performs optional logging, then exits the program. [Seen in: ba999‑end]  
All cursors are freed via ba998‑Free before exit if active. [Seen in: ba998‑Free]

---
## delfolioRES
*[47/267]*

### Business/Functional Perspective
### Delfolio File Restore

**Program Purpose**  
This utility restores records from a sequential file named *delfolio.seq* by reading each record and writing it back to a destination file, thereby creating a backup copy or performing a restoration. It ensures that all records are transferred safely and records the number of records processed. The process supports auditability by logging detailed status messages to a system log file, helping maintain data integrity and compliance.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- The program reports if the source file is missing or cannot be opened.  
- It logs an error if reading from the source file fails, indicating the problematic record.  
- An error is reported if writing to the destination file fails.  
- At completion, it logs the total number of records read and written.  
- Any unexpected system status causes the program to terminate immediately, logging the issue.

**User Flow Summary**  
When the user runs the program, it automatically attempts to open the *delfolio.seq* file for reading. If the file is not found or cannot be accessed, the user is informed via the log that no records were processed and the program exits. If the file is available, the program reads each record sequentially and writes it to the destination file, counting the number of successful reads and writes. Upon reaching the end of the source file or encountering an error, the program closes both files and logs a summary showing how many records were read and written. The log file, *SYS-DISPLAY.log*, is the only visible output, providing a record of the operation’s outcome.

**Program Linkages**  
- ACAS-Sysout

---

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa000-Main-Start, performing argument retrieval, logging setup, and opening the input sequential file. [Seen in: aa000-Main-Start.]  
If the input file opens successfully, the program opens the output file and then enters a loop in aa010-Read-Recs to read each record and write it to the output file. [Seen in: aa010-Read-Recs.]  
Upon reaching end‑of‑file or encountering an error, the program jumps to aa020-Finish-Off to close files, report counts, and exit. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program retrieves command line arguments via zz020-Get-Program-Args and initializes logging parameters before any file operations. [Seen in: aa000-Main-Start.]  
It then opens the input file Del-Inv-Nos-File-Seq, checks FS-Reply, and logs a message if the file is missing or unreadable. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Input File Open  
Trigger: Execution of aa000-Main-Start before opening Del-Inv-Nos-File-Seq.  
Key steps: open input file, test FS-Reply, log error and goback if not zero.  
I/O: Del-Inv-Nos-File-Seq.  
Outcomes: sets SO-Print, logs message, terminates if error.  
[Seen in: aa000-Main-Start.]

Path: Output File Open  
Trigger: Successful input file open, proceeding to open Del-Inv-Nos-File.  
Key steps: open output file, test FS-Reply, log error and goback if not zero.  
I/O: Del-Inv-Nos-File.  
Outcomes: sets SO-Print, logs message, terminates if error.  
[Seen in: aa000-Main-Start.]

Path: Read and Write Loop  
Trigger: Perform forever in aa010-Read-Recs.  
Key steps: read next record, check FS-Reply for end or error, write record, check FS-Reply, increment counters.  
I/O: Del-Inv-Nos-File-Seq (read), Del-Inv-Nos-File (write).  
Outcomes: updates ws-Rec-Cnt-In and ws-Rec-Cnt-Out, may trigger error paths.  
[Seen in: aa010-Read-Recs.]

Path: Error on Read  
Trigger: FS-Reply not zero after a read operation in aa010-Read-Recs.  
Key steps: construct error message with SY003 and FS-Reply, call Sysout, go to aa020-Finish-Off.  
I/O: none.  
Outcomes: logs error, exits loop, proceeds to finish.  
[Seen in: aa010-Read-Recs.]

Path: Error on Write  
Trigger: FS-Reply not zero after a write operation in aa010-Read-Recs.  
Key steps: set SO-Print to SY006, call Sysout, go to aa020-Finish-Off.  
I/O: none.  
Outcomes: logs write error, exits loop, proceeds to finish.  
[Seen in: aa010-Read-Recs.]

Path: Finish Off  
Trigger: go to aa020-Finish-Off from end-of-file or error.  
Key steps: close both files, log record counts, set Return-Code to zero, goback.  
I/O: Del-Inv-Nos-File-Seq, Del-Inv-Nos-File.  
Outcomes: program terminates cleanly with zero return code.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes the input and output files, logs the total records processed, and sets Return-Code to zero before exiting via goback. [Seen in: aa020-Finish-Off.]  
No additional cleanup is performed beyond file closure and logging. [Seen in: aa020-Finish-Off.]

---
## delfolioUNL
*[48/267]*

### Business/Functional Perspective
### delfolio UNLoad  

**Program Purpose**  
The delfolioUNL program creates a backup of the existing delfolio data by copying each record from the active delfolio file into a new sequential file named *delfolio.seq*. It logs the operation, including the number of records transferred, to aid in audit and recovery. This ensures that an up‑to‑date, portable copy of the data is available if the original file becomes corrupted or inaccessible, reducing risk to the business.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- *No delfolio file to process* – the source file is missing.  
- *Problem reading delfolio file = …* – an error occurred while reading the source.  
- *Write error on .seq file* – the backup file could not be written.  
- *Program arguments incorrect: …* – the command‑line arguments are not in the expected format.  
- *Note message & Hit return* – a generic informational prompt.  
- *Environment variables not yet set up : ABORTING* – required settings are missing, so the program stops.

**User Flow Summary**  
A user starts the program (typically via a scheduled batch job or manual execution). The program checks for the presence of the current delfolio file. If it exists, it reads each record and writes it to a new sequential file called *delfolio.seq*, counting how many records are processed. Throughout the run, status messages and any errors are written to a log file (SYS‑DISPLAY.log). When finished, the program reports the total number of records read and written, then exits.

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph aa000-Main-Start, where it retrieves command‑line arguments and logs a header message. It then opens the source delfolio file for input, and if the file is missing or unreadable it logs an error and exits. If the file is available, it opens a sequential output file and enters the aa010-Read-Recs loop to copy each record. Upon reaching the end of the source file or encountering an error, control transfers to aa020-Finish-Off, which closes files, logs the record counts, and terminates. [Seen in: aa000-Main-Start.][Seen in: aa010-Read-Recs.][Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command‑line parameters, then sets logging system and file numbers and writes a header via Call‑Sysout. It opens the input delfolio file and checks FS‑Reply; if an error occurs it logs a message and exits. If the input file opens successfully, it opens the output sequential file and initializes the record counters to zero. [Seen in: zz020-Get-Program-Args.][Seen in: aa000-Main-Start.][Seen in: Call‑Sysout.]

5.3 Core Processing  
Path: Read and Write Records  
Trigger: Execution of aa010-Read-Recs loop.  
Key steps: Read next record from Del‑Inv‑Nos‑File; if FS‑Reply non‑zero, log error and exit; increment ws‑Rec‑Cnt‑In; write record to Del‑Inv‑Nos‑File‑Seq; if FS‑Reply non‑zero, log write error and exit; increment ws‑Rec‑Cnt‑Out.  
I/O: Del‑Inv‑Nos‑File, Del‑Inv‑Nos‑File‑Seq.  
Outcomes: Updated record counters, potential error messages, eventual transfer to aa020‑Finish‑Off on end or error. [Seen in: aa010-Read-Recs.]

Path: Finish‑Off  
Trigger: End of aa010-Read-Recs loop or error condition.  
Key steps: Close Del‑Inv‑Nos‑File‑Seq and Del‑Inv‑Nos‑File; log total records in and out; log a “CLOSE” message; set Return‑Code to zero; goback.  
I/O: Del‑Inv‑Nos‑File, Del‑Inv‑Nos‑File‑Seq.  
Outcomes: Files closed, final counts logged, program exits cleanly. [Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs the total number of records processed, and performs a goback to terminate. A zero Return‑Code is set just before exiting. [Seen in: aa020-Finish-Off.]

---
## deliveryLD
*[49/267]*

### Business/Functional Perspective
### Delivery Table Load

**Program Purpose**  
This program imports delivery data from a COBOL delivery file into a MySQL database for the company’s sales and purchase ledgers. It ensures that only valid records are inserted, handles duplicate entries by rewriting where appropriate, and records progress and errors in a system log. By centralizing the load process it reduces manual data entry errors, guarantees audit‑ready data, and supports compliance with financial reporting requirements.

**Screen Interactions**  
No direct screens. This program is executed as a batch job after the delivery file has been created and returns status information to the logging subsystem.

**Messages and Errors**  
- *File access failures*: reports problems opening the system configuration file or the delivery file itself.  
- *Database configuration issues*: alerts when database details are missing or the parameters file cannot be read.  
- *Duplicate record handling*: notes when a record already exists and is updated instead of inserted.  
- *Write failures*: displays an error if a record cannot be written to the database due to a SQL error or other database issue.  
- *General errors*: reports any other unexpected problems that stop the load, indicating the nature of the failure.

**User Flow Summary**  
The user launches the program, optionally passing arguments. The program reads system parameters, then opens the delivery file and the target MySQL table. It reads each delivery record, attempts to insert it into the database, and if a duplicate key is found it rewrites the existing record. Throughout the process, progress and any errors are logged. When the file ends, the program commits the changes (or rolls back if configured), prints a summary of records processed and written, and closes all resources before exiting.

**Program Linkages**  
- acas-get-params  
- acas014  
- ACAS-Sysout  
- MySQL_rollback  
- MySQL_commit

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at aa000-main-start, parsing arguments, initializing logging, and opening the system file to load database parameters. [Seen in: aa000-main-start.]  
It then loads RDBMS settings from acas.param if required, overrides file-system flags, and opens both the COBOL delivery file and the MySQL delivery table via acas014 calls. [Seen in: aa010-Proc-Override.]  
The main loop reads each delivery record, writes it to the database, handles duplicate keys by rewriting or counting, and continues until EOF, after which it finalizes counts, commits, and closes all resources. [Seen in: aa010-Read, aa999-Finish.]  
On encountering a write error other than a duplicate key, the program logs the error, sets a return code, and aborts to the finish routine. [Seen in: aa010-Read.]

5.2 Initialization  
The program parses command‑line arguments with zz020-Get-Program-Args, sets logging parameters, and opens the system file to obtain database configuration. [Seen in: aa000-main-start.]  
If the system file indicates no database or Cobol files are in use, it attempts to read acas.param; on success it populates RDBMS fields and jumps to aa010-Proc-Override. [Seen in: aa010-Proc-Override.]  
It then sets file‑system flags, opens the delivery COBOL file (acas014‑Open‑Input) and the MySQL table (acas014‑Open), and initializes counters. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  

Path: No Delivery File  
Trigger: FS‑Reply = 35 after acas014‑Open‑Input.  
Key steps: Log a message, close the system file, close the delivery file, and exit.  
I/O: System‑File, Delivery File.  
Outcomes: Program terminates with no records processed.  
[Seen in: aa010-Proc-Override.]

Path: Duplicate Key Handling  
Trigger: SQL‑State = "23000" or FS‑Reply = 22 or 99 or SQL‑Err 1062/1022 after acas014‑Write.  
Key steps: Reset FS‑Reply and WE‑Error, rewrite the record, increment the rewrite counter, and continue reading.  
I/O: Delivery File, MySQL table.  
Outcomes: Duplicate records are counted and rewritten; processing continues.  
[Seen in: aa010-Read.]

Path: Normal Record Processing  
Trigger: FS‑Reply = 0 after acas014‑Write and no duplicate key.  
Key steps: Increment the output counter and proceed to the next record.  
I/O: Delivery File, MySQL table.  
Outcomes: Record successfully written; counters updated.  
[Seen in: aa010-Read.]

Path: Error on Write  
Trigger: FS‑Reply not zero after acas014‑Write (other than duplicate conditions).  
Key steps: Log error details, set return‑code 16, and jump to aa999‑Finish.  
I/O: Delivery File, MySQL table.  
Outcomes: Processing aborts, counts displayed, resources closed.  
[Seen in: aa010-Read.]

Path: End‑of‑File  
Trigger: FS‑Reply = 10 after acas014‑Read‑Next.  
Key steps: Jump to aa999‑Finish, display counts, commit, close files.  
I/O: Delivery File, MySQL table, System‑File.  
Outcomes: Program ends gracefully.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program writes final record counts, logs closure messages, commits any remaining transactions, closes the system file and both delivery and database files, and returns control. [Seen in: aa999-Finish.]

---
## deliveryMT
*[50/267]*

### Business/Functional Perspective
### Delivery Record Management  

**Program Purpose**  
The program provides a single interface for accessing delivery records stored in a relational database. It allows other parts of the system to open and close the connection, read records sequentially or by key, add new records, update existing ones, delete individual records, or clear the entire table. The routine guarantees that data is written or retrieved consistently, prevents duplicate keys, and reports any database‑level problems, thereby supporting accurate reporting and auditability of delivery information.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Success** – operation completed and data returned (or written).  
- **Not Found** – requested key does not exist.  
- **Duplicate Key** – attempt to add a record that already exists.  
- **Connection or Access Error** – database connection failed or query failed.  
- **End‑of‑File** – no more records to read.  
- **No Data** – table contains no rows when a read or start is requested.  

**User Flow Summary**  
1. A calling module supplies the desired function (open, close, read next, read indexed, start, write, delete, rewrite, or delete all) and the data record to operate on.  
2. The routine opens a database connection if required, then performs the requested operation.  
3. For reads, the routine returns the matching record and a status code indicating success, end‑of‑file, or not‑found.  
4. For writes or deletes, the routine reports whether the action succeeded, failed because the key already existed, or failed due to a database error.  
5. After completion, the routine closes the connection if it had opened one and passes back the final status and any error details to the caller for further processing or user notification.

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the entry paragraph **ba-ACAS-DAL-Process**, where it accepts environment lines, sets screen exception handling, and clears error fields. [Seen in: ba-ACAS-DAL-Process.]  
It then evaluates the **File-Function** value to dispatch to one of the operation-specific paragraphs (Open, Close, Read‑Next, Read‑Indexed, Start, Write, Delete, Delete‑All, Rewrite, or Bad‑Function). [Seen in: ba-ACAS-DAL-Process.]  
Each operation paragraph performs its database action and finally transfers control to **ba999-end** for logging and program exit. [Seen in: ba999-end.]

5.2 Initialization  
The program accepts the number of environment lines, sets a minimum of 24 lines for screen handling, and enables screen exception and escape key detection. [Seen in: ba010-Initialise.]  
It clears all error and status fields (WS‑MYSQL‑Error‑Message, WS‑MYSQL‑Error‑Number, WS‑Log‑Where, WS‑File‑Key, SQL‑Msg, SQL‑Err, SQL‑State) before determining the requested operation. [Seen in: ba010-Initialise.]

5.3 Core Processing  

Path: Open  
Trigger: File‑Function = 1  
Key steps: Build MySQL connection parameters from linkage areas, perform MYSQL‑1000‑OPEN, set cursor inactive, and set FS‑Reply to 0.  
I/O: MYSQL‑OPEN procedure, no table access.  
Outcomes: Successful connection sets WS‑File‑Key to “OPEN DELIVERY”; on error FS‑Reply non‑zero and control goes to ba999-end.  
[Seen in: ba020-Process-Open.]

Path: Read‑Next  
Trigger: File‑Function = 3 (and cursor inactive)  
Key steps: Construct a SELECT query for all records with DELIV‑KEY > “00000000”, execute it, store the result, and fetch the first row.  
I/O: SELECT on DELIVERY‑REC table, MYSQL‑FETCH.  
Outcomes: If no rows, FS‑Reply set to 10 and WS‑File‑Key “No Data”; otherwise cursor becomes active and the first record is loaded into WS‑Delivery‑Record.  
[Seen in: ba040-Process-Read-Next.]

Path: Start  
Trigger: File‑Function = 9 (access‑type 5‑9)  
Key steps: Build a SELECT query with a comparison operator based on Access‑Type, execute it, and set cursor active if rows exist.  
I/O: SELECT on DELIVERY‑REC table.  
Outcomes: If rows found, cursor active and WS‑File‑Key contains a message with the count; if none, FS‑Reply set to 21 and WE‑Error cleared.  
[Seen in: ba060-Process-Start.]

Path: Write  
Trigger: File‑Function = 5  
Key steps: Load host variables from WS‑Delivery‑Record, build an INSERT statement, execute it, and check for duplicate key errors.  
I/O: INSERT on DELIVERY‑REC table.  
Outcomes: On success FS‑Reply and WE‑Error remain zero; on duplicate key FS‑Reply set to 22; on other errors FS‑Reply set to 99.  
[Seen in: ba070-Process-Write.]

Path: Delete  
Trigger: File‑Function = 8  
Key steps: Build a DELETE statement for the key in WS‑Delivery‑Record, execute it, and verify that exactly one row was deleted.  
I/O: DELETE on DELIVERY‑REC table.  
Outcomes: If deletion fails, FS‑Reply set to 99 and WE‑Error to 995; otherwise FS‑Reply and WE‑Error remain zero.  
[Seen in: ba080-Process-Delete.]

Path: Rewrite  
Trigger: File‑Function = 7  
Key steps: Load host variables, build an UPDATE statement for the key, execute it, and confirm one row was updated.  
I/O: UPDATE on DELIVERY‑REC table.  
Outcomes: On failure FS‑Reply set to 99 and WE‑Error to 994; on success FS‑Reply and WE‑Error remain zero.  
[Seen in: ba090-Process-Rewrite.]

5.4 Termination  
After each operation, control reaches **ba999-end**, where optional logging is performed if Testing‑1 is true, and the program exits via **ba999-exit**. [Seen in: ba999-end, ba999-exit.]  
The program ensures any active cursor is freed in **ba998-Free** before exiting, setting Cursor‑Not‑Active to true. [Seen in: ba998-Free.]

---
## deliveryRES
*[51/267]*

### Business/Functional Perspective
### Delivery File Backup  

**Program Purpose**  
This program restores or backs up delivery records by copying each record from a source sequential file to a target delivery file. It ensures that the data set is transferred safely, counts the number of records processed, and logs the outcome. The routine supports audit and recovery processes, helping maintain data integrity and providing a quick way to duplicate or restore the delivery data set.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *File not found*: “No delivery file to process.”  
- *Open failure*: “Failed on open – Delivery file = [error]”.  
- *Read error*: “Problem reading .seq file = [error]”.  
- *Write error*: “Write error on .dat file”.  
- *General abort*: “Environment variables not yet set up : ABORTING”.  

**User Flow Summary**  
1. The user initiates the program, optionally providing arguments (though they are not used for data processing).  
2. The program verifies that a sequential delivery file exists; if not, it logs a message and stops.  
3. It opens a target delivery file for writing.  
4. It reads each record from the source file, writes it to the target file, and updates counters.  
5. After all records are processed (or an error occurs), it closes both files, logs the total number of records read and written, and exits.  
6. The user can review the logged messages in the SYS‑DISPLAY.log file to confirm success or diagnose any issues.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-Main-Start, performing argument parsing, logging setup, and opening the source delivery sequence file. [Seen in: aa000-Main-Start.]  
It then opens the destination delivery file for writing, handling any open errors before proceeding. [Seen in: aa000-Main-Start.]  
The main processing loop in aa010-Read-Recs reads each record from the source file, writes it to the destination file, and counts records, terminating when the source file ends or an error occurs. [Seen in: aa010-Read-Recs.]  
After the loop, aa020-Finish-Off closes both files, logs the record counts, and exits the program. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command‑line arguments and initializes logging parameters WS-Log-System and WS-Log-File-no. [Seen in: aa000-Main-Start.]  
It prints a header message via Call‑Sysout and then attempts to open the input delivery sequence file, checking FS‑Reply for errors. [Seen in: aa000-Main-Start.]  
If the input file opens successfully, it proceeds to open the output delivery file, again verifying FS‑Reply and handling any failures. [Seen in: aa000-Main-Start.]  
Record counters and other working storage are zeroed before entering the read loop. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Open-Input-File  
Trigger: Execution of aa000-Main-Start before opening Delivery-File-Seq.  
Key steps: perform zz020-Get-Program-Args, set logging, call Call‑Sysout, open input Delivery-File-Seq, check FS‑Reply, error handling with Call‑Sysout and goback if needed.  
I/O: Delivery-File-Seq (input).  
Outcomes: If FS‑Reply zero, program proceeds; otherwise exits with error message.  
[Seen in: aa000-Main-Start.]

Path: Open-Output-File  
Trigger: After successful input file open, aa000-Main-Start opens Delivery-File for output.  
Key steps: open output Delivery-File, check FS‑Reply, error handling with Call‑Sysout and goback if needed.  
I/O: Delivery-File (output).  
Outcomes: If FS‑Reply zero, program proceeds to read loop; otherwise exits.  
[Seen in: aa000-Main-Start.]

Path: Normal-Read-Write-Loop  
Trigger: Execution of aa010-Read-Recs performing forever loop.  
Key steps: read next record from Delivery-File-Seq, increment ws-Rec-Cnt-In, write record to Delivery-File, increment ws-Rec-Cnt-Out, loop until end of file.  
I/O: Delivery-File-Seq (input), Delivery-File (output).  
Outcomes: Successful transfer of all records, counters updated, loop ends at end‑of‑file.  
[Seen in: aa010-Read-Recs.]

Path: Read-Error-Exit  
Trigger: FS‑Reply non‑zero after a read operation in aa010-Read-Recs.  
Key steps: construct error message with SY003 and FS‑Reply, call Call‑Sysout, go to aa020-Finish-Off.  
I/O: Delivery-File-Seq (input).  
Outcomes: Program jumps to finish, closes files, logs counts, exits.  
[Seen in: aa010-Read-Recs.]

Path: Write-Error-Exit  
Trigger: FS‑Reply non‑zero after a write operation in aa010-Read-Recs.  
Key steps: set SO-Print to SY006, call Call‑Sysout, go to aa020-Finish-Off.  
I/O: Delivery-File (output).  
Outcomes: Program jumps to finish, closes files, logs counts, exits.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: Execution of aa020-Finish-Off after loop completion or error.  
Key steps: close Delivery-File-Seq and Delivery-File, build summary message, call Call‑Sysout, set Return-Code to zero, goback.  
I/O: Delivery-File-Seq, Delivery-File.  
Outcomes: Files closed, summary logged, program terminates with Return-Code zero.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program terminates by executing goback in aa020-Finish-Off after closing both files and logging the final record counts. [Seen in: aa020-Finish-Off.]  
A zero Return-Code is set just before exit, indicating successful completion. [Seen in: aa020-Finish-Off.]

---
## deliveryUNL
*[52/267]*

### Business/Functional Perspective
### Delivery File Backup  

**Program Purpose**  
This utility creates a sequential backup of the system’s delivery data file. It reads each record from the current delivery file and writes it to a new “delivery.seq” file. The backup is intended as a safeguard that can be used to restore the original data if corruption or loss occurs. The process records progress and counts to a log for audit and troubleshooting.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **File missing or unreadable** – the program notes that there is no delivery file to process.  
- **Read error** – if a record cannot be read, an error message indicating a problem reading the batch file is logged.  
- **Write error** – if a record cannot be written to the backup file, a write‑error message is logged.  
- **Incorrect arguments** – if command‑line arguments are wrong, an error message about program arguments is logged.  
- **Missing environment setup** – if required environment variables are not set, an error message is logged.  
- **Success** – upon completion, the log shows the number of records read and written.  

**User Flow Summary**  
A user or automated process starts the backup by invoking the program with the required arguments. The program opens the existing delivery file, copies each record into a new sequential file, and logs the progress and record counts to the system display log. If any step fails—such as the source file not existing, a read/write error, or missing environment settings—the program writes an explanatory message to the log and stops. On successful completion, the log reports how many records were processed and the backup file “delivery.seq” is ready for use.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins by retrieving command line arguments, setting logging parameters, and logging a header message. [Seen in: aa000-Main-Start.]  
It then opens the source delivery file for input, verifies its existence, and opens a sequential output file for writing. [Seen in: aa000-Main-Start.]  
The main loop reads each record from the source file, writes it to the output file, and tracks record counts until end‑of‑file or an error occurs, after which it closes files, logs a summary, and exits. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line parameters and initializes logging system identifiers. [Seen in: aa000-Main-Start.]  
It sets WS-Log-System and WS-Log-File-no, clears SO-Print, and logs a startup message via Call‑Sysout. [Seen in: aa000-Main-Start.]  
It opens the input delivery file, checks FS-Reply for errors, and if none, opens the output delivery-File-Seq, resetting record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Argument Retrieval  
Trigger: Program start  
Key steps: perform zz020-Get-Program-Args, set logging parameters, log header.  
I/O: None  
Outcomes: logging parameters set, header message logged.  
[Seen in: aa000-Main-Start.]

Path: File Open  
Trigger: After initialization  
Key steps: open input Delivery-File, check FS-Reply, open output delivery-File-Seq, initialize counters.  
I/O: Delivery-File, delivery-File-Seq  
Outcomes: files opened, counters zeroed, error message logged if input file missing.  
[Seen in: aa000-Main-Start.]

Path: Record Processing  
Trigger: Loop in aa010-Read-Recs  
Key steps: read next record, check FS-Reply, increment ws-Rec-Cnt-In, write record to delivery-File-Seq, check FS-Reply, increment ws-Rec-Cnt-Out; on error or end-of-file, branch to aa020-Finish-Off.  
I/O: Delivery-File, delivery-File-Seq  
Outcomes: records copied, counters updated, error status handled, exit to finish.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: End-of-file or error during processing  
Key steps: close delivery-File-Seq and Delivery-File, build summary string, log summary and close message, set Return-Code to zero, goback.  
I/O: Delivery-File, delivery-File-Seq  
Outcomes: files closed, summary logged, program terminates.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs a summary of records processed, and sets Return-Code to zero before exiting with goback. [Seen in: aa020-Finish-Off.]  
Any code following the goback (copy of Proc-Get-Env-Set-Files.cob and a subsequent Call‑Sysout) is unreachable and therefore not executed. [Seen in: aa020-Finish-Off.]

---
## dfltLD
*[53/267]*

### Business/Functional Perspective
### Default Table Loading

**Program Purpose**  
The program reads the default system configuration and loads or updates the corresponding records into the MySQL database. It ensures that the database tables reflect the current system settings and that duplicate entries are updated rather than duplicated. The routine validates the presence of required configuration data and terminates gracefully if any critical information is missing. By maintaining an up‑to‑date default table, the application guarantees consistent behavior across all modules that rely on these settings.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the system file cannot be opened or read, the program stops and displays an error indicating a missing or corrupt configuration file.  
- When database connection details are absent or the database is not configured, the program reports the missing parameters and aborts.  
- If a record that is about to be written already exists, the program updates that record instead of inserting a duplicate.  
- For any other database write errors (e.g., syntax, permission, or network issues), the program reports the error details and terminates.  
- Upon successful completion, the program displays a summary showing how many records were processed and how many were updated.  

**User Flow Summary**  
The user runs the program from the command line, optionally passing two arguments. The routine first reads the system file to obtain configuration values and then checks that a MySQL connection can be established. It proceeds to write or update the default table entries, handling duplicate keys by performing a rewrite. Throughout the process, any problems are reported to the console via the standard system output routine. After all records are processed, a concise summary of actions taken is printed, and the program ends.  

**Program Linkages**  
- acas-get-params  
- dfltMT  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **aa000-main-start**, performing argument parsing, displaying the program name, and opening the system parameter file. [Seen in: aa000-main-start.]  
It reads the system record to obtain database connection details, loading them from *acas.param* if necessary, and then overrides file system settings before opening the RDB via **acas000**. [Seen in: aa000-main-start, aa010-Proc-Override.]  
The program writes a single default table record using **dfltMT**, handling duplicate key or other SQL errors, and finally closes the RDB and system file before exiting. [Seen in: aa010-Read, aa999-Finish.]

5.2 Initialization  
**zz020-Get-Program-Args** is performed to capture command line arguments, followed by a display of the program name via **Call-Sysout**. [Seen in: aa000-main-start.]  
System-File is opened and the first two records are read to populate *Default-Record* and system parameters; if any read fails, an error message is displayed and the program aborts. [Seen in: aa000-main-start.]  
Database connection parameters are loaded from the system record or from *acas.param*, and the file system flags are set to indicate RDB usage before calling **acas000-Open**. [Seen in: aa000-main-start, aa010-Proc-Override.]

5.3 Core Processing  
Path: System File Read & DB Load  
Trigger: Entry to **aa000-main-start**  
Key steps: open System-File, read record 2 into *Default-Record*, read record 1 for system parameters, load DB settings or call *acas-get-params*, set log and file system flags.  
I/O: System-File.  
Outcomes: *WS-RDB-Return* set, RDBMS fields populated, or program aborts on error.  
[Seen in: aa000-main-start.]

Path: RDB Open & Override  
Trigger: After DB settings loaded, go to **aa010-Proc-Override**  
Key steps: reset file system flags, set File-Key-No, call **acas000-Open** to initialize RDB connection.  
I/O: System-File, RDB via **acas000**.  
Outcomes: RDB connection established or error message and abort.  
[Seen in: aa010-Proc-Override, acas000-Open.]

Path: Record Write & Duplicate Handling  
Trigger: **aa010-Read**  
Key steps: increment input count, set File-System-Used, perform **acas000-Write**, check for duplicate key (SQL-State 23000 or fs-reply 22/99 or SQL-Err 1062/1022), on duplicate perform **acas000-ReWrite**, update rewrite count or error messages.  
I/O: RDB via **acas000**.  
Outcomes: record written or rewritten, counts updated, or error path to **aa999-Finish**.  
[Seen in: aa010-Read.]

Path: Error Check After Write  
Trigger: **aa100-Check-4-Errors**  
Key steps: if fs-reply not zero, display error details, go to **aa999-Finish**.  
I/O: none (display).  
Outcomes: error logged and program terminates early.  
[Seen in: aa100-Check-4-Errors.]

Path: Finish & Close  
Trigger: **aa999-Finish**  
Key steps: display record counts, set File-System-Used to RDB, close RDB via **acas000-Close**, close System-File, display EOJ message, goback.  
I/O: RDB via **acas000**, System-File.  
Outcomes: program exits with return-code 0 unless earlier error set.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program closes the RDB connection with **acas000-Close**, closes the system file, displays an end‑of‑job message, and returns control to the caller. [Seen in: aa999-Finish.]  
If any error was detected earlier, the return-code is set to a non‑zero value before goback, otherwise it remains zero. [Seen in: aa999-Finish.]

---
## dfltMT
*[54/267]*

### Business/Functional Perspective
### ACAS File Table Handler  

**Program Purpose**  
The program connects the ACAS accounting system to its underlying data store. It opens, closes, reads, writes, or updates a set of up to 32 configuration records stored in the database. By providing reliable access and error handling, it keeps the system’s configuration data accurate and available, supporting consistent reporting and auditability.  

**Screen Interactions**  
No direct screens. This program is called by other modules after a data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *Success*: Operations complete without error.  
- *No data*: If a read request finds no rows, the caller is informed that there is “No Data”.  
- *End of file*: When the end of a record set is reached, the caller receives an “EOF” indication.  
- *Duplicate key*: Attempts to insert a record that already exists result in a “Duplicate key” message.  
- *SQL error*: Any database error returns a descriptive message and an error code, allowing the caller to understand the problem.  

**User Flow Summary**  
A user (or calling module) initiates one of the file functions—open, close, read next, write, or rewrite.  
* Open: The program establishes a database connection.  
* Close: It safely terminates the connection.  
* Read next: It retrieves up to 32 configuration records in a single call, returning them in a structured record to the caller.  
* Write: It takes a batch of up to 32 records supplied by the caller and inserts them into the database.  
* Rewrite: It updates existing records with new values supplied by the caller.  
Throughout these steps the program monitors for errors such as missing data, duplicate keys, or database problems, reporting any issues back to the caller via standard status codes and messages.  

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry begins in **ba-ACAS-DAL-Process** where environment variables are accepted and screen exceptions are enabled. [Seen in: ba-ACAS-DAL-Process.]  
The routine performs initialization in **ba010-Initialise** and then evaluates the File-Function to dispatch to one of the process paragraphs (Open, Close, Read‑Next, Write, Rewrite, or Bad‑Function). [Seen in: ba010-Initialise, ba-ACAS-DAL-Process.]  
After the selected processing paragraph completes, control returns to **ba999‑exit** which performs any final logging and exits the program. [Seen in: ba999-exit.]

5.2 Initialization  
In **ba010‑Initialise**, all error and status fields are cleared and the MySQL error message area is zeroed. [Seen in: ba010-Initialise.]  
The program also sets up screen exception handling for COB_SCREEN_EXCEPTIONS, COB_SCREEN_ESC, and COB_SCREEN_PGUP/PAGEDOWN. [Seen in: ba010-Initialise.]  
The environment lines count is adjusted to a minimum of 24 for logging purposes. [Seen in: ba010-Initialise.]

5.3 Core Processing  
Path: Process‑Open  
Trigger: File‑Function = 1  
Key steps: Build MySQL connection parameters from linkage areas, perform **MYSQL‑1000‑OPEN**, set WS‑File‑Key to “OPEN DEFAULT”, set Most‑Cursor‑Set to zero, and exit.  
I/O: MySQL connection open.  
Outcomes: fs‑reply set on error, otherwise success; Most‑Cursor‑Set zero.  
[Seen in: ba020-Process-Open.]

Path: Process‑Close  
Trigger: File‑Function = 2  
Key steps: If a cursor is active, perform **ba998‑Free**; set ws‑No‑Paragraph to 2, set WS‑File‑Key to “CLOSE DEFAULT”, perform **MYSQL‑1980‑CLOSE**, and exit.  
I/O: MySQL connection close.  
Outcomes: cursor freed, status set.  
[Seen in: ba030-Process-Close.]

Path: Process‑Read‑Next  
Trigger: File‑Function = 3 or 4  
Key steps: If cursor not active, construct a WHERE clause for DEF‑REC‑KEY > “000”, perform **SELECT** via **MYSQL‑1210‑COMMAND**, store result, set cursor active; then fetch up to 32 rows, populate Default‑Record arrays, handle EOF and errors, and set Most‑Cursor‑Set accordingly.  
I/O: SELECT and FETCH from SYSDEFLT‑REC, MySQL result array.  
Outcomes: fs‑reply 0, WE‑Error 0, WS‑File‑Key set to last key or EOF, Most‑Cursor‑Set set to 1 or 0.  
[Seen in: ba040-Process-Read-Next.]

Path: Process‑Write  
Trigger: File‑Function = 5  
Key steps: Loop over 32 positions; for each non‑empty record, set fields and perform **bb200‑Insert** (INSERT into SYSDEFLT‑REC).  
I/O: INSERT into SYSDEFLT‑REC.  
Outcomes: fs‑reply 0, WE‑Error 0, WS‑File‑Key set to last key processed.  
[Seen in: ba070-Process-Write.]

Path: Process‑Rewrite  
Trigger: File‑Function = 7  
Key steps: Loop over 32 positions; for each non‑empty record, build a WHERE clause with the key, perform **bb300‑Update** (UPDATE SYSDEFLT‑REC).  
I/O: UPDATE on SYSDEFLT‑REC.  
Outcomes: fs‑reply 0, WE‑Error 0, WS‑File‑Key set to last key processed.  
[Seen in: ba090-Process-Rewrite.]

Path: Bad‑Function  
Trigger: File‑Function not 1,2,3,4,5,7  
Key steps: Set WE‑Error to 990, Fs‑Reply to 99, and exit.  
I/O: none.  
Outcomes: error status returned.  
[Seen in: ba100-Bad-Function.]

5.4 Termination  
The **ba999‑end** paragraph performs final logging if testing is enabled and then proceeds to **ba999‑exit**. [Seen in: ba999-end.]  
The **ba999‑exit** paragraph simply exits the program, returning control to the caller. [Seen in: ba999-exit.]

---
## dummy-rdbmsMT
*[55/267]*

### Business/Functional Perspective
### Dummy RDBMS Entry Points  

**Program Purpose**  
The program supplies placeholder database access routines for the ACAS accounting system when a real relational database is not used.  It allows the rest of the application to call standard data‑access entry points without requiring an RDBMS, simplifying configuration for file‑based environments.  By always returning a consistent status, it signals that no database operation was performed, ensuring downstream components can detect the dummy mode and adjust accordingly.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
The program reports a generic failure status for every call. It returns an overall error code indicating that the requested database action could not be executed because this module is a dummy placeholder. No specific error messages are shown to the user; the calling logic receives a standard failure response.  

**User Flow Summary**  
When a user initiates any accounting operation that normally requires database access (e.g., posting a GL batch or updating a sales invoice), the system calls the corresponding dummy routine. The routine immediately sets an error indicator and returns control to the caller. The user sees that the operation could not be completed in database mode and may be directed to use file‑based processing or check system configuration.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow
The program receives a call to one of its many entry points, each of which shares the same parameter list. [Seen in: ACAS-Dummy-call-Group Section.]  
Upon entry, the routine immediately assigns error status values and a return code of 64. [Seen in: ACAS-Dummy-call-Group Section.]  
The routine then exits via GOBACK, returning control to the caller. [Seen in: ACAS-Dummy-call-Group Section.]

5.2 Initialization
The program initializes the FS-Reply field to 99, WE-Error to 999, and RETURN-CODE to 64. [Seen in: ACAS-Dummy-call-Group Section.]  
No additional variables or files are initialized; the routine proceeds directly to termination. [Seen in: ACAS-Dummy-call-Group Section.]

5.3 Core Processing
Path: analMT  
Trigger: entry call to "analMT".  
Key steps: set FS-Reply, WE-Error, RETURN-CODE, GOBACK.  
I/O: none.  
Outcomes: error codes set, program exits.  
[Seen in: ACAS-Dummy-call-Group Section.]

Path: auditMT  
Trigger: entry call to "auditMT".  
Key steps: set FS-Reply, WE-Error, RETURN-CODE, GOBACK.  
I/O: none.  
Outcomes: error codes set, program exits.  
[Seen in: ACAS-Dummy-call-Group Section.]

Path: systemMT  
Trigger: entry call to "systemMT".  
Key steps: set FS-Reply, WE-Error, RETURN-CODE, GOBACK.  
I/O: none.  
Outcomes: error codes set, program exits.  
[Seen in: ACAS-Dummy-call-Group Section.]

Path: valueMT  
Trigger: entry call to "valueMT".  
Key steps: set FS-Reply, WE-Error, RETURN-CODE, GOBACK.  
I/O: none.  
Outcomes: error codes set, program exits.  
[Seen in: ACAS-Dummy-call-Group Section.]

5.4 Termination
The routine terminates by executing GOBACK, returning control to the caller with the pre-set error codes. [Seen in: ACAS-Dummy-call-Group Section.]  
No resources are released explicitly; the program relies on the caller to manage any cleanup. [Seen in: ACAS-Dummy-call-Group Section.]

---
## fhlogger
*[56/267]*

### Business/Functional Perspective
### Transaction File Logger  

**Program Purpose**  
The program records key information about each system transaction or error event to a plain‑text log file. By capturing dates, times, system identifiers, operation types, status codes, and descriptive messages, it provides an auditable trail that supports compliance, troubleshooting, and risk management. The log can be reviewed by administrators to detect problems and verify that processes are executing correctly.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If logging is disabled, the program terminates without generating a log entry.  
- If the log file cannot be opened or a write operation fails, the user is presented with an error notice and asked to press Return to continue.  
- The program does not otherwise display additional messages.  

**User Flow Summary**  
When a transaction or error occurs, the calling program supplies details such as the operation type, file identifier, key values, and any system or SQL error information. The logger creates a record that includes the current date and time, system code, and the supplied details, then appends this record to the log file. If the log file is unavailable, the user receives a clear notification and must acknowledge the error before the calling process can proceed.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the Ca-Process-Logs Section, performing initial checks on logging status and file state before proceeding to log record creation. If conditions dictate, it may close the log file or exit immediately; otherwise it opens or extends the log file as needed. Finally, it writes a formatted log record, handles any write errors, and exits via the ca999-Exit paragraph. [Seen in: Ca-Process-Logs Section.]

5.2 Initialization  
The program tests whether logging is disabled (File-Logging-Off) or whether a close request has been issued (File-Function and Access-Type zero) and closes the file if necessary. It then opens the log file in extend mode if it is currently closed, initializing the Log-File-Open-Flag and preparing the Log-Record structure with spacers and date/time stamps. [Seen in: Ca-Process-Logs Section.]

5.3 Core Processing  
Path: Close-Log-File-Request  
Trigger: File-Function = 0 and Access-Type = 0 and LFOF-Open is true.  
Key steps: set Log-File-Open-Flag to zero, close Log-File, go to ca999-Exit.  
I/O: Log-File.  
Outcomes: Log file closed, program exits.  
[Seen in: Ca-Process-Logs Section.]

Path: Logging-Off  
Trigger: File-Logging-Off is true.  
Key steps: go directly to ca999-Exit.  
I/O: none.  
Outcomes: program exits without logging.  
[Seen in: Ca-Process-Logs Section.]

Path: Open-Log-File  
Trigger: LFOF-Closed is true.  
Key steps: open Log-File in extend mode; if fx-Reply non‑zero, close and reopen in output mode; set Log-File-Open-Flag to 1.  
I/O: Log-File.  
Outcomes: Log file opened/extended and ready for writing.  
[Seen in: Ca-Process-Logs Section.]

Path: Create-Log-Record  
Trigger: normal flow after ensuring file is open.  
Key steps: initialize Log-Record, populate fields (date/time, system, file number, function, paragraph, access, key, where, errno, msg, SQL state), write Log-Record, increment Log-File-Rec-Written.  
I/O: Log-File.  
Outcomes: log entry written, record count incremented.  
[Seen in: Ca010-Create-Log-Rec.]

Path: Write-Error-Handling  
Trigger: FX-Reply not zero after write.  
Key steps: display error messages FH903 and FH901, accept user reply, close Log-File, reset Log-File-Open-Flag, go to ca999-Exit.  
I/O: Log-File, screen.  
Outcomes: error reported, log file closed, program exits.  
[Seen in: Ca010-Create-Log-Rec.]

5.4 Termination  
The ca999-Exit paragraph performs a clean exit of the program, ensuring any open log file is closed and the Log-File-Open-Flag is set appropriately. The program then returns control to the caller. [Seen in: ca999-Exit.]

---
## finalLD
*[57/267]*

### Business/Functional Perspective
### Final Table Load

**Program Purpose**  
The program transfers the final accounting record from the system file into the MySQL database. It pulls database connection details from the system file or, if missing, from a separate parameters file. By validating the data and handling duplicate keys, it guarantees that the final table is correctly populated and that any errors are reported to the operator. The result is a reliable, audit‑ready load of the last accounting snapshot.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **File access errors** – problems opening or reading the system file.  
- **Missing data** – the final record is empty, so nothing is loaded.  
- **Missing database parameters** – credentials not found in the system file or parameter file.  
- **Duplicate key or write failure** – record already exists or cannot be written, with an attempt to rewrite or update.  
- **Database commit/rollback issues** – failures when ending the transaction.  
- **General write errors** – any other SQL error encountered during the load.  
- **Status messages** – counts of records processed, rewritten, and log entries written.

**User Flow Summary**  
1. The operator starts the program (typically via a script).  
2. The program reads the system file record that holds database credentials.  
3. If the credentials are missing, the program attempts to load them from an external parameters file. If it still cannot obtain them, it aborts and notifies the operator.  
4. It checks the final record; if the record is empty, it informs the operator that there is nothing to load and exits.  
5. Otherwise, the program writes the record to the MySQL database. If the record already exists, it updates it; if any write error occurs, it reports the problem and stops the operation.  
6. After the write, the program reports the number of records processed, any rewrites, and the number of log entries written. It then commits the transaction, closes the database and the system file, and signals successful completion.

**Program Linkages**  
- acas-get-params  
- finalMT  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **aa000-main-start**, retrieves command line arguments, displays the program name, and initializes logging variables. [Seen in: aa000-main-start.]  
It opens the system file, reads the system parameters and final record, and validates that required data is present before proceeding. [Seen in: aa000-main-start.]  
After loading database configuration, it opens the RDB connection via **acas000**, writes the final record to the database, handles duplicate or other errors, commits or rolls back as needed, and then closes files before exiting. [Seen in: aa000-main-start, acas000-Open, aa010-Read, aa999-Finish.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to capture up to two command line arguments, sets up logging flags, and displays the program name. [Seen in: aa000-main-start.]  
It opens the system file, reads record 3 (final record) and record 1 (system parameters), and initializes working‑storage counters and flags before any database operations. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System File Read  
Trigger: Opening **System-File** and reading records 3 and 1.  
Key steps: open System-File, read record 3 into Final-Record, read record 1 into system parameters, check fs-reply for errors.  
I/O: System-File.  
Outcomes: sets Final-Record, system parameters, sets fs-reply; if errors, displays messages and exits.  
[Seen in: aa000-main-start.]

Path: DB Settings Load  
Trigger: RDBMS-DB-Name empty or FS-Cobol-Files-Used flag.  
Key steps: call **acas-get-params**, evaluate WS-RDB-Return codes, copy returned host, user, password, db-name, port, socket into RDBMS variables, or display errors and exit.  
I/O: acas-get-params.  
Outcomes: RDBMS variables populated; if failure, program exits with error code.  
[Seen in: aa000-main-start.]

Path: RDB Open  
Trigger: **acas000-Open** performed after setting File-Key-No and File-System-Used.  
Key steps: set fn-open and fn-i-o true, call acas000, check for errors via aa100-Check-4-Errors.  
I/O: acas000 (calls finalMT).  
Outcomes: RDB connection established; if errors, exit.  
[Seen in: acas000-Open.]

Path: Record Write  
Trigger: **aa010-Read** performing acas000-Write.  
Key steps: increment ws-Rec-Cnt-In, set File-System-Used, call acas000-Write, evaluate Sql-State and fs-reply for duplicate or other errors, handle duplicate by rewriting or incrementing rewrite count, otherwise increment ws-Rec-Cnt-Out.  
I/O: acas000 (finalMT write).  
Outcomes: record written or rewritten; counters updated; may trigger error path.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: Sql-State = "23000" or fs-reply 22 or 99 or SQL-Err 1062/1022.  
Key steps: clear FS-Reply and WE-Error, perform acas000-ReWrite, if FS-Reply non-zero display error, else increment ws-Rec-Cnt-R-Out, go to aa999-Finish.  
I/O: acas000 (finalMT rewrite).  
Outcomes: duplicate record rewritten or error reported; finish processing.  
[Seen in: aa010-Read.]

5.4 Termination  
In **aa999-Finish**, the program logs record counts, closes the RDB connection via acas000-Close, closes the system file, and displays an end‑of‑job message before returning. [Seen in: aa999-Finish.]  
The program exits with GOBACK after cleaning up all file handles and resetting file function and access type. [Seen in: aa999-Finish.]

---
## finalMT
*[58/267]*

### Business/Functional Perspective
### Final File Access  

**Program Purpose**  
The program provides the data‑access layer for the “final” record set used by the accounting system. It opens and closes the database connection, retrieves the next set of final records for display or processing, and writes or updates those records as required. By validating keys, preventing duplicates, and reporting errors, it helps maintain data integrity and supports audit trails for financial records.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – the requested operation completes without issue.  
- **End of data** – no more records are available for reading.  
- **Duplicate key** – an attempt to write a record that already exists.  
- **Invalid key or missing record** – the requested record cannot be found.  
- **Database error** – a general error from the database engine (e.g., connection failure, SQL syntax error).  
- **Unexpected error** – any other internal problem that stops the operation.  

**User Flow Summary**  
When the higher‑level application needs data, it calls this program with a specific file‑function code (open, close, read next, write, or rewrite).  
- For a **read** request, the program fetches up to 26 rows from the database and returns them as a single record, setting status codes to indicate whether the read was successful, reached the end of the data set, or failed to find the requested record.  
- For a **write** or **rewrite** request, it attempts to insert or update each field in the record; if a duplicate key is found, a duplicate‑key status is returned, and if the database reports any other error, that error is passed back.  
- The calling program then uses the returned status codes and, if a read succeeded, the returned record to present information to the user or to continue processing.  

**Program Linkages**  
- MySQL_errno  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in **ba-ACAS-DAL-Process**, initializing environment and evaluating the File‑Function to dispatch to one of the operation paragraphs. [Seen in: ba-ACAS-DAL-Process.]  
Depending on the File‑Function value, it performs one of the following: open (**ba020-Process-Open**), close (**ba030-Process-Close**), read next (**ba040-Process-Read-Next**), write (**ba070-Process-Write**), rewrite (**ba090-Process-Rewrite**) or an error path (**ba100-Bad-Function**). [Seen in: ba020-Process-Open, ba030-Process-Close, ba040-Process-Read-Next, ba070-Process-Write, ba090-Process-Rewrite, ba100-Bad-Function.]  
After completing the selected operation, control returns to **ba999-exit** where the program exits. [Seen in: ba999-exit.]

5.2 Initialization  
The program accepts linkage parameters, sets screen exception flags, and initializes key variables and error fields to spaces or zero. [Seen in: ba-ACAS-DAL-Process.]  
It then evaluates the File‑Function to determine the operation path, performing no further checks before dispatch. [Seen in: ba-ACAS-DAL-Process.]

5.3 Core Processing  
Path: Open  
Trigger: File‑Function = 1  
Key steps: build MySQL connection parameters, perform MYSQL‑1000‑OPEN, set WS‑File‑Key to “OPEN FINAL”, set Most‑Cursor‑Set to zero.  
I/O: MySQL connection establishment.  
Outcomes: fs‑reply set on error, otherwise zero; program proceeds to ba999‑end.  
[Seen in: ba020-Process-Open.]

Path: Read‑Next  
Trigger: File‑Function = 4  
Key steps: if cursor not active, build WHERE clause, perform SELECT, store result, set cursor active; loop to fetch up to 26 rows, populate AR1 array, set WS‑File‑Key per row, handle EOF or errors.  
I/O: SELECT and FETCH from SYSFINAL‑REC table.  
Outcomes: fs‑reply and WE‑Error set for EOF or errors; Most‑Cursor‑Set indicates active; final record populated.  
[Seen in: ba040-Process-Read-Next.]

Path: Write  
Trigger: File‑Function = 5  
Key steps: loop over AR1 array, for each non‑blank record set key and AR1, perform bb200‑Insert (INSERT into SYSFINAL‑REC), handle duplicate key or other errors.  
I/O: INSERT into SYSFINAL‑REC.  
Outcomes: fs‑reply set to 22 for duplicate, 99 for other errors; WE‑Error updated; final record unchanged.  
[Seen in: ba070-Process-Write.]

Path: Rewrite  
Trigger: File‑Function = 7  
Key steps: loop over AR1 array, for each non‑blank record build WHERE clause using key, perform bb300‑Update (UPDATE SYSFINAL‑REC), handle errors.  
I/O: UPDATE on SYSFINAL‑REC.  
Outcomes: fs‑reply set to 99 on error, WE‑Error set to 994 on update failure; final record unchanged.  
[Seen in: ba090-Process-Rewrite.]

Path: Close  
Trigger: File‑Function = 2  
Key steps: if cursor active, perform ba998‑Free; perform MYSQL‑1980‑CLOSE; set WS‑File‑Key to “CLOSE FINAL”.  
I/O: close MySQL connection.  
Outcomes: fs‑reply zero; program proceeds to ba999‑end.  
[Seen in: ba030-Process-Close.]

Path: Bad‑Function  
Trigger: File‑Function other than 1‑5, 7  
Key steps: set WE‑Error to 990, Fs‑Reply to 99.  
I/O: none.  
Outcomes: error status set.  
[Seen in: ba100-Bad-Function.]

5.4 Termination  
If the testing flag is set, logs are written via Ca‑Process‑Logs before exiting. [Seen in: ba999-end.]  
The program exits by returning from the procedure division via ba999‑exit. [Seen in: ba999-exit.]

---
## general
*[59/267]*

### Business/Functional Perspective
### General Ledger Menu  

**Program Purpose**  
The program provides a central menu for managing the General Ledger within the accounting system. It allows users to set dates, view and edit chart of accounts, maintain default account information, run posting and cycle‑processing functions, and generate various financial reports. By coordinating these activities, the program ensures that accounting entries are recorded correctly, that the ledger remains balanced, and that the system configuration stays up to date, thereby supporting accurate reporting, compliance, and risk reduction.  

**Screen Interactions**  
1. **Main Menu Screen** – Displays a header with the program name, current date and time, and a list of options (A–M, X, and optionally Z). The user selects an option by entering the corresponding letter.  
   * Options include:  
     * A – Date Entry  
     * B – Chart Of Accounts  
     * C – Default Account Maintenance  
     * D – Final Accounts Set‑Up  
     * E – Enter Transactions  
     * F – Proof/Modify Transactions  
     * G – Batch Status Report  
     * H – Transaction Posting  
     * I – End Of Cycle Processing  
     * J – Print Trial Balance  
     * K – Print P&L and Balance Sheet  
     * L – Print Ledgers  
     * M – Print Final Accounts  
     * X – Exit to operating system  
     * Z – System Set Up (displayed only if not restricted)  

No other direct user‑visible screens are defined in this program.  

**Messages and Errors**  
* If the terminal size is less than 24 rows or 80 columns, a message is shown and the program stops.  
* If environment variables for the system are not set up, an abort message is displayed.  
* If no backup script is found in the specified directory, a notice is shown.  
* If a required archive file is missing, the message *“No Archive File found, Aborted”* appears.  
* Attempting to access the restricted “Z” option when not permitted results in a “Not permitted” notice.  
* General error messages such as *“Environment variables not yet set up: ABORTING”* or *“Error on systemMT processing”* inform the user of issues that prevent normal operation.  

**User Flow Summary**  
1. The user starts the program. It first validates terminal dimensions and environment variables.  
2. The menu screen is shown with the current date, time, and a list of operations.  
3. The user types a letter to choose an action.  
4. The program calls the corresponding sub‑program (e.g., *gl020* for date entry, *gl120* for posting transactions).  
5. After the sub‑program finishes, the system parameters are updated and written back to persistent storage.  
6. Control returns to the main menu, allowing the user to perform additional tasks or exit.  
7. On exit, any pending backup operation is triggered if configured, and the program terminates.  

**Program Linkages**  
- maps04  
- sys002  
- gl000  
- gl030  
- gl020  
- gl040  
- gl050  
- gl051  
- gl060  
- gl070  
- gl071  
- gl072  
- gl080  
- gl090  
- gl100  
- gl105  
- gl120  
- gl130  
- gl190  
- SYSTEM  
- CBL_CHECK_FILE_EXIST

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry begins at the **General-Control  Section.**, where screen exceptions are set, program arguments are parsed, and terminal size is validated before opening the system parameter file. [Seen in: General-Control  Section.]  
After system records are loaded, the main menu is displayed and user input is accepted; each letter is mapped to a load routine via the **load-it.** paragraph, with special handling for exit (X) and system setup (Z). [Seen in: display-menu, accept-loop, load-it.]  
Each load routine calls the appropriate GL module, then returns to the menu or performs system setup or exit, concluding with a GOBACK. [Seen in: load00, call-system-setup, pre-overrewrite.]

5.2 Initialization  
Startup checks include setting environment variables for screen exceptions, reading command‑line arguments via **zz020-Get-Program-Args.**, and validating terminal dimensions. [Seen in: General-Control  Section.]  
The system parameter file is opened, system records are read into working storage, and the existence of the backup script is verified before the menu loop begins. [Seen in: Open-System, aa010-Get-System-Recs, pre-overrewrite.]

5.3 Core Processing  
Path: Auto‑run Trigger (Date Entry)  
Trigger: menu‑reply = "A" selected by the user.  
Key steps: go to **load01.**, set ws‑called to "gl000", invoke **load00.** which calls the gl000 module with system‑record, default‑record, and to‑day.  
I/O: Calls gl000 module via ws‑called; reads system‑record and default‑record from the system file.  
Outcomes: ws‑term‑code may be set; if >7 the flow jumps to **overrewrite.**, otherwise control returns to the menu. [Seen in: load01, load00.]

Path: General Menu Dispatch  
Trigger: any letter other than X, Z, or A after accept-loop search.  
Key steps: search letters‑upper to find z, then go to **load‑it.**, which dispatches to the appropriate load routine based on z.  
I/O: Calls the corresponding gl module via ws‑called; reads system‑record, default‑record, and to‑day.  
Outcomes: module may set ws‑term‑code; if >7 the flow jumps to **overrewrite.**, otherwise returns to the menu. [Seen in: accept-loop, load‑it, load00.]

Path: System Setup  
Trigger: menu‑reply = "Z" when Param‑Restrict ≠ "Y".  
Key steps: go to **call-system-setup.**, which opens the system file, rewrites system, default, and totals records, calls sys002, then returns to **Open-System.**  
I/O: System file and sys002 module.  
Outcomes: system parameters are updated and control returns to the menu. [Seen in: accept-loop, call-system-setup.]

Path: End‑of‑Cycle Processing  
Trigger: menu‑reply = "I" selected by the user.  
Key steps: go to **load09.**, which calls **load00.** with ws‑called set to "gl090".  
I/O: Calls gl090 module via ws‑called; reads system‑record and default‑record.  
Outcomes: module may set ws‑term‑code; if >7 the flow jumps to **overrewrite.**, otherwise returns to the menu. [Seen in: load09, load00.]

Path: Exit  
Trigger: menu‑reply = "X" selected by the user.  
Key steps: go to **pre-overrewrite.**, which verifies the backup script, constructs the full backup command, calls SYSTEM with the script, then performs GOBACK.  
I/O: Backup script file and SYSTEM call.  
Outcomes: program terminates. [Seen in: pre-overwrite.]

5.4 Termination  
The program exits by executing the **pre-overrewrite.** paragraph, which runs the backup script and then performs a GOBACK. [Seen in: pre-overwrite.]  
If a module sets ws‑term‑code > 7 during a load, the program jumps to **overrewrite.** to persist system changes before terminating. [Seen in: load00, overrewrite.]

---
## gl000
*[60/267]*

### Business/Functional Perspective
### General Ledger Start Of Day  

**Program Purpose**  
The program prepares the accounting system for a new business day by recording the current date and time. It displays a screen that prompts the user to enter the operating date in the format chosen for the environment (UK, US, or international). After validating the date, the program returns the selected date and time to the calling context so that all ledger entries for the day use a consistent, accurate date. This step reduces data entry errors and supports audit‑ready reporting.  

**Screen Interactions**  
1. **General Ledger Start Of Day Screen**  
   * Title and header: “Client –”, user name, program name “GL000 (3.02.06)”, and “General Ledger Start Of Day”.  
   * Current time displayed after the user enters it.  
   * Prompt for date entry:  
     * “Enter todays date as dd/mm/yyyy – [          ]” (UK)  
     * “Enter todays date as mm/dd/yyyy – [          ]” (US)  
     * “Enter todays date as yyyy/mm/dd – [          ]” (International)  
   * Date input field positioned at the prompt.  
   * An error message line below the prompt for invalid dates.  

**Messages and Errors**  
* If the entered date is not valid, the program shows an “Invalid Date” message and asks the user to re‑enter the date.  

**User Flow Summary**  
The user launches the program and is greeted with a screen showing the current time and a prompt to enter the day’s date in the system’s configured format. After typing the date, the program checks that it follows the expected pattern and falls within a valid range. If the date is invalid, an error message appears and the user is prompted to try again. Once a valid date is accepted, the screen clears the error, and the program ends, passing the confirmed date and time back to the next step of the overall workflow.  

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by initializing screen exceptions and moving the supplied to-day value into the internal date variable. [Seen in: main.]  
It then displays header information, accepts the current system date and time, and prompts the user to enter today's date in the format selected by the Date-Form setting. [Seen in: main.]  
After validating the entered date, the program calls the external maps04 routine, then transfers control to the chain-menu paragraph before exiting. [Seen in: main.]

5.2 Initialization  
The main paragraph sets environment variables for screen exceptions and captures the supplied to-day value into the internal date field. [Seen in: main.]  
It displays client, user, program name, and other header information, and accepts the current system date and time. [Seen in: main.]  
The program then displays the date prompt based on the configured date format and accepts user input for the date. [Seen in: main.]

5.3 Core Processing  
Path: Date Entry  
Trigger: User input of date at prompt.  
Key steps: Accept date, display prompt, convert to standard UK form, set u-bin to zero, call maps04.  
I/O: None.  
Outcomes: u-bin may be zero indicating error, or non-zero indicating success.  
[Seen in: date-entry, main.]

Path: Validation Error  
Trigger: u-bin = zero after maps04 call.  
Key steps: Display GL009 error, go back to date-entry.  
I/O: None.  
Outcomes: Loop back to date entry for re‑entry.  
[Seen in: main.]

Path: maps04 Call  
Trigger: After date entry and u-bin set to zero.  
Key steps: Call maps04 using maps03-ws, check u-bin.  
I/O: None.  
Outcomes: u-bin set by maps04.  
[Seen in: main.]

Path: chain-menu  
Trigger: u-bin non‑zero after maps04.  
Key steps: Move u-bin to run-date, u-date to to-day, zero ws-term-code.  
I/O: None.  
Outcomes: Sets run-date, to-day, and term-code for subsequent processing.  
[Seen in: chain-menu.]

5.4 Termination  
The program reaches the main-exit paragraph, which performs a GOBACK to return control to the caller. [Seen in: main-exit.]  
No explicit file or resource cleanup is performed beyond the GOBACK. [Seen in: main-exit.]

---
## gl020
*[61/267]*

### Business/Functional Perspective
### Default Accounts Maintenance  

**Program Purpose**  
The program lets a user define, change, or view the default accounting entries that a client uses for routine transactions. It ensures that each default account number is valid, associates the correct description and VAT status, and records the default amounts used in day‑to‑day postings. By keeping these defaults consistent, the program supports accurate financial reporting, reduces manual entry errors, and simplifies audit preparation.  

**Screen Interactions**  
1. **Main Menu** – Title “Default File Utilities” and options:  
   - 1 Set‑Up Default Accounts  
   - 2 Amend Default Accounts  
   - 3 Display The Defaults  
   - 9 Return To System Menu  
   User enters a single‑digit choice.  

2. **Set‑Up Screen** – Displays a two‑column grid of account numbers with headings “A/C Nos” and “Code Vat.” For each row the user can enter:  
   - The account number (or the default amount, if the field is empty).  
   - The account code.  
   - The VAT code (I, N, O, or optional Y/N).  
   A prompt allows the user to add additional rows or finish by pressing ESC.  

3. **Amend Screen** – Prompts for the number of the row to edit. After selecting a row, the user can modify the amount, code, and VAT fields using the same layout as the set‑up screen.  

4. **Display Screen** – Shows the complete list of default accounts with their amounts, codes, and VAT codes. A final line reads “End of listing. Hit return for Menu.” The user presses Enter to return to the main menu.  

**Messages and Errors**  
- **Missing Chart of Accounts** – If the system cannot access the ledger file, the screen shows “Chart of Accounts not set up” and prompts the user to press Return.  
- **Invalid Input** – If a user enters an account number that is not in the ledger, a code that is not recognized, or a VAT entry that is not one of the accepted letters, the program will refuse to accept the entry and repeat the prompt.  
- **Operation Cancelled** – Pressing the ESC key during any entry screen returns the user to the previous screen or exits the current operation.  
- **Successful Completion** – After a set‑up or amend operation finishes, the screen displays the updated defaults and a message indicating that the changes have been saved.  

**User Flow Summary**  
A user starts at the main menu and chooses whether to set up new defaults, amend existing ones, or simply view the current list. In the set‑up path, the user can choose to overwrite the current defaults or append to them. For each account, the user enters an amount, selects a code from the ledger, and specifies the VAT treatment; the program validates each entry against the ledger and the allowed VAT codes. In the amend path, the user selects the row to change and updates the same fields. When finished, the user receives confirmation that the defaults have been written, or is prompted to review the list. The display option simply lists all defaults for review before returning to the main menu.  

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in the **init01** section, sets screen exception flags, displays program name, date, and user information, and opens the ledger file for input. [Seen in: init01-Main.]  
The user selects a function (set‑up, amend, show, or exit) which triggers the corresponding section. [Seen in: init01-Main.]  
Each function section performs its specific operations and then returns to the main menu loop or exits. [Seen in: set-up, amend, show.]

5.2 Initialization  
The **init01** section sets environment flags, displays header information, and opens the ledger file for input. [Seen in: init01-Main.]  
If the ledger file fails to open, an error message is displayed and the program exits. [Seen in: init01-Main.]

5.3 Core Processing  

Path: Set‑Up  
Trigger: `menu-reply = 1`  
Key steps: display set‑up header, ask whether to add to existing defaults, initialize defaults if “N”, display input headings, loop over account numbers to accept amount, code, and VAT, read ledger descriptions, and write updated defaults to the ledger file.  
I/O: `GL-Nominal-Open-Input`, `GL-Nominal-Close` (implicit write), ledger file.  
Outcomes: defaults are created or updated; control returns to the main menu.  
[Seen in: set-up, main-loop, get-input, get-description, file-init.]

Path: Amend  
Trigger: `menu-reply = 2`  
Key steps: display amendment header, prompt for account number to alter, accept new amount, code, and VAT, read description, and update the ledger record.  
I/O: `GL-Nominal-Read-Indexed`, `GL-Nominal-Close` (implicit write), ledger file.  
Outcomes: selected default record is updated; control returns to the main menu.  
[Seen in: amend, get-input, get-description.]

Path: Show  
Trigger: `menu-reply = 3`  
Key steps: display show header, display input headings, list all existing defaults, wait for return, and close the ledger file.  
I/O: `GL-Nominal-Close`, ledger file.  
Outcomes: defaults are displayed to the user; control returns to the main menu.  
[Seen in: show, input-headings, display-existing, main-exit.]

5.4 Termination  
On exit, the program performs `GL-Nominal-Close` to close the ledger file and then exits with `GOBACK`. [Seen in: main01-exit.]  
The final status is determined by the exit of the procedure division. [Seen in: main01-exit.]

---
## gl030
*[62/267]*

### Business/Functional Perspective
### Chart of Accounts Maintenance  

**Program Purpose**  
The program lets a finance or accounting user maintain the Chart of Accounts (CoA).  It allows new accounts to be created, existing accounts to be amended or deleted, and accounts to be organised by profit centre, branch or ledger.  Users can view the accounts in a list or as a report, and the program can import or export the CoA to a text file.  By validating inputs and preventing actions that would leave accounts in an inconsistent state, it supports accurate financial reporting and compliance.  

**Screen Interactions**  
1. **Main Menu** – Title: *Chart Of Account Utilities*  
   *Inputs*: User selects option 1‑9 by number or function key.  
   *Outputs*: Displays menu text, prompts for next action.  
2. **Set‑up / Amend Profit Centres or Branches** – Title: *Set‑Up for Profit Centres* or *Set‑Up for Branches*  
   *Inputs*: Establishment code, a list of codes that can be selected (Y to select, Q to finish).  
   *Outputs*: Confirmation of selected codes.  
3. **Chart of Accounts Set‑Up** – Title: *Chart of Accounts Set‑Up*  
   *Inputs*: Ledger number, sub‑number, profit‑centre/branch code (if applicable), account name, account type, placement, level.  
   *Outputs*: Validation messages if any entry is invalid, success confirmation when the record is stored.  
4. **Chart of Accounts Amend** – Title: *Chart Of Accounts Amend*  
   *Inputs*: Same fields as the set‑up screen.  Function keys F8 (Move), F9 (Copy/Replace) and ESC (Quit) are available.  A line starting with “+” deletes an account.  
   *Outputs*: Validation messages, confirmation of changes or deletions.  
5. **Alphabetic Listing** – Title: *Chart Of Accounts Alphabetic Print*  
   *Inputs*: None (display only).  
   *Outputs*: Alphabetically sorted list of accounts with level, type, placement and name.  
6. **Display or Print Chart of Accounts** – Title: *Chart Of Accounts Display* or *Print Out*  
   *Inputs*: Start account number and optional profit‑centre/branch code; navigation keys N (next), I (ignore same code), C (continue), Q (quit).  
   *Outputs*: Current account record, and prompts for navigation.  
7. **Profit Centres / Branch Report** – Title: *Profit Centres Report*  
   *Inputs*: None (display only).  
   *Outputs*: List of profit centres or branch codes with names.  
8. **Import/Export CoA** – Title: *Import / Export CoA File*  
   *Inputs*: Choice to export (1) or import (2); file name.  
   *Outputs*: Confirmation of file creation or replacement, record count, and any file‑access errors.  

**Messages and Errors**  
- **Missing or invalid establishment code** – “A code for Establishment must be input.”  
- **Ledger code too low** – “Error! Ledger Code must be not less than 1000.”  
- **Ledger file missing or unreadable** – “Ledger File Does Not Exist” or “No Ledger File to update.”  
- **Rewrite or delete errors** – “Rewrite Error‑01. Hit return to finish” or “Deletion Request Denied! Current Balance Not Zero.”  
- **Account already exists** – “Requested account already exists.”  
- **Account has postings** – “Account has postings – Request rejected.”  
- **Invalid code format** – “Invalid! Code must be numeric or <n*>.”  
- **Record not found** – “Does not exist!”  
- **General system issues** – “Terminal program not set to length => 24” and “Note message & Hit return.”  

**User Flow Summary**  
A user starts the program and is presented with the main menu, which lists options such as setting up new profit centres, adding accounts, amending or deleting accounts, viewing lists, printing reports, and importing or exporting the chart.  
If the user chooses to set up profit centres or branches, the program prompts for an establishment code and then displays a selectable list of codes.  After confirmation, the program records the setup.  
For adding a new account, the user enters the ledger number, sub‑number, (optionally) a profit‑centre/branch code, the account name, type, placement, and level.  The program validates each field, reports any errors, and writes the record to the ledger.  
Amending an existing account follows a similar screen but offers function‑key actions: F9 copies the existing account to a new number, F8 moves it, and ESC quits.  The user can delete an account by starting the name with “+”.  Validation ensures that accounts with a balance or postings cannot be deleted.  
The alphabetic listing or profit‑centre report displays the accounts in sorted order without requiring further input.  
For a detailed view, the user enters a starting account (and optional code) and can navigate through the list using the on‑screen prompts.  The print option outputs the same information to a spool file.  
Importing or exporting allows the user to create a text copy of the entire chart or to replace the current chart from a text file.  The program confirms file names, checks file accessibility, and reports the number of records processed.  

**Program Linkages**  
- maps04  
- SYSTEM (used to launch the print‑report routine)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in **init01 section** where environment variables are set and the main menu is displayed. [Seen in: init01 section.]  
User input is accepted in **Menu-Input** and the selected option or function key determines which processing section is performed. [Seen in: Menu-Input]  
After a section completes, control returns to **Menu-Input** until the user selects exit, at which point the program performs a **goback**. [Seen in: menu-exit]

5.2 Initialization  
The **init01 section** sets screen exception flags, accepts terminal line count, validates it, and displays the program title and date. [Seen in: init01 section.]  
It also performs a date conversion routine (**zz070-Convert-Date**) and displays the user name and menu options. [Seen in: init01 section.]

5.3 Core Processing  

Path: **gl030a** (Set up Branches or Profit Centres)  
Trigger: ws-menu = 1 or F1 key.  
Key steps: Open ledger file for input, read the first record to populate the establishment/branch codes, display prompts for establishment code, accept codes, and write new ledger entries for each selected code.  
I/O: Reads and writes **GL-Nominal** ledger file.  
Outcomes: Ledger file updated with new establishment/branch records; control returns to menu.  
[Seen in: gl030a section.]

Path: **gl030b** (Add New Accounts)  
Trigger: ws-menu = 2 or F2 key.  
Key steps: Open ledger file, prompt for ledger number, sub, optional PC code, name, type, placement, level; validate and write or rewrite ledger records; handle multi‑add logic for PC codes.  
I/O: Reads and writes **GL-Nominal** ledger file.  
Outcomes: New account records created or updated; ledger file closed and control returns to menu.  
[Seen in: gl030b section.]

Path: **gl030c** (Amend/Delete Existing Accounts)  
Trigger: ws-menu = 3 or F3 key.  
Key steps: Open ledger file, prompt for ledger number and sub, accept new name, type, placement, level; support copy (F9), move (F8), delete (leading “+”); perform ledger read, rewrite, or delete operations; enforce balance zero on delete.  
I/O: Reads, rewrites, and deletes **GL-Nominal** ledger file.  
Outcomes: Existing account records amended or removed; ledger file closed and control returns to menu.  
[Seen in: gl030c section.]

Path: **gl030e** (Alphabetic Listing)  
Trigger: ws-menu = 4 or F4 key.  
Key steps: Load ledger table into memory (**zz100-Load-Ledger-Table**), open ledger file for input, sort table by name, iterate through table, read each ledger record, format and write to print file.  
I/O: Reads **GL-Nominal** ledger file; writes to **print-file**.  
Outcomes: Alphabetically sorted report generated and printed; ledger file closed.  
[Seen in: gl030e section.]

Path: **gl030f** (Display or Print Chart of Accounts)  
Trigger: ws-menu = 5, 6 or F5/F6 key.  
Key steps: Open ledger file for input, prompt for start account and optional PC/branch, read sequentially, display or write each record to screen or print file, handle paging and user navigation (N, I, C, Q).  
I/O: Reads **GL-Nominal** ledger file; writes to **print-file** when printing.  
Outcomes: Chart of accounts displayed or printed; ledger file closed.  
[Seen in: gl030f section.]

Path: **gl030g** (Profit Centres Report)  
Trigger: ws-menu = 7 or F7 key.  
Key steps: Open ledger file for input, load establishment/branch codes, iterate through codes, read each ledger record, write formatted report lines to print file.  
I/O: Reads **GL-Nominal** ledger file; writes to **print-file**.  
Outcomes: Profit centre report generated and printed; ledger file closed.  
[Seen in: gl030g section.]

Path: **gl030h** (Import/Export Chart of Accounts)  
Trigger: ws-menu = 8 or F8 key.  
Key steps: Prompt user to choose import or export; for export, open output text file, read all ledger records and write them to the text file; for import, open input text file, read each record, write to ledger file, resetting amounts to zero.  
I/O: Reads/writes **GL-Nominal** ledger file and **Saved-CoA** text file.  
Outcomes: Chart of accounts exported to or imported from a text file; files closed.  
[Seen in: gl030h section.]

5.4 Termination  
When the user selects exit (ws-menu = 9 or Esc), the program performs a **goback** to return to the system menu. [Seen in: menu-exit]  
All open files are closed and the program terminates. [Seen in: menu-exit]

---
## gl050
*[63/267]*

### Business/Functional Perspective
### General Ledger Posting

**Program Purpose**  
This program lets a user create and enter general‑ledger posting batches. It validates dates, account numbers and VAT information, assigns posting conventions, and records each transaction for audit and financial reporting. The batch creation ensures that postings are grouped, dated, and signed off correctly, which supports compliance, reduces risk of duplicate or invalid entries, and simplifies downstream accounting processes.

**Screen Interactions**  
1. **Main Menu** – Title: *Transaction Entry Functions*  
   - Displays the current date.  
   - Prompts: *Select one of the following by number* with options **(1) Set up New Batch** and **(9) Exit to System Menu**.  
   - Input: one‑digit menu choice.  

2. **Default Accounts Setup** – Title: *General Ledger – Posting Set‑Up*  
   - Shows current defaults for posting number, convention (CR/DR), profit centre/branch (if configured), and posting date.  
   - Prompts for a default number, convention, profit centre/branch, and posting date.  
   - Offers options: **0 – Return to System Menu**, **33 – Set‑up Temporary Default**, **99 – Display current Defaults**.  
   - Input: single integer for the default number.  

3. **Temporary Default Setup** – (Appears when option 33 is chosen)  
   - Prompts for account number, VAT setting, and posting code.  
   - Input: account number, VAT indicator (*I*, *O*, *N*), and two‑character code.  

4. **Posting Entry Screen** – Title: *General Ledger – Posting Input*  
   - Displays batch number, default posting account, contra account, convention, posting date, account, optional profit centre/branch, amount, VAT code, VAT amount, and narrative.  
   - Input sequence: date → account → profit centre/branch → amount → VAT code → VAT amount (if applicable) → narrative.  
   - At any point the user may exit the batch with **Esc** or choose options shown in the help outline (B, E, F, Q, n).  

5. **VAT Rate Prompt** – (If the default VAT is Input or Output)  
   - Prompts *VAT Rate* and confirms with a yes/no.  
   - Input: numeric rate selection.  

6. **Help Outline** – Displays quick‑reference keys: **B – Back‑up one field**, **E – End**, **F – Force Write**, **Q – Quit Batch**, **n – Back‑up n records**.

**Messages and Errors**  
- **Invalid Date** – The program notifies the user when the entered date is not recognised or is out of range.  
- **Invalid Account Number** – If the account entered does not exist in the ledger, a clear message is shown and the user is prompted to re‑enter.  
- **Invalid VAT Code** – When an unsupported VAT indicator is entered, the user is asked to re‑enter.  
- **Missing Defaults** – If profit centre or branch defaults are required but not set, the user is prompted to configure them first.  
- **Cycle Errors** – The program will refuse a posting cycle earlier than the current system cycle and will warn if the cycle is more than one year ahead.  
- **No Items Entered** – When a batch is finished without any posting items, a notification indicates that no entries were added.  
- **Esc or Exit** – Choosing **Esc** or selecting option **9** ends the batch or returns to the main system menu.

**User Flow Summary**  
When the program starts, the user is presented with a menu offering to create a new batch or exit. Selecting **1** launches the Default Accounts Setup screen where the user confirms or changes the posting defaults, chooses a convention, and sets the posting date. After confirming defaults, the user proceeds to the Posting Entry screen. Here the user enters a series of transactions: for each one they provide a date, account, optional profit centre/branch, amount, optional VAT details, and a narrative description. The program validates each field, shows helpful prompts, and allows the user to navigate back or forward through entries. Once all desired items are entered, the user can choose to write the batch, force a write, or quit the batch. The program writes each transaction to the posting file and returns the user to the main menu or closes the program.

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at the **init01 section**, performing environment setup, opening batch and posting files, and preparing the system record. [Seen in: init01 section.]  
The user is presented with a menu in the **menu-input paragraph**, selecting either to set up a new batch (ws-menu = 1) or exit (ws-menu = 9). [Seen in: menu-input.]  
Selecting batch setup triggers the **gl050a** and **gl050b** sections to configure defaults and collect posting data, after which control returns to the menu. [Seen in: gl050a section, gl050b section.]

5.2 Initialization  
The **init01 section** sets screen exception flags, initializes the posting array, opens batch and posting files, and prepares the system record. [Seen in: init01 section.]  
It then displays the program name and date, and calls **zz070-Convert-Date** to format the current date. [Seen in: init01 section.]

5.3 Core Processing  

Path: Batch Setup  
Trigger: ws-menu = 1 in **menu-input**  
Key steps: **get-next-batch** (sets ledger and batch numbers), **get-default** (calls **gl050a** to read defaults), **gl050b** (displays posting prompts), **write-next-batch** (writes batch record).  
I/O: batch file (GL-Batch-Open, GL-Batch-Write), ledger file (GL-Nominal-Read-Indexed), posting file (GL-Posting-Open-Input/Output).  
Outcomes: new batch record created, defaults stored, posting data collected.  
[Seen in: get-next-batch, get-default, gl050a, gl050b, write-next-batch.]

Path: Posting Input  
Trigger: after batch setup or when **gl050b** is called directly.  
Key steps: display prompts, **accept-account**, **accept-amount**, **accept-vat**, **accept-narative**, compute VAT amounts, **write-loop** to write postings.  
I/O: posting file (GL-Posting-Write), ledger file (GL-Nominal-Read-Indexed).  
Outcomes: posting records written, posting array populated.  
[Seen in: gl050b section, accept-account, accept-amount, accept-vat, accept-narative, write-loop.]

Path: Write-Out  
Trigger: when a > 12 or main-exit after posting input.  
Key steps: **open-posting**, **write-loop** for each posting, **close-posting**, update save-a.  
I/O: posting file.  
Outcomes: postings persisted, a reset.  
[Seen in: write-out section, write-loop.]

Path: Quit-Batch  
Trigger: escape code “Q” or end batch.  
Key steps: **open-posting**, read postings for batch, delete each posting, **close-posting**, set z to 9.  
I/O: posting file.  
Outcomes: batch postings removed.  
[Seen in: quit-batch section.]

Path: Get-Batch  
Trigger: user selects get-batch (not used in menu but available).  
Key steps: **GL-Batch-Open**, prompt for batch number, **GL-Batch-Read-Indexed**, handle invalid key.  
I/O: batch file.  
Outcomes: batch record loaded or error.  
[Seen in: get-batch paragraph.]

Path: Validate-Date  
Trigger: date input in various accept routines.  
Key steps: replace delimiters, convert to UK format, call **maps03** to validate, set u-bin.  
I/O: none.  
Outcomes: u-bin indicates validity.  
[Seen in: zz050-Validate-Date section.]

5.4 Termination  
The **menu-ex** paragraph closes the batch file and performs GOBACK to return to the system menu. [Seen in: menu-ex.]  
The **program-exit** section exits the program after all cleanup. [Seen in: program-exit.]

---
## gl051
*[64/267]*

### Business/Functional Perspective
### Batch Amendment & Reporting

**Program Purpose**  
The program lets users update and verify batch transaction records and produce proof reports for the General Ledger.  It validates dates, account numbers, and VAT details, ensures that postings match the batch header, and rewrites the amended records in the posting file.  By providing an interactive editing environment, it supports compliance and audit readiness while reducing the risk of incorrect postings.  The main benefit is that users can correct batch information and confirm its integrity before final settlement.

**Screen Interactions**  
1. **Main Menu** – Title: *“General Ledger – Batch Amendment”*; prompts “Select one of the following by number – (1) Amend existing Batch (2) Print Proof Reports – All Batches (3) Print Proof Reports – One Batch (4) Print all Transactions (9) Exit to system menu”.  User enters a single‑digit choice.  
2. **Batch Number Entry** – Title: *“Enter Batch Number”*; input field for a 5‑digit batch number.  
3. **Batch Header Amendment Prompt** – Title: *“Amend Batch Header? (Y/N)”*; user confirms whether to edit the header.  
4. **Batch Outline Screen** – Title: *“Batch Data”*; displays and allows editing of Batch, Cycle, Items, Gross Value, VAT Value, and Description.  
5. **Batch Details Amendment Prompt** – Title: *“Amend Batch Details? (Y/N)”*; confirms whether to change the detailed fields shown in the outline screen.  
6. **Posting Amendment Screen** – Title: *“Postings – Edit”*; shows fields for Date, Account, (Profit Centre / Branch if enabled), Amount, VAT Code (P/M/blank), VAT Amount, and Narrative. The user edits each posting record sequentially.

**Messages and Errors**  
- *Invalid date format* – when the entered date cannot be parsed or is outside the allowed range.  
- *Date too early* – the posting date is earlier than the batch cycle.  
- *Date too far* – the posting date is later than the current system cycle.  
- *No items specified* – the batch contains zero items; a prompt appears to correct this.  
- *Invalid VAT code* – entered VAT code is not P (percentage) or M (margin).  
- *Invalid account number* – the account number entered does not exist in the ledger.  
- *General prompt cancellations* – pressing escape or quitting aborts the current edit and returns to the previous menu or exits the program.

**User Flow Summary**  
When launched, the user sees the main menu and selects an option. For *Amend existing Batch*, the user enters the batch number. If the batch exists, the program asks whether the header should be edited. If yes, the user modifies header fields such as cycle, items, gross value, VAT value, and description. A follow‑up prompt lets the user decide whether to amend the detailed batch data. The program then presents a screen for each posting in the batch. The user can change the date, account, profit centre/branch, amount, VAT code, VAT amount, and narrative. The program validates each field, showing error messages if necessary, and rewrites the posting record after editing. After all postings are processed, the program returns to the main menu.  

For *Print Proof Reports*, the user may choose to print all batches or a single batch. The program reads the requested batches, calculates totals, and outputs a formatted report that shows each posting line, batch totals, and a verification status line indicating whether the batch matches the recorded totals. The user reviews the printed proof to confirm correctness before final processing.

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **gl051-Main**, displays the menu and accepts the user’s choice. [Seen in: gl051-Main.]  
Depending on the menu selection it performs batch amendment (**gl050c**), proof report for all batches (**proof-all**), proof report for one batch (**gl050d**), or prints all transactions (**gl050d** with flags). [Seen in: gl051-Main.]  
After each operation the batch record is rewritten and closed, then control returns to the menu until the user exits. [Seen in: gl051-Main.]

5.2 Initialization  
The program sets screen exception flags, moves the print‑spool name, converts the current date, and initializes display variables before showing the menu. [Seen in: Menu-Input.]  
It opens the batch file for I/O before processing menu selections. [Seen in: Menu-Input.]

5.3 Core Processing  

Path: **Batch Amendment**  
Trigger: User selects menu option 1.  
Key steps: `get-batch` reads the selected batch; `batch-amendment` confirms header change; `define-vat-rate` obtains VAT rate; posting file is opened; the program loops reading posting records, accepting date, account, profit centre, amount, VAT, and narrative, then rewrites each posting record.  
I/O: batch file, posting file, ledger file.  
Outcomes: posting records are updated, batch status may be set, and files are rewritten.  
[Seen in: gl050c, get-batch, batch-amendment, define-vat-rate, GL-Posting-Open, loop, GL-Posting-Rewrite.]

Path: **Proof Report – All Batches**  
Trigger: User selects menu option 2.  
Key steps: `proof-all` loops reading the next batch record; if the batch is waiting, `gl050d` prints the proof report; the batch record is rewritten.  
I/O: batch file, posting file, ledger file, print file.  
Outcomes: a proof report is printed for each batch and batch status is updated.  
[Seen in: proof-all, gl050d, GL-Batch-Read-Next, GL-Batch-Rewrite.]

Path: **Proof Report – One Batch**  
Trigger: User selects menu option 3.  
Key steps: `get-batch` reads the selected batch; `gl050d` prints the proof report for that batch; the batch record is rewritten.  
I/O: batch file, posting file, ledger file, print file.  
Outcomes: proof report printed for the selected batch.  
[Seen in: gl050d, get-batch, GL-Batch-Read-Indexed.]

Path: **Print All Transactions**  
Trigger: User selects menu option 4.  
Key steps: set `save-batch` to zero, `batch-start` to 1, `z` to 99, then perform `gl050d` to print all transactions.  
I/O: posting file, ledger file, print file.  
Outcomes: all transactions are printed.  
[Seen in: gl050d, Menu-Input.]

Path: **Exit**  
Trigger: User selects menu option 9.  
Key steps: go to `menu-exit` and perform `GOBACK`.  
I/O: none.  
Outcomes: program terminates.  
[Seen in: menu-exit.]

5.4 Termination  
After each operation the batch file is rewritten and closed, posting and nominal files are closed, and the program returns to the menu or exits. [Seen in: Menu-Input, main-exit.]  
On exit, the program performs `GOBACK` to return control to the caller. [Seen in: menu-exit.]

---
## gl060
*[65/267]*

### Business/Functional Perspective
### Batch Status Report  

**Program Purpose**  
The program provides a concise status overview of financial batches that have been processed during a selected accounting cycle.  It allows the user to view, page through, or print a detailed report that lists each batch’s ledger type, status, last activity date, and summary amounts.  The report supports auditors, controllers and managers in confirming that batches were correctly completed, waiting, archived, or still open, thereby ensuring compliance and reducing risk of mis‑posted transactions.  

**Screen Interactions**  

1. **Main Menu** – “Select one of the following by number”  
   * Inputs: a single numeric key (1, 2, or 9)  
   * Options displayed:  
     - (1) **Display Batch Report** – show the report on screen, page by page.  
     - (2) **Print Batch Report** – send the report to the print spooler.  
     - (9) **Exit to system menu** – return to the overarching system menu.  

2. **Batch Report Screen** – shows header information followed by a list of batches.  
   * Header lines display cycle, date, and column titles for ledger, batch number, status, last activity, header items, gross, VAT, actual items, gross, and VAT.  
   * Each batch entry shows the ledger type (G/L, P/L, or S/L), batch number, status (Open, Waiting, Processed, Archived), the date of the last activity, and the header and actual financial figures.  
   * Navigation prompt: “Enter <N> for next screen or <X> to exit” –  
     - **N** – loads the next page of the report.  
     - **X** – ends the report display and returns to the main menu.  

3. **End Screen** – after a print job or when the user finishes viewing.  
   * If printing, the program sends the report to the print system.  
   * If viewing, the screen shows “Type return to exit.” and waits for the user to press Return before returning to the main menu.  

**Messages and Errors**  

- If the user enters an invalid key at any prompt, the program simply re‑prompts for input without crashing.  
- If no batch records are found for the selected cycle, the report screen will show only the header lines and the navigation prompt, indicating that there are no entries to display.  
- When the user chooses to print, the program attempts to write the report to the spooler; if this fails, the program ends with a generic “Error writing to print spool” message (the exact wording is handled internally).  
- Selecting “Exit to system menu” terminates the program cleanly and returns control to the parent system.  

**User Flow Summary**  
The user starts the batch status report program and immediately sees a menu offering three options: display the report, print the report, or exit.  Selecting **Display** opens a scrollable screen that lists each batch in the current accounting cycle, showing its ledger type, status, activity date, and summary amounts.  The user can view additional pages by pressing **N** and can stop viewing at any time by pressing **X**.  Choosing **Print** triggers the program to send the same report to the printer; once printing completes, the user is returned to the system menu.  Choosing **Exit** skips the report entirely and returns the user to the broader system interface.  

**Program Linkages**  

- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in the procedure division and immediately enters the init01 section, which sets up the environment and displays the main menu. [Seen in: init01 section.]  
The user selects an option; choosing 1 or 2 triggers the gl060a section to generate a batch status report either on screen or to a print file. [Seen in: menu-input2.]  
The gl060a section opens the batch file, reads records in a loop, formats and displays or prints them, and then returns to the main menu or exits. [Seen in: gl060a section.]

5.2 Initialization  
init01 sets environment variables, converts the current date, and initializes line counters and screen dimensions. [Seen in: init01 section.]  
It then displays the program title, date, and the selection menu before accepting the user's choice. [Seen in: menu-input2.]

5.3 Core Processing  
Path: Menu Selection  
Trigger: User enters 1 or 2 at the menu prompt. [Seen in: menu-input2.]  
Key steps: perform gl060a. [Seen in: menu-input2.]  
I/O: none. [Seen in: menu-input2.]  
Outcomes: sets variable a and initiates report generation. [Seen in: menu-input2.]

Path: Batch Report Display (a=1)  
Trigger: a = 1 after menu selection. [Seen in: gl060a section.]  
Key steps: open batch file, loop reading records, format lines, display on screen, prompt for next screen or exit. [Seen in: gl060a section, loop, screen-option.]  
I/O: batch-file read (GL-Batch-Read-Next). [Seen in: loop.]  
Outcomes: report displayed on screen; user can continue or exit. [Seen in: screen-option.]

Path: Batch Report Print (a=2)  
Trigger: a = 2 after menu selection. [Seen in: gl060a section.]  
Key steps: open print file, write headings, loop reading batch records, write print-records, close print file, call SYSTEM to print. [Seen in: gl060a section, headings, detail-print, end-report.]  
I/O: batch-file read, print-file write. [Seen in: loop, detail-print.]  
Outcomes: report printed to spool. [Seen in: end-report.]

Path: End Report / Exit  
Trigger: fs-reply = 10 (end of batch file) or ws-reply = "X". [Seen in: loop, screen-option.]  
Key steps: close batch file, close print file if open, display exit message or invoke print command, then goback. [Seen in: end-report, GL-Batch-Close.]  
I/O: close files. [Seen in: end-report.]  
Outcomes: program terminates. [Seen in: end-report.]

Path: Date Conversion (zz060-Convert-Date)  
Trigger: called when processing stored, posted, proofed, entered dates. [Seen in: next-1.]  
Key steps: call maps03, convert binary date to ws-date. [Seen in: zz060-Convert-Date section.]  
I/O: none. [Seen in: zz060-Convert-Date section.]  
Outcomes: ws-date set for display. [Seen in: zz060-Convert-Date section.]

5.4 Termination  
end-report closes any open print file, optionally calls the SYSTEM print command, then closes the batch file. [Seen in: end-report.]  
The program then performs GL-Batch-Close and returns to the caller with GOBACK. [Seen in: end-report.]

---
## gl070
*[66/267]*

### Business/Functional Perspective
### Transaction Posting

**Program Purpose**  
The program records and finalises the accounting for a day’s financial activity. It validates the status of each batch of transactions, generates a pre‑transaction file for posting, and produces a summary report that can be reviewed by the user. The report confirms that batches are ready for posting and that no errors will occur, supporting accurate ledgers and compliance. By ensuring all data is written safely, the program helps the finance team maintain reliable audit trails.

**Screen Interactions**  
1. **Title Screen** – Displays the program name, “Transaction Posting,” and the current date.  
2. **Phase Message Screen** – Shows the current phase: “Phase – 1. Batch Check” followed by “Phase – 2. Transaction Pre‑process.”  
3. **Batch Status Report Screen** – Presents a header, then a list of batches with ledger type, batch number, status, dates, item counts, gross amounts, and VAT. The user is prompted at the bottom to press **N** for the next screen or **X** to exit. When finished, a final prompt asks the user to press return to close the report.

**Messages and Errors**  
- **Successful Operation** – The batch status report is displayed; after reviewing, the program writes the pre‑transaction file and exits.  
- **User Exit** – Selecting **X** or completing the last page ends the report and the program.  
- **No Data** – If the batch file contains no records, the program terminates silently without error messages.  
- **Processing Errors** – The program does not display explicit error messages for missing data; it stops processing if a required batch record cannot be read.

**User Flow Summary**  
The user starts the program and sees the title and date. The system performs a batch check and immediately shows the batch status report. The user can review the report page by page, pressing **N** to see more or **X** to finish. Once the report is complete, the program automatically processes the transaction pre‑process phase, creating a pre‑transaction file for posting, and then exits. The user returns to the main accounting environment with the new pre‑transaction data available for posting.

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the procedure division, performing initial environment setup in the **init01** section. It then displays the transaction posting header and current date in the **menu-input** paragraph. The main processing is divided into a batch‑check phase (**gl071a**) followed by a transaction pre‑process phase (**gl071b**). [Seen in: init01.]

5.2 Initialization  
The **init01** section accepts terminal line count, sets screen exception flags, converts the current date, and initializes the file key. The **menu-input** paragraph displays the program name, title, and date on the screen. The **menu-input2** paragraph initializes the phase counter, displays the first phase banner, and invokes the batch‑check routine. [Seen in: init01.]

5.3 Core Processing  
Path: Batch Check  
Trigger: Invoked from **menu-input2** after Phase‑1 banner.  
Key steps: Open the batch input file, read each record, compare cycle numbers, set status flag **a** if a batch is open, and loop until end of file.  
I/O: batch file (GL‑Batch‑Open‑Input, GL‑Batch‑Read‑Next).  
Outcomes: Sets variable **a** to indicate an open batch, which may trigger the status report. [Seen in: gl071a.]

Path: Batch Status Report  
Trigger: Executed when **a = 1** after the batch check.  
Key steps: Re‑open the batch file, loop through records, format and display status lines, handle paging, and wait for user input to continue or exit.  
I/O: batch file (GL‑Batch‑Open‑Input, GL‑Batch‑Read‑Next).  
Outcomes: Produces a screen‑based report of batch status and may terminate the program. [Seen in: gl060a.]

Path: Transaction Pre‑process  
Trigger: After Phase‑2 banner in **menu-input2**.  
Key steps: Open the pre‑transaction output file, open the batch file, loop through open batches, call **gl071b‑pre‑process** for each batch, and close the posting file.  
I/O: pre‑transaction file (output), batch file (input), posting file (input).  
Outcomes: Writes pre‑transaction records to the output file for each posting line. [Seen in: gl071b.]

Path: Posting Pre‑process  
Trigger: Called within the **gl071b** loop for each batch.  
Key steps: Open the posting file, read each posting record, write corresponding pre‑transaction records for debit and credit sides, handle VAT adjustments, and loop until end of posting file.  
I/O: posting file (input), pre‑transaction file (output).  
Outcomes: Generates detailed pre‑transaction entries for all postings in the batch. [Seen in: gl071b-pre-process.]

Path: Date Conversion (Binary)  
Trigger: Invoked by **zz060‑Convert‑Date** when a binary date needs formatting.  
Key steps: Call **maps03** to set date format, convert binary date to UK/USA/Intl string, and store in **ws‑date**.  
I/O: none.  
Outcomes: Sets **ws‑date** to a formatted date string. [Seen in: zz060-Convert-Date.]

Path: Date Conversion (String)  
Trigger: Invoked by **zz070‑Convert‑Date** when the current day string needs formatting.  
Key steps: Convert the **to‑day** string to UK/USA/Intl format, swapping month/day if necessary, and store in **ws‑date**.  
I/O: none.  
Outcomes: Sets **ws‑date** to a formatted date string. [Seen in: zz070-Convert-Date.]

Path: Date Mapping  
Trigger: Called by **zz060‑Convert‑Date** to determine date format.  
Key steps: Call external **maps04** routine via **maps03**.  
I/O: none.  
Outcomes: Prepares date conversion parameters. [Seen in: maps03.]

5.4 Termination  
The **main-exit** paragraph in each section performs a **GOBACK** to terminate the program, ensuring all files are closed. The program exits cleanly after completing the requested phase or after user‑initiated termination. [Seen in: main-exit.]

---
## gl071
*[67/267]*

### Business/Functional Perspective
### Batch Transaction Sort  

**Program Purpose**  
The program organizes raw accounting transaction data into a sorted file that can be used by downstream batch processes. It reads unsorted transaction records, orders them by batch number, account number, period code and posting number, and writes the sorted records to an output file. The sorted file supports faster reporting, reconciliation, and ensures data integrity across the accounting system.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- The user sees a brief progress message: “Sorting…Please wait.”  
- If the program encounters a file‑access or sorting error, it stops execution without displaying a specific error message.  
- Successful completion leaves the sorted transaction file ready for the next stage of the batch workflow.  

**User Flow Summary**  
When the batch job is started, the program immediately displays a short status line indicating that sorting is underway. It then reads the unsorted transaction file, sorts the records in ascending order based on batch, account, period code, and posting number, and writes the sorted data to the output file. No further user interaction is required; the program completes and returns control to the batch system, where the sorted file is used by subsequent reports or reconciliations.  

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at the main paragraph, displaying a status message. [Seen in: main.]  
It then initiates a sort operation on the pre-trans file, ordering by batch, account, posting code, and post number. [Seen in: main.]  
After sorting, control transfers to the main-exit paragraph which terminates the program. [Seen in: main-exit.]

5.2 Initialization  
The program displays a "Sorting…Please wait" message to indicate processing has begun. [Seen in: main.]  
No additional variable initialization or file opening logic is present; the sort statement implicitly opens the input and output files. [Seen in: main.]

5.3 Core Processing  
Path: Sort-Transaction  
Trigger: Execution of the SORT statement in the main paragraph.  
Key steps: The SORT statement reads records from pre-trans, orders them by sort-batch, sort-ac, sort-pc, sort-post, and writes the sorted records to post-trans.  
I/O: pre-trans, post-trans, sort-trans.  
Outcomes: Sorted data is written to post-trans; status of fs-reply may indicate file operation success. [Seen in: main.]

5.4 Termination  
The main-exit paragraph executes a GOBACK to return control to the caller. [Seen in: main-exit.]  
No explicit cleanup of files or resources is performed; the runtime environment handles closure. [Seen in: main-exit.]

---
## gl072
*[68/267]*

### Business/Functional Perspective
### Batch Transaction Posting  

**Program Purpose**  
The program processes a sequential file of posting transactions, updates the corresponding ledger balances, and generates a detailed report of all postings for the batch. It ensures that account balances are current, provides a complete audit trail of debits and credits, and flags any issues that arise while reading or updating ledger or batch records. The result is a printable summary that can be reviewed for compliance and financial accuracy.  

**Screen Interactions**  
No direct user screens are presented. The program runs in batch mode, displaying a brief status line ("Phase - 4. Transaction Update") and then writes a formatted transaction posting report to the print spool.  

**Messages and Errors**  
- A status line appears on the screen to indicate the program is running.  
- If the program encounters an error while reading a batch or ledger record, it stops processing that batch, writes the account summary that has been built so far, and then continues with the next batch or ends the run.  
- Upon successful completion, the printed report contains a complete listing of all transactions, balance changes, and a final account summary.  

**User Flow Summary**  
The user initiates the batch job (typically via a scheduler or manual start). The program reads each posting transaction, updates the ledger balance, and writes a line for each transaction to a print report. After all records are processed, the program writes account totals and closes the files. The user then reviews the generated report, which shows each transaction, the resulting balance, and a summary for each account. No input is required during execution; the program runs to completion and delivers the report automatically.  

**Program Linkages**  
- SYSTEM   (called to print the final report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry performs environment setup, opens batch and ledger files, and opens the posting and print files before entering the main processing loop. [Seen in: gl072-Main section.]  
The main loop reads each transaction record, detects changes in batch or ledger numbers, and triggers end‑of‑account or end‑of‑batch actions, writing formatted output lines and maintaining totals. [Seen in: loop.]  
Upon reaching the end of the posting file, the program finalizes the last account and batch, closes all files, rewrites batch and ledger records, prints the report, and exits. [Seen in: end-run.]

5.2 Initialization  
The program initializes spool name, file key number, and displays a phase message, then performs GL‑Batch‑Open and GL‑Nominal‑Open to open the batch and ledger files. [Seen in: gl072-Main section.]  
It opens the sequential input file post‑trans and the output print‑file, and sets save‑batch and save‑ledger to zero before entering the processing loop. [Seen in: gl072-Main section.]  
The program also moves the program name to the header line and sets up initial display parameters. [Seen in: gl072-Main section.]

5.3 Core Processing  
Path: Main Loop  
Trigger: Read of post‑trans record (not end)  
Key steps: Check numeric batch, handle batch change, handle ledger change, update totals, write print line, page overflow check.  
I/O: post‑trans (input), print‑file (output)  
Outcomes: updates totals, writes lines, may trigger end‑account or new‑account, sets save‑batch/ledger, updates line‑cnt.  
[Seen in: loop.]  

Path: End‑Account  
Trigger: Ledger change or page overflow (line‑cnt > Page‑Lines)  
Key steps: Perform GL‑Nominal‑Rewrite, write summary line, write separators, reset totals.  
I/O: ledger file (rewrite), print‑file (output)  
Outcomes: ledger record rewritten, totals reset, print output updated.  
[Seen in: end-account.]  

Path: End‑Batch  
Trigger: Batch change  
Key steps: Perform GL‑Batch‑Rewrite, set cleared‑status, set posted date.  
I/O: batch file (rewrite)  
Outcomes: batch record rewritten, status updated.  
[Seen in: end-batch.]  

Path: New‑Account  
Trigger: Ledger change  
Key steps: Set WS‑Ledger‑Key, read next ledger record if not read‑ledger R, reset totals, write brought‑forward line, set read‑ledger to space.  
I/O: ledger file (read), print‑file (output)  
Outcomes: ledger record read, totals reset, print output updated.  
[Seen in: new-account.]  

Path: Headings  
Trigger: Start of batch or page (save‑batch zero or line‑cnt > Page‑Lines)  
Key steps: Get batch info, convert date, write header lines, set line‑cnt.  
I/O: batch file (read), print‑file (output)  
Outcomes: header printed, line‑cnt set.  
[Seen in: headings.]  

Path: End‑Run  
Trigger: End of post‑trans file  
Key steps: Close files, perform GL‑Batch‑Close, GL‑Nominal‑Close, call SYSTEM Print‑Report, goback.  
I/O: post‑trans, print‑file, batch file, ledger file  
Outcomes: files closed, report printed, program exited.  
[Seen in: end-run.]

5.4 Termination  
The program closes the posting and print files, rewrites any remaining batch and ledger records, and invokes the system print routine before returning control. [Seen in: end-run.]  
It then performs a GOBACK to terminate execution. [Seen in: main-exit.]

---
## gl080
*[69/267]*

### Business/Functional Perspective
### End Cycle Archiving

**Program Purpose**  
The program finalises an accounting period by checking for un‑posted batches, clearing processed data, and either archiving transaction records to a specified location or deleting them if archiving is disabled. It also updates ledger balances for the new period, ensuring that all financial data is accurate and consistent before the next cycle starts. The operation is performed only after a system backup has been confirmed, protecting the integrity of the accounting records and supporting audit and compliance requirements.

**Screen Interactions**  
The program presents a single screen that shows:  
1. **Header** – “End Of Cycle Processing”, the current date, and the user‑specified batch number.  
2. **Instructional messages** – prompts reminding the user to confirm a backup has been taken, that the archive device (e.g., USB stick) is present, and that the user can abort by pressing Escape or “A”.  
3. **Phase indicators** – as processing proceeds, lines such as “Phase – 1. Batch Check”, “Phase – 2. Transaction Archiving”, “Phase – 3. Transaction Deletion”, “Phase – 4. Posting Contraction”, and “Phase – 5. End of Period Processing” are displayed.  
4. **Input fields** – a single‑character prompt at column 1065 where the user can press any key to continue, Escape or “A” to abort, and later a prompt at column 1369 for the user to confirm the archive path or enter “9” to cancel the run.  
No additional screens, buttons, or menus are presented.

**Messages and Errors**  
- **Missing backup or archive device** – the program stops and displays a reminder that a backup must be performed and that the USB memory stick must be available.  
- **Un‑posted or un‑proofed batches detected** – the user is informed that such batches exist and the run is halted until the issue is resolved.  
- **File write problems** – if a posting record cannot be written to the work file, the program reports the failure, displays the error code, and stops.  
- **Record size mismatch** – if the posting record size does not match the expected size, the program notifies the user and aborts until the data is corrected.  
- **Abort requests** – pressing Escape, “A”, or entering “9” at any prompt causes the program to terminate immediately.

**User Flow Summary**  
1. The user starts the program and sees the header and date.  
2. The program asks for confirmation that a backup has been taken and that the archive device is attached.  
3. The user can press any key to continue or abort.  
4. The program scans for any batches that are still un‑posted or un‑proofed; if any are found, it displays a warning and stops.  
5. If archiving is enabled, the program asks for the archive file path (defaulting to a pre‑set location). The user can confirm or abort.  
6. The program processes each batch: it writes transaction records to the archive file, deletes the posting records, and marks the batch as cleared.  
7. If archiving is disabled, the program deletes the posting records instead.  
8. The program compresses the posting file to maintain a compact state.  
9. Ledger balances are updated for the new period, and the cycle/period counters are incremented.  
10. Upon completion, the program exits, leaving the accounting system ready for the next period.

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program starts at **gl080-Main**, sets screen exception handling, displays the program name and title, converts the current date to the system format, and displays it. [Seen in: gl080-Main.]  
It then performs a batch check (**gl080a**); if unprocessed batches exist it aborts, otherwise it proceeds to either archive (**gl080b**) or delete (**gl080c**) transactions based on the archiving flag. [Seen in: gl080-Main.]  
After transaction handling, it compresses postings (**compress-post**), updates ledger balances for the period, and exits. [Seen in: gl080-Main.]

5.2 Initialization  
The program sets screen exception handling, displays program name and title, converts the current date to the system format, and displays it. [Seen in: gl080-Main.]  
It then prompts the user to confirm that a backup has been performed, aborting if the user cancels. [Seen in: gl080-Main.]

5.3 Core Processing  
Path: Batch Check  
Trigger: performed by **gl080a** in main.  
Key steps: open batch input file, read each record, check cycle and status, set flag *a* if unprocessed batches found.  
I/O: batch file (GL-Batch-Open-Input, GL-Batch-Read-Next, GL-Batch-Close).  
Outcomes: flag *a* set to 1 if unprocessed batches, causing abort; otherwise continue.  
[Seen in: gl080a.]

Path: Archiving  
Trigger: performed by **gl080b** in main when archiving flag true.  
Key steps: display phase, call disk-change to set archive path, open archive file, open batch file, loop through batches, for each batch call arc-process to write archive records, close posting file, rewrite batch record with cleared status, close archive and batch files.  
I/O: archive file, batch file, posting file (GL-Batch-Open, GL-Posting-Open, GL-Posting-Close, GL-Batch-Rewrite, etc).  
Outcomes: batches archived, status cleared, *a* may be set to 9 if disk change aborted.  
[Seen in: gl080b.]

Path: Deletion  
Trigger: performed by **gl080c** in main when archiving flag false.  
Key steps: display phase, open batch file, loop through batches, call del-process to delete posting records, close posting file, rewrite batch record with cleared status.  
I/O: batch file, posting file (GL-Batch-Open, GL-Posting-Open, GL-Posting-Delete, GL-Batch-Rewrite).  
Outcomes: batches deleted, status cleared.  
[Seen in: gl080c.]

Path: Posting Contraction  
Trigger: performed by **compress-post** after archiving/deletion.  
Key steps: if Cobol files used, compare posting record length with work file record, copy posting file to work file, then copy back to posting file, deleting records as needed.  
I/O: posting file, work file.  
Outcomes: posting file compressed, errors handled.  
[Seen in: compress-post.]

Path: End of Period Processing  
Trigger: after compress-post, if *scycle* equals period boundary.  
Key steps: increment *scycle*, open ledger file, loop reading ledger records, rewrite balances for current quarter, close ledger file, adjust current quarter and period counters.  
I/O: ledger file (GL-Nominal-Open, GL-Nominal-Read-Next, GL-Nominal-Rewrite, GL-Nominal-Close).  
Outcomes: ledger balances updated, counters advanced.  
[Seen in: GL-Nominal-Open.]

5.4 Termination  
The program exits via GOBACK from **gl080-Main**, closing any open files and returning control to the caller. [Seen in: gl080-Main.]  
If the program aborted due to unprocessed batches or backup not confirmed, it displays appropriate messages and exits. [Seen in: gl080-Main.]

---
## gl090
*[70/267]*

### Business/Functional Perspective
### Trial Balance Menu

**Program Purpose**  
The program presents a concise menu that lets users generate a trial balance report for the current accounting period. Users can choose a detailed view or a profit‑centre/branch view, ensuring quick access to essential financial summaries. By generating accurate trial balances, the program supports compliance, audit readiness, and overall financial control. It acts as the gateway to the detailed reporting functions housed in separate modules.

**Screen Interactions**  
1. **Trial Balance Menu Screen** – Displayed at program start.  
   * Title “Trial Balance” at the top.  
   * Current date shown in the chosen regional format.  
   * User identifier displayed near the top of the screen.  
   * Prompt “Select Option By Number :- [ ]” with an input field.  
   * Options:  
     - (1) Detailed Trial Balance  
     - (2) Profit Centre Trial Balance or Branch Trial Balance (depending on configuration)  
     - (9) Exit to system menu  

**Messages and Errors**  
- If the user selects an option, the chosen report is generated and presented; otherwise the menu re‑appears.  
- Selecting “9” terminates the menu and returns to the main system menu.  
- If the required ledger data is missing, the called reporting program will terminate and return control to this menu (no specific error text is shown here).

**User Flow Summary**  
The user opens the Trial Balance menu and is presented with the date, their user ID, and two reporting options plus an exit choice. After selecting option 1 or 2, the program hands control to the corresponding report‑generation routine, which produces the requested trial balance. Once the report is displayed, control returns to the menu, allowing the user to generate another report or exit to the system menu by pressing 9. The entire interaction is driven by the menu display and user key‑in; no additional screens or prompts appear beyond the main menu and the resulting report.

**Program Linkages**  
- gl090b  
- gl090a

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by displaying the menu header and converting the current date to the appropriate format. [Seen in: menu-input.]  
It then presents the user with a list of trial‑balance options and accepts a numeric reply. [Seen in: menu-input.]  
Based on the reply, it either calls a subprogram to generate a detailed or profit‑centre trial balance, loops back for another selection, or exits to the system menu. [Seen in: menu-input.]

5.2 Initialization  
The program displays its name and the title “Trial Balance” on the screen, setting the foreground color for each line. [Seen in: menu-input.]  
It performs a date conversion routine to format the current date for display before showing it to the user. [Seen in: zz070-Convert-Date.]

5.3 Core Processing  
Path: Detailed Trial Balance  
Trigger: menu‑reply = 1  
Key steps: call subprogram gl090b with the current calling data, system record, to‑day, and file definitions.  
I/O: gl090b (subprogram) – no files or tables are referenced in this file.  
Outcomes: control returns to menu-input for another selection.  
[Seen in: menu-input.]

Path: Profit/Branch Trial Balance  
Trigger: menu‑reply = 2  
Key steps: call subprogram gl090a with the current calling data, system record, to‑day, and file definitions.  
I/O: gl090a (subprogram) – no files or tables are referenced in this file.  
Outcomes: control returns to menu-input for another selection.  
[Seen in: menu-input.]

Path: Exit to System Menu  
Trigger: menu‑reply = 9  
Key steps: proceed to main‑exit paragraph.  
I/O: none.  
Outcomes: program terminates with a GOBACK.  
[Seen in: menu-input.]

Path: Date Conversion  
Trigger: performed during initialization before menu display.  
Key steps: move to‑day to ws‑date, adjust format based on Date‑Form, swap month/day for USA format, or reformat to International format.  
I/O: none.  
Outcomes: ws‑date contains the formatted date for display.  
[Seen in: zz070-Convert-Date.]

5.4 Termination  
The program ends by executing the main‑exit paragraph, which performs a GOBACK to return control to the caller. [Seen in: main-exit.]

---
## gl090a
*[71/267]*

### Business/Functional Perspective
### Structured Trial Balance  

**Program Purpose**  
The program creates a structured trial‑balance report that aggregates account balances by level. It reads a ledger file, sums debits and credits for each account, and prints a concise, page‑formatted report that shows totals for each hierarchy level and the overall total. The report supports audit trails and compliance by providing a clear snapshot of the organisation’s financial positions.  

**Screen Interactions**  
1. **Startup screen** – Displays the program name, “Structured Trial Balance” title, and the current date.  
2. **Error screen** – If the ledger file cannot be opened, it shows the message “Ledger File Does Not Exist” and prompts the user to “Hit Return to Quit.”  

**Messages and Errors**  
- *Ledger file missing* – The program halts and asks the user to press Return to exit.  
- *Normal completion* – A formatted trial‑balance report is sent to the printer; no on‑screen message is shown.  

**User Flow Summary**  
The user starts the program (typically from a command line or CICS trigger). The program attempts to open the specified ledger file. If successful, it reads each ledger record, accumulates balances for each account and each level of the account hierarchy, and writes a structured report to the print spool. The report lists accounts, debit and credit amounts by level, and totals for the entire ledger. After printing, the program ends. If the ledger file cannot be found, the user receives an error message and can press Return to quit.  

**Program Linkages**  
- SYSTEM  

---

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program opens the ledger input file, converts the current date, and initializes the print spool before entering the main ledger‑reading loop. [Seen in: gl090a-Main section.]  
During the loop it reads each ledger record, accumulates balances, prints detail lines and level totals, and handles page breaks until the end of the file is reached. [Seen in: Read-Ledger.]  
After processing all records it writes final totals, closes the print and ledger files, and exits the program. [Seen in: end-run.]

5.2 Initialization  
The program performs a nominal‑file open and checks for errors, displaying a message and aborting if the file cannot be opened. [Seen in: gl090a-Main section.]  
It sets up the print spool name, displays the program header, converts the current date to the required format, and initializes all ledger‑level accumulators and counters. [Seen in: gl090a-Main section., zz070-Convert-Date.]

5.3 Core Processing  
Path: Ledger Read Loop  
Trigger: Each successful read of a ledger record.  
Key steps: Read next record, test for end‑of‑file or error, handle level changes, accumulate balances, print detail or totals as required, update page and line counters.  
I/O: ledger file (input), print file (output).  
Outcomes: ledger‑level totals updated, page count incremented, line count reset on new page.  
[Seen in: Read-Ledger.]

Path: Detail Print Path  
Trigger: When a ledger level change requires printing the current detail line.  
Key steps: Format account number, write the detail line to the print file, update line counter and trigger heading if page full.  
I/O: print file.  
Outcomes: one detail line printed, line counter advanced, possible heading printed.  
[Seen in: detail-print.]

Path: Total Print Path (total4-print, total3-print, total2-print, total1-print)  
Trigger: When a higher‑level total must be printed (on level change or end‑of‑file).  
Key steps: Compute account number, format totals for the current level, write the total line, propagate balances to the next higher level, reset current level accumulators.  
I/O: print file.  
Outcomes: total line printed for the level, higher‑level accumulators updated, current level reset.  
[Seen in: total4-print., total3-print., total2-print., total1-print.]

Path: Accumulate Path  
Trigger: After a ledger balance is processed.  
Key steps: Add or subtract the ledger balance to the appropriate debit or credit accumulator for the current level.  
I/O: none.  
Outcomes: l-dr or l-cr for the current level updated.  
[Seen in: accumulate.]

Path: End‑of‑Run  
Trigger: After the ledger file read loop exits.  
Key steps: Write final totals to the print file, close the print and ledger files, invoke the system print routine, and return to the caller.  
I/O: print file, ledger file.  
Outcomes: all files closed, program exits cleanly.  
[Seen in: end-run.]

5.4 Termination  
The program writes the grand totals, closes the print and ledger files, calls the system print routine, and performs a GOBACK to terminate. [Seen in: end-run.]  
It then returns control to the caller via the main‑exit paragraph. [Seen in: main-exit.]

---
## gl090b
*[72/267]*

### Business/Functional Perspective
### Detailed Trial Balance Report  

**Program Purpose**  
This program produces a complete trial‑balance report for all ledger accounts. It lists each account’s current balance, last‑year balance, and quarterly balances, and supplies total debits and credits for audit and reporting purposes. The report helps ensure that the accounting records are balanced and that financial statements can be prepared accurately and on time.  

**Screen Interactions**  
1. **Error screen** – When the ledger file cannot be opened, the program displays a message indicating that the ledger file does not exist and prompts the user to press **Return** to quit.  
2. **Report screen** – The program prints a report that begins with a header showing the program name, current date, user name, and page number. It then lists each account with its balances and ends with totals. No user input is required during the report display.  

**Messages and Errors**  
- *Ledger file not found*: The program shows an error message and waits for the user to press Return before terminating.  
- *End of report*: After all accounts are listed, the program finishes automatically without further prompts.  

**User Flow Summary**  
The user starts the program (typically from a command or menu). The program opens the ledger file and automatically generates a detailed trial‑balance report. The report is printed or displayed on the screen, showing each account’s current, previous‑year, and quarterly balances. Totals for debits and credits are included at the bottom of the report. Once the report is complete, the program closes the ledger file and exits, returning control to the calling environment.  

**Program Linkages**  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program opens the ledger file, displays a header, and then enters a loop that reads each ledger record, formats it, and writes it to the print file. When the end of the ledger file is reached, the program prints a totals line, closes the print file, and invokes the system print command. Finally, the program closes the ledger file and exits. [Seen in: gl090b-Main section., p-loop., end-report., main-exit.]

5.2 Initialization  
The program performs an initial open of the ledger file (GL-Nominal-Open-Input) and checks for errors, displaying a message and aborting if the file cannot be opened. It then sets up the print spool name, converts the current date to the appropriate format (zz070-Convert-Date), opens the print file, and writes the initial page heading. [Seen in: GL-Nominal-Open-Input, zz070-Convert-Date, page-heading.]

5.3 Core Processing  
Path: Ledger-Read-Loop  
Trigger: Entry to the p-loop paragraph.  
Key steps: Perform GL-Nominal-Read-Next, test for end‑of‑file or error, write the formatted ledger line to the print file, increment line counter, and trigger a new page heading when the line count exceeds Page‑Lines.  
I/O: ledger-file (input), print-file (output).  
Outcomes: line‑cnt and page‑nos updated, ledger totals accumulated.  
[Seen in: p-loop, GL-Nominal-Read-Next, page-heading.]

Path: Page-Heading  
Trigger: Invocation of the page-heading paragraph (initially and after each page).  
Key steps: Increment page‑nos, determine quarter indices j and k based on current‑quarter, and write header lines (line‑1, line‑3, line‑4, line‑5) to the print file.  
I/O: print-file (output).  
Outcomes: Header printed, page‑nos incremented.  
[Seen in: page-heading.]

Path: End-Report  
Trigger: Exit from the p-loop when ledger‑n equals 9999 or we‑error is set.  
Key steps: Write a totals line (line‑6) and a separator (line‑7), close the print file, and call the system print command.  
I/O: print-file (output).  
Outcomes: Totals displayed, print file closed, print job submitted.  
[Seen in: end-report.]

Path: Ledger-Open  
Trigger: Perform GL-Nominal-Open-Input at program start.  
Key steps: Open the ledger file for input and set fs‑reply.  
I/O: ledger-file (input).  
Outcomes: fs‑reply indicates success or failure.  
[Seen in: GL-Nominal-Open-Input.]

Path: Ledger-Close  
Trigger: Perform GL-Nominal-Close at program end.  
Key steps: Close the ledger file.  
I/O: ledger-file (input).  
Outcomes: Ledger file closed.  
[Seen in: GL-Nominal-Close.]

5.4 Termination  
The program closes the print file, calls the system print command, closes the ledger file, and then performs a GOBACK to terminate. [Seen in: end-report, GL-Nominal-Close, main-exit.]

---
## gl100
*[73/267]*

### Business/Functional Perspective
### Ledger Pre‑Sort Printing

**Program Purpose**  
The program prepares ledger data for printing by sorting a pre‑archived file. It reads the raw ledger archive, orders the entries by account, posting code, batch and post number, and writes the sorted result to a temporary output file. This ordering ensures that ledger reports are accurate, compliant with accounting standards, and ready for downstream printing or reconciliation, thereby reducing the risk of mis‑ordered or incomplete financial records.

**Screen Interactions**  
1. **Header Screen** – Displays the program name and the title “Ledger Print - Sort”.  
2. **Instruction Prompts** – Shows two messages:  
   * “Ensure Archive USB Memory Stick is in path” (prompting the user to confirm the archive location).  
   * “Enter <0> to signify change made or <9> to abort this run :- [ ]” (waiting for a numeric key).  
3. **Path Entry** – After the user presses a key other than 9, the screen prompts: “Current path/name is :”. The user can edit the default archive file path or confirm it.

**Messages and Errors**  
- **Abort** – Pressing **9** stops the run immediately.  
- **Confirm Change** – Pressing **0** proceeds to the path entry step.  
- **Missing Archive** – If the archive file cannot be opened (e.g., the USB stick is absent or the path is wrong), the program exits after notifying the user.  
- **Invalid Input** – Any key other than 0 or 9 during the initial prompt causes the screen to re‑display, allowing the user to try again.

**User Flow Summary**  
The user starts the program and sees a simple screen with a title and two instructional lines. They press **0** to continue or **9** to cancel. If continuing, they are asked to confirm or modify the path to the archive file. After entering a valid path, the program opens the archive, sorts the ledger records by key fields, writes the sorted data to a temporary file, and then exits. If the archive cannot be found or opened, the user is informed and the program terminates.

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Sentence 1. The program begins by displaying its name and a title on the screen, then performs a disk‑change routine to set file paths and gather user input. [Seen in: gl100-Main.]  
Sentence 2. It checks for an abort request; if the user entered 9, it sets a termination code and exits. [Seen in: gl100-Main.]  
Sentence 3. If not aborted, it opens the input archive file, sorts its contents into an output file, and then terminates. [Seen in: gl100-Main.]

5.2 Initialization  
Sentence 1. The disk‑change section constructs the full paths for the archive and temporary output files, displays prompts, and accepts user input for the abort flag and archive file name. [Seen in: disk-change.]  
Sentence 2. After returning from disk‑change, the program verifies the abort flag and attempts to open the archive file, setting an error code if the open fails. [Seen in: gl100-Main.]

5.3 Core Processing  
Path: Abort Run  
Trigger: User enters 9 during disk‑change input.  
Key steps: set ws‑term‑code to 5, go to menu‑exit.  
I/O: none.  
Outcomes: program exits with termination code 5.  
[Seen in: gl100-Main.]  

Path: Archive Open Failure  
Trigger: fs‑reply not zero after attempting to open the archive file.  
Key steps: set ws‑term‑code to 4, go to menu‑exit.  
I/O: open archive.  
Outcomes: program exits with termination code 4.  
[Seen in: gl100-Main.]  

Path: Disk‑Change Input Loop  
Trigger: Accept‑option loop for user input of abort flag and archive file name.  
Key steps: display GL105 and GL101, accept a, loop if a not zero, accept file‑2, loop if file‑2 first char space.  
I/O: display, accept.  
Outcomes: sets a and file‑2 for subsequent processing.  
[Seen in: disk-change, accept-option.]  

Path: Sort Operation  
Trigger: Successful opening of the archive file.  
Key steps: perform sort on sort‑file using archive giving arch‑out.  
I/O: sort‑file, archive, arch‑out.  
Outcomes: sorted output file created.  
[Seen in: gl100-Main.]  

Path: Display Startup Messages  
Trigger: Program start.  
Key steps: display prog‑name and title.  
I/O: display.  
Outcomes: screen shows program name and title.  
[Seen in: gl100-Main.]  

Path: Exit  
Trigger: menu‑exit paragraph.  
Key steps: goback.  
I/O: none.  
Outcomes: program terminates and returns control.  
[Seen in: menu-exit.]  

5.4 Termination  
Sentence 1. On normal completion, the program reaches the menu‑exit paragraph and executes a GOBACK to return control to the caller. [Seen in: menu-exit.]  
Sentence 2. If an abort or file‑open error occurs, the program sets ws‑term‑code to 5 or 4 respectively before exiting. [Seen in: gl100-Main.]

---
## gl105
*[74/267]*

### Business/Functional Perspective
### Ledger Print  

---

**Program Purpose**  
The Ledger Print program produces a hard‑copy ledger report from archived posting data. It lets the user decide whether to print all accounts or a single account, and whether to include all product codes or a specific product code. The program checks that the archive file is available, validates the requested account and product code, and then prints a formatted ledger to the output spool for audit and record‑keeping.  

---

**Screen Interactions**  

1. **Main Prompt** –  
   *Title:* “Ledger Print” displayed at the top of the screen.  
   *Input:* Y/N to print all accounts.  
   *Options:* ‘Y’ to print all, ‘N’ to supply a specific account.  

2. **Account Entry** – (appears if the user chose ‘N’ in step 1)  
   *Prompt:* “Enter Account to print”  
   *Input:* Account number.  

3. **Product‑Code Prompt** –  
   *Input:* Y/N to print all product codes.  

4. **Product‑Code Entry** – (appears if the user chose ‘N’ in step 3)  
   *Prompt:* “Enter P/C to Print”  
   *Input:* Product‑code number.  

5. **Archive Path Confirmation** –  
   *Prompt:* “Current path is :” followed by the archive file name.  
   *Input:* Ability to change the path if needed.  

6. **Abort/Change Prompt** –  
   *Prompt:* “Enter 0 to change, 9 to abort” (displayed as part of the path confirmation).  
   *Input:* ‘9’ aborts the run; other keys re‑display the prompt.  

---

**Messages and Errors**  

- **Archive File Missing** – “Ensure Archive USB Memory Stick is in path”.  
- **Account Not Found** – “A/C Not Found”.  
- **Product Code Not Found** – “P/C Not Found”.  
- **Abort Option** – Entering ‘9’ during the abort prompt stops the program immediately.  
- **Retry Prompts** – If an invalid key is entered at any yes/no prompt, the screen is re‑displayed until a valid input is received.  

---

**User Flow Summary**  

1. The user launches the program.  
2. The screen shows a header “Ledger Print” and asks whether all accounts should be printed.  
3. If the user selects “all”, the program proceeds to the product‑code prompt; otherwise the user enters a specific account number.  
4. The user is then asked whether all product codes should be printed; if not, they enter the desired product code.  
5. The program verifies that the archive file exists, and confirms the file path on screen, offering the chance to change it.  
6. The program checks that the entered account and product code exist; if either is missing, an appropriate message is shown and the user can re‑enter.  
7. Once all parameters are valid, the program reads the archived posting records, formats them into a ledger report, and sends the report to the output spool.  
8. When finished, the program calls the operating‑system routine to print the spool file and then exits.  

---

**Program Linkages**  

- SYSTEM (used to print the spool file)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph **MAIN**, initializing display and date conversion, then prompts the user for printing options. [Seen in: main.]  
Depending on the user’s responses, it may request a specific account or P/C, validating them against the nominal ledger via **GL-Nominal-Read-Indexed**. [Seen in: get-2, get-4.]  
After selection, paragraph **START-RUN** opens the archive and print files and enters **LOOP** to process each record, generating headings and line entries. [Seen in: start-run, loop.]  
When the archive is exhausted, paragraph **MAIN-END** closes files, calls the system print routine, and exits. [Seen in: main-end.]

5.2 Initialization  
MAIN performs date conversion (**zz070-Convert-Date**), displays program header, and calls **disk-change** to build the archive path. [Seen in: main, zz070-Convert-Date, disk-change.]  
It then opens the nominal ledger (**GL-Nominal-Open-Input**) and prompts the user for printing mode, setting up variables such as ws-reply, ac-to-print, and pc-to-print. [Seen in: main, GL-Nominal-Open-Input.]

5.3 Core Processing  

Path: Print All Accounts  
Trigger: User answers “Y” to both “Print All Accounts?” and “Print all P/Cs ?” prompts. [Seen in: get-1, get-3.]  
Key steps: Open archive and print files, loop through all archive records, write headings for each new account, output transaction lines, and write totals at account end. [Seen in: start-run, loop, new-ac, headings, ac-end.]  
I/O: archive (input), print-file (output). [Seen in: start-run, loop, ac-end.]  
Outcomes: All accounts and their P/Cs are printed to the spool file, totals are displayed, and the program proceeds to termination. [Seen in: main-end.]

Path: Print Specific Account  
Trigger: User enters an account number at the “Enter Account to print” prompt and it is found in the nominal ledger. [Seen in: get-2, GL-Nominal-Read-Indexed.]  
Key steps: Set ac-to-print, open archive and print files, loop through archive records filtering by that account, generate headings and lines, write totals. [Seen in: start-run, loop, new-ac, headings, ac-end.]  
I/O: ledger file (GL-Nominal-Read-Indexed), archive, print-file. [Seen in: get-2, start-run, loop, ac-end.]  
Outcomes: Only the selected account’s transactions are printed, with totals, before program exit. [Seen in: main-end.]

Path: Print Specific P/C  
Trigger: User enters a P/C after selecting a specific account, and the P/C exists in the nominal ledger. [Seen in: get-4, GL-Nominal-Read-Indexed.]  
Key steps: Set pc-to-print, open archive and print files, loop through archive records filtering by account and P/C, write headings and lines, write totals. [Seen in: start-run, loop, new-ac, headings, ac-end.]  
I/O: ledger file, archive, print-file. [Seen in: get-4, start-run, loop, ac-end.]  
Outcomes: Only the selected P/C’s transactions are printed, with totals, before program exit. [Seen in: main-end.]

Path: End-of-Cycle Orchestration  
Trigger: End of archive file reached during LOOP. [Seen in: loop.]  
Key steps: Execute ac-end to write final totals, reset totals, exit LOOP, close print-file and archive, call SYSTEM to print report. [Seen in: ac-end, main-end.]  
I/O: archive, print-file. [Seen in: ac-end, main-end.]  
Outcomes: Totals are printed, files are closed, and the program terminates cleanly. [Seen in: main-exit.]

Path: System Setup (Disk Change)  
Trigger: Executed at program start before opening archive. [Seen in: disk-change.]  
Key steps: Build the path for the archive file, display messages, accept user input for path if needed, set arc-out-name. [Seen in: disk-change.]  
I/O: none (user input). [Seen in: disk-change.]  
Outcomes: arc-out-name is set to the correct file path for the archive. [Seen in: main.]

5.4 Termination  
MAIN-END closes the print-file and archive, calls GL-Nominal-Close, invokes the system print routine, and then GOBACK to exit. [Seen in: main-end.]  
The program terminates with a clean exit after freeing resources. [Seen in: main-exit.]

---
## gl120
*[75/267]*

### Business/Functional Perspective
### Profit & Loss Report

---

**Program Purpose**  
The program generates a Profit‑&‑Loss statement and a Balance Sheet for a specified reporting period. By reading the ledger entries for that period, it aggregates totals, calculates balances, and produces a formatted printed report. This enables managers and auditors to verify financial performance and position, ensuring compliance with accounting standards and supporting decision‑making.

---

**Screen Interactions**

1. **Date Entry Screen**  
   - Title: *Enter P&L Date (space to abort)*  
   - Input: User types a date (in UK, USA or international format).  
   - Controls: Space to exit, otherwise the date is accepted and processed.

2. **Confirmation Screen**  
   - Prompt: *Ok to continue? (Y/N)*  
   - Default: *[Y]*  
   - Input: Y or N to proceed or re‑enter a date.

3. **Report Output**  
   - The final Profit & Loss and Balance Sheet is printed to the default output device (usually a printer or spool). No further user interaction is required on the report screen.

---

**Messages and Errors**

- **Ledger File Not Found** – A message indicates that the required ledger file or table could not be located. The user is prompted to press return to quit.  
- **Invalid or Unsupported Date** – If the entered date cannot be parsed or validated, the program returns to the date entry prompt.  
- **Operation Stops** – If no ledger data is available for the chosen period, the report ends gracefully without producing totals.  

---

**User Flow Summary**

1. The user starts the report program.  
2. A screen prompts for the reporting period date. The user enters a valid date or presses space to cancel.  
3. After a valid date, the program asks for confirmation to proceed.  
4. Upon confirmation, the program reads the company’s ledger file, aggregates debit and credit balances by account levels, and calculates totals for Profit & Loss and Balance Sheet items.  
5. A formatted report is generated and sent to the printer. The user can view the printed report or spool file.  
6. The program terminates, returning control to the caller or to the batch environment.

---

**Program Linkages**

- CALL "SYSTEM" using Print-Report  
- CALL "maps04" using maps03-ws

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the gl120‑Main section, displaying the title and converting the current date to UK format before prompting the user for a P&L date. [Seen in: gl120-Main]  
After validating the date, it opens the ledger input file, the Final‑Output file, and initializes all accounting accumulators before entering a loop that reads each ledger record, aggregates balances, and writes subtotals to the Final‑Output file. [Seen in: loop]  
Once all ledger records are processed, the program generates a formatted report by reading the Final‑Output file, handling place changes, and printing totals to the printer before exiting. [Seen in: pl-loop]

5.2 Initialization  
The program displays the program name and title, converts the system date to UK format, and prompts the user for the reporting period date. [Seen in: gl120-Main]  
It then opens the ledger input file (GL‑Nominal‑Open‑Input), the Final‑Output file, and initializes all ledger, balance, and total variables to zero. [Seen in: gl120-Main, loop]

5.3 Core Processing  
Path: Ledger Read and Accumulate Loop  
Trigger: Entry to the loop after file opens.  
Key steps: perform GL‑Nominal‑Read‑Next, check for end‑of‑file or error, accumulate balances into level‑specific totals, and when a level change occurs, perform detail‑print and total‑print routines.  
I/O: ledger‑file (via GL‑Nominal‑Read‑Next), Final‑Output‑file.  
Outcomes: updates l‑dr/l‑cr arrays, writes subtotals to Final‑Output‑file, sets we‑error for EOF.  
[Seen in: loop, detail-print, total4-print, total3-print, total2-print, total1-print]

Path: Final Report Generation  
Trigger: After end‑run, before printing.  
Key steps: open print‑file, read Final‑Output‑file record by record, detect place changes, invoke place‑change and number‑change, write formatted lines to print‑file.  
I/O: Final‑Output‑file, print‑file.  
Outcomes: produces the printed P&L and Balance Sheet report, updates run‑this/run‑last totals.  
[Seen in: pl-loop, place-change, number-change, main-end]

Path: Place Change and Number Change  
Trigger: When l‑place differs from store‑place during pl‑loop.  
Key steps: search place‑table for l‑place, set v, perform number‑change to output subtotals, adjust run‑this/run‑last based on place number, write summary lines.  
I/O: none external.  
Outcomes: updates run totals, writes intermediate totals and gross/net profit lines.  
[Seen in: place-change, number-change]

Path: Error Handling for Missing Ledger  
Trigger: After GL‑Nominal‑Open‑Input if fs‑reply not zero.  
Key steps: display GL121 and GL013 messages, accept user reply, go to main‑exit.  
I/O: none.  
Outcomes: program terminates without processing.  
[Seen in: gl120-Main, main-exit]

5.4 Termination  
The program closes the Final‑Output file, the ledger file, and the print file, then calls the operating‑system print routine before executing GOBACK to return control. [Seen in: end-run, main-exit]

---
## glbatchLD
*[76/267]*

### Business/Functional Perspective
### GL Batch Table Load  

**Program Purpose**  
This program imports a General Ledger (GL) batch file into a MySQL database. It reads system settings, connects to the database, processes each transaction record, and writes the data into the appropriate table. Duplicate records are detected and handled automatically, while errors such as missing files or database write failures are reported to the user. The routine ensures that only valid, uniquely identified records enter the ledger, supporting accurate financial reporting and audit compliance.  

**Screen Interactions**  
No direct screens. This program runs as a background job after a separate data‑entry step and returns results (counts and status messages) back to that context.  

**Messages and Errors**  
- **File and System Access** – If the system parameters file cannot be opened or read, the program stops and informs the user that the system file is missing or corrupt.  
- **Database Configuration** – When the database name, user, or host is not defined, the program aborts and tells the user that the database has not been set up.  
- **Batch File Availability** – If the GL batch file is not found, the program ends with a message that there is nothing to process.  
- **Record Processing Errors** – Any failure to read a record from the batch file, or to write a record to the database, triggers an error message that describes the problem.  
- **Duplicate Key Handling** – Duplicate transaction keys are automatically rewritten or ignored; the program reports when a duplicate is detected and how it was handled.  
- **Commit/Rollback Issues** – If the final commit or rollback fails, the program notifies the user that the database operation could not be completed.  

**User Flow Summary**  
The user initiates the program, optionally providing up to two command‑line arguments. The routine reads system parameters to obtain database connection details, or it loads these from an external parameter file if needed. It then opens the specified GL batch file. Each record in the file is read sequentially; the program attempts to insert the record into the MySQL ledger table. If a record already exists, the program either updates the existing entry or skips it, keeping a count of such occurrences. After all records have been processed, the program commits the transaction to the database and prints a final summary showing how many records were read, written, and rewritten. Finally, it closes the files and terminates cleanly.  

**Program Linkages**  
- acas007  
- acas-get-params  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins by parsing command line arguments, opening the system parameter file, and loading database connection details, then proceeds to open the batch file for reading. [Seen in: aa000-main-start.]  
If the batch file is missing or cannot be opened, the program logs an error and terminates without processing any records. [Seen in: aa010-Proc-Override.]  
Otherwise, the program enters a loop that reads each batch record, writes it to the GL batch table in MySQL, handling duplicate keys and other database errors as they occur. [Seen in: aa010-Read.]  
Upon reaching end‑of‑file or encountering a fatal error, the program writes a summary of processed records, closes all files and database connections, and exits. [Seen in: aa999-Finish.]

5.2 Initialization  
The program performs a PERFORM of zz020-Get-Program-Args to capture command line arguments, then sets up logging parameters for FH logging. [Seen in: aa000-main-start.]  
It opens the system file, reads the first record to obtain RDBMS settings, and if those settings are missing, attempts to read them from acas.param via acas-get-params. [Seen in: aa000-main-start.]  
If the system file or parameter file cannot be read, the program displays an error message and aborts. [Seen in: aa000-main-start.]  
After successful parameter loading, the program opens the Cobol batch file for input and the MySQL table via acas007, initializing file and access flags. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: System Parameter Load and DB Setup  
Trigger: Program start (aa000-main-start).  
Key steps: Perform zz020-Get-Program-Args, open system file, read record, load RDBMS settings, call acas-get-params if needed, set logging flags, open batch file input, open RDB table.  
I/O: System-File, acas.param (via acas-get-params), Cobol batch file, MySQL table.  
Outcomes: sets WS-Log-System, WS-Log-File-No, RDBMS connection details, File-System-Used flags, prepares for record processing.  
[Seen in: aa000-main-start, aa010-Proc-Override.]

Path: Batch File Missing  
Trigger: acas007-Open-Input returns FS-Reply = 35.  
Key steps: Detect FS-Reply 35, log GL097 message, close system file, close batch file, exit.  
I/O: Cobol batch file.  
Outcomes: program terminates without processing records.  
[Seen in: aa010-Proc-Override.]

Path: Batch Record Processing Loop  
Trigger: acas007-Read-Next returns FS-Reply = 0 (record read).  
Key steps: Increment input count, set File-System-Used, perform acas007-Write to insert into MySQL, handle duplicate key or other errors, increment output count, loop back to read next.  
I/O: Cobol batch file, MySQL table.  
Outcomes: ws-Rec-Cnt-In, ws-Rec-Cnt-Out, ws-Rec-Cnt-R-Out updated; possible error messages logged; continues until EOF.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: acas007-Write returns FS-Reply = 22 or 99 or SQL-Err 1062/1022.  
Key steps: Reset FS-Reply and WE-Error, perform acas007-Rewrite to update existing record, if rewrite fails log duplicate key message, increment rewrite count, continue loop.  
I/O: Cobol batch file, MySQL table.  
Outcomes: ws-Rec-Cnt-R-Out incremented, duplicate key logged, processing continues.  
[Seen in: aa010-Read.]

Path: Error on Write  
Trigger: acas007-Write returns FS-Reply not zero other than duplicate key.  
Key steps: Log error messages including FS-Reply, WE-Error, SQL-Err, SQL-Msg, SQL-State, set return-code 16, go to finish.  
I/O: Cobol batch file, MySQL table.  
Outcomes: processing stops, error summary logged.  
[Seen in: aa010-Read.]

Path: Finish and Cleanup  
Trigger: EOF (FS-Reply=10) or fatal error leads to aa999-Finish.  
Key steps: Log record counts, close RDB table, close system file, close batch file, log EOJ message, exit.  
I/O: System-File, Cobol batch file, MySQL table.  
Outcomes: program terminates gracefully.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program writes a final summary of records processed, closes all open files and database connections, logs an end‑of‑job message, and returns control to the operating system. [Seen in: aa999-Finish.]  
If a fatal error was encountered during processing, the program sets an appropriate return-code before exiting. [Seen in: aa010-Read, aa999-Finish.]

---
## glbatchMT
*[77/267]*

### Business/Functional Perspective
### GL Batch File Handling

**Program Purpose**  
The program manages General Ledger (GL) batch records in the accounting system. It performs all database operations—creating, reading, updating, deleting, and listing records—while ensuring data integrity, detecting duplicate keys, and logging each interaction for audit and troubleshooting. The module serves as the single entry point for GL batch data access, supporting both flat‑file and relational database environments and facilitating migration between them.

**Screen Interactions**  
No direct screens. This program is invoked by a higher‑level data‑entry module and returns results and status codes back to that context.

**Messages and Errors**  
- **Connection issues** – If the database cannot be opened, the operation is aborted and an error is logged.  
- **Duplicate key** – Attempting to write a record that already exists results in a “duplicate key” notification.  
- **Record not found** – If a requested key does not exist (for read, delete, or rewrite), a “record not found” status is returned.  
- **Read/Fetch errors** – Failures when retrieving data are reported with an appropriate error message.  
- **Write/Insert errors** – General database errors during insert, update, or delete are captured and returned.  
- **Invalid function or parameters** – If the requested operation code is unsupported or parameters are out of range, an error status is produced.  
- **Unexpected failures** – Any other unexpected error triggers a generic failure status and logs the incident for investigation.

**User Flow Summary**  
1. A calling module supplies a GL batch record and a function code that indicates the desired operation (e.g., open, close, read next, read indexed, start, write, delete, delete all, rewrite).  
2. The program opens the database connection if required and performs the requested operation, applying key checks and handling duplicates or missing records.  
3. After execution, the program returns the record (if applicable), status codes that indicate success or the type of failure, and logs the action for audit purposes.  
4. The calling module receives the results and can present a success message, display an error, or take corrective action as needed.

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- MySQL_query  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by accepting the number of environment lines and setting screen exception flags. [Seen in: ba010-Initialise.]  
It clears all MySQL and error status fields before evaluating the File-Function to determine the requested operation. [Seen in: ba010-Initialise.]  
The evaluate dispatch routes execution to the specific processing paragraph (open, close, read, write, delete, etc.) based on the File-Function value. [Seen in: ba010-Initialise.]

5.2 Initialization  
The program sets the environment variables for screen exceptions and clears all status and error fields (WS-MYSQL-Error-Message, WS-MYSQL-Error-Number, WS-Log-Where, WS-File-Key, SQL-Msg, SQL-Err, SQL-State). [Seen in: ba010-Initialise.]  
It also accepts the number of environment lines and ensures a minimum of 24 lines for screen handling. [Seen in: ba010-Initialise.]  
The linkage areas are already populated with the incoming record and function parameters before initialization. [Seen in: ba-ACAS-DAL-Process.]

5.3 Core Processing  

Path: Open  
Trigger: File‑Function = 1  
Key steps: Build MySQL connection parameters from DB‑Host, DB‑UName, etc.; perform MYSQL‑1000‑OPEN; set Cursor‑Not‑Active; set WS‑File‑Key to “OPEN GLBATCH”.  
I/O: MySQL connection, table GLBATCH‑REC (not yet accessed).  
Outcomes: FS‑Reply set to 0 on success, otherwise 99; WE‑Error remains 0; WS‑File‑Key set for logging.  
[Seen in: ba020-Process-Open.]

Path: Read‑Next  
Trigger: File‑Function = 3  
Key steps: If cursor not active, build WHERE clause for BATCH‑KEY >= “000000”, perform SELECT, store result, set cursor active; if no rows set FS‑Reply = 10, WE‑Error = 10, WS‑File‑Key = “No Data”; otherwise set cursor active and log count. If cursor active, perform FETCH (ba041‑Reread); on EOF set FS‑Reply = 10, WE‑Error = 10, WS‑File‑Key = “EOF”; on success unload HVs to record, set WS‑File‑Key to record key, FS‑Reply = 0, WE‑Error = 0.  
I/O: MySQL SELECT, FETCH, table GLBATCH‑REC.  
Outcomes: FS‑Reply 0 for record, 10 for EOF, WE‑Error 0 or 10, WS‑File‑Key record key or EOF.  
[Seen in: ba040-Process-Read-Next, ba041-Reread.]

Path: Read‑Indexed  
Trigger: File‑Function = 4  
Key steps: Build WHERE clause for BATCH‑KEY = key value, perform SELECT, if zero rows set FS‑Reply = 21 and free cursor; if rows exist, FETCH, unload HVs, set WS‑File‑Key to key, FS‑Reply = 0, WE‑Error = 0.  
I/O: MySQL SELECT, FETCH, table GLBATCH‑REC.  
Outcomes: FS‑Reply 0 for found, 21 for not found, WE‑Error 0 or 990/989.  
[Seen in: ba050-Process-Read-Indexed.]

Path: Write  
Trigger: File‑Function = 5  
Key steps: Load HVs from record (bb000‑HV‑Load), set WS‑File‑Key to key, perform INSERT (bb200‑Insert); if COUNT‑ROWS ≠ 1 handle duplicate key (SQL‑Err 1062/1022 or Sql‑State 23000) set FS‑Reply = 22, else set FS‑Reply = 99.  
I/O: MySQL INSERT into GLBATCH‑REC.  
Outcomes: FS‑Reply 0 for success, 22 for duplicate, 99 for other error; WE‑Error set accordingly.  
[Seen in: ba070-Process-Write.]

Path: Delete  
Trigger: File‑Function = 8  
Key steps: Build WHERE clause for BATCH‑KEY = key, perform DELETE; if COUNT‑ROWS ≠ 1 set FS‑Reply = 99, WE‑Error = 995; else set FS‑Reply = 0, WE‑Error = 0.  
I/O: MySQL DELETE from GLBATCH‑REC.  
Outcomes: FS‑Reply 0 for success, 99 for error.  
[Seen in: ba080-Process-Delete.]

Path: Delete‑ALL  
Trigger: File‑Function = 6  
Key steps: Set key to 999999, build WHERE clause with ‘<"999999"’, perform DELETE; if COUNT‑ROWS not > zero set FS‑Reply = 99, WE‑Error = 995; else set FS‑Reply = 0, WE‑Error = 0.  
I/O: MySQL DELETE from GLBATCH‑REC.  
Outcomes: FS‑Reply 0 for success, 99 for error.  
[Seen in: ba085-Process-Delete-ALL.]

5.4 Termination  
The program performs any pending logging via Ca‑Process‑Logs if Testing‑1 is set, then exits via ba999‑exit. [Seen in: ba999-end.]  
The final status is returned through FS‑Reply, WE‑Error, SQL‑Err, SQL‑Msg, and WS‑File‑Key in the linkage area. [Seen in: ba999-end.]

---
## glbatchRES
*[78/267]*

### Business/Functional Perspective
### Restore GL Batch

**Program Purpose**  
The program restores a General Ledger batch by copying records from a sequential backup file (`batch.seq`) to the primary batch file used by the accounting system. It verifies that the backup file exists, reads each record, writes it to the target file, and logs the total number of records processed. This ensures that a lost or corrupted batch can be recovered quickly, maintaining data integrity and compliance with audit requirements.

**Screen Interactions**  
No direct screens. This program is run automatically after a data‑entry step and reports its results only through log files.

**Messages and Errors**  
- *Missing file*: “No GLbatch file to process” – the backup file could not be found.  
- *Read error*: “Problem reading .seq file” – the program encountered an error while reading the backup.  
- *Write error*: “SYS06 Write error on .dat file” – an error occurred while writing records to the destination file.  
- *Operation complete*: The program logs the number of records read and written, indicating successful restoration.

**User Flow Summary**  
The user initiates the restore program (e.g., from a scheduled batch job). The program checks for the existence of the backup file. If the file is present, it reads each record sequentially and writes it to the primary batch file, counting the records processed. Throughout the operation, status messages and any errors are written to a system log (`SYS-DISPLAY.log`). Once all records are processed or an unrecoverable error occurs, the program logs the totals and terminates, returning control to the calling process or batch scheduler.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins by retrieving command line arguments and logging startup information. [Seen in: aa000-Main-Start.]  
It then opens the source sequential file “batch.seq” for input and a destination file for output, handling any open errors. [Seen in: aa000-Main-Start.]  
The main loop reads each record from the source, writes it to the destination, and counts processed records until end‑of‑file or an error occurs, after which it closes both files and logs a summary before exiting. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line parameters and sets logging identifiers. [Seen in: aa000-Main-Start.]  
It initializes record counters to zero and prepares a status message buffer before attempting file operations. [Seen in: aa000-Main-Start.]  
If the source file cannot be opened, an error message is logged and the program terminates immediately. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: File Open and Error Handling  
Trigger: After performing zz020-Get-Program-Args in aa000-Main-Start.  
Key steps: open input glBatch-File-Seq, check FS-Reply; open output Batch-File, check FS-Reply; on error log message and goback.  
I/O: glBatch-File-Seq, Batch-File.  
Outcomes: sets FS-Reply, logs error, exits if failure.  
[Seen in: aa000-Main-Start.]  

Path: Record Read/Write Loop  
Trigger: Entry to aa010-Read-Recs.  
Key steps: read next record, increment input count, write to Batch-Record, increment output count, handle read/write errors by logging and exiting loop.  
I/O: glBatch-File-Seq, Batch-File.  
Outcomes: copies all records, updates ws-Rec-Cnt-In and ws-Rec-Cnt-Out, may terminate on error.  
[Seen in: aa010-Read-Recs.]  

Path: Finish and Summary  
Trigger: aa020-Finish-Off after loop completion or error.  
Key steps: close both files, build summary string with record counts, log summary, set Return-Code to zero, goback.  
I/O: glBatch-File-Seq, Batch-File.  
Outcomes: final counts reported, program exits cleanly.  
[Seen in: aa020-Finish-Off.]  

Path: Environment Setup (Post-Processing)  
Trigger: After aa020-Finish-Off, copy "Proc-Get-Env-Set-Files.cob" is executed.  
Key steps: set environment variables and file paths (ACAS_LEDGERS).  
I/O: N/A.  
Outcomes: environment ready for subsequent operations (though not used further in this file).  
[Seen in: Proc-Get-Env-Set-Files.cob.]  

Path: Final Sysout Call  
Trigger: After environment setup, Call-Sysout is invoked.  
Key steps: call ACAS-Sysout with SO-Print.  
I/O: N/A.  
Outcomes: final message output to SYS-DISPLAY.log.  
[Seen in: Call-Sysout.]

5.4 Termination  
The program closes both input and output files, logs a final summary of record counts, sets Return-Code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]  
Any error encountered during file operations results in an immediate GOBACK after logging the error message. [Seen in: aa000-Main-Start.]

---
## glbatchUNL
*[79/267]*

### Business/Functional Perspective
### Batch File Backup  

**Program Purpose**  
The program creates a backup of a batch data file by copying each record from the original file into a new sequential file (`batch.seq`). It logs the start and end of the operation, counts how many records were read and written, and records any problems that occur. This ensures a reliable copy of the batch data that can be used for recovery or audit purposes, reducing data loss risk.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the source batch file cannot be opened, the user sees “No glbatch file to process.”  
- If a read error occurs, the program logs a message indicating a problem reading the batch file.  
- If a write error occurs while creating the backup file, a message is logged that a write error occurred on the `.seq` file.  
- General success messages report the number of records processed and close operations.  

**User Flow Summary**  
The user starts the program (typically from a batch job or command line). The program opens the original batch file and, if it exists, reads each record one at a time, writing the same record to a new sequential file. As it processes, it keeps a running count of records read and written. When all records have been handled or an error occurs, the program closes both files, logs a summary of records processed, and exits. The resulting `batch.seq` file is a backup copy of the original data, and the log file contains a record of the operation for audit or troubleshooting.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and initializing logging parameters. [Seen in: aa000-Main-Start.]  
It opens the source batch file for input, verifies its existence, and then opens the destination sequential file for output. [Seen in: aa000-Main-Start.]  
The main loop reads each record from the batch file, writes it to the sequential file, counts records, and handles any read or write errors before closing files and reporting totals. [Seen in: aa010-Read-Recs.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and sets logging system and file numbers. [Seen in: aa000-Main-Start.]  
It initializes the record counters and clears the output message buffer before opening the batch file for input. [Seen in: aa000-Main-Start.]  
If the batch file cannot be opened, it logs a message and exits immediately. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Batch-File-Open-Check  
Trigger: open input Batch-File fails (FS-Reply not zeros)  
Key steps: log message “No glbatch file to process”, close file, goback  
I/O: Batch-File  
Outcomes: program exits immediately with error logged.  
[Seen in: aa000-Main-Start.]

Path: Record-Read-Loop  
Trigger: successful open of Batch-File, enter aa010-Read-Recs  
Key steps: read next record; if FS-Reply not zeros log SY003 and go to finish; write record to glbatch-File-Seq; if write error log SY006 and go to finish; increment input and output counters; loop until end of file.  
I/O: Batch-File, glbatch-File-Seq  
Outcomes: records written, counters updated, errors logged if any.  
[Seen in: aa010-Read-Recs.]

Path: End-Of-File  
Trigger: read next record at end  
Key steps: go to aa020-Finish-Off, close files, log totals, set Return-Code zero, goback.  
I/O: Batch-File, glbatch-File-Seq  
Outcomes: program terminates normally.  
[Seen in: aa020-Finish-Off.]

Path: Read-Error  
Trigger: FS-Reply not zeros after read  
Key steps: log SY003 with FS-Reply, go to aa020-Finish-Off.  
I/O: Batch-File  
Outcomes: program terminates with error logged.  
[Seen in: aa010-Read-Recs.]

Path: Write-Error  
Trigger: FS-Reply not zero after write  
Key steps: log SY006, go to aa020-Finish-Off.  
I/O: glbatch-File-Seq  
Outcomes: program terminates with error logged.  
[Seen in: aa010-Read-Recs.]

5.4 Termination  
The program closes both the input batch file and the output sequential file, logs the record counts, and then exits with a zero return code. [Seen in: aa020-Finish-Off.]  
Any error encountered during reading or writing causes the program to jump to the finish‑off paragraph, perform the same cleanup, and exit. [Seen in: aa020-Finish-Off.]

---
## glpostingLD
*[80/267]*

### Business/Functional Perspective
### GL Posting Table Load  

#### Program Purpose  
The program transfers general‑ledger posting records from a flat posting file into the MySQL posting table used by the accounting system. It guarantees that each record is inserted correctly, manages duplicate entries by rewriting or ignoring them as appropriate, and records any problems that occur. By keeping the database in sync with the posting file, it supports accurate reporting and audit trails for the business.  

#### Screen Interactions  
No direct screens. This program is invoked after a separate data‑entry step and returns results back to that context.  

#### Messages and Errors  
* **Configuration errors** – If system parameters or the database connection file are missing or incorrect, the program stops and reports the issue.  
* **File access errors** – Problems opening the posting file or reading its contents cause the program to terminate with a descriptive message.  
* **Duplicate record handling** – When a posting already exists in the database, the program rewrites the record or, if the record cannot be updated, notes that it is being ignored.  
* **Database errors** – Any problem writing to MySQL (such as connection failures, write errors, or transaction problems) is reported, and the program stops further processing.  
* **Summary information** – At completion, the program prints counts of records read, records written, records rewritten, and log entries generated.  

#### User Flow Summary  
1. The user runs the program (typically from a script or batch job).  
2. The program reads system parameters and ensures a MySQL connection can be established.  
3. It opens the GL posting file and processes each record in turn.  
4. For each record, it attempts to insert the data into the MySQL posting table.  
   * If the record is new, it is written.  
   * If the record already exists, it is rewritten or ignored, and a note is logged.  
   * Any error during writing stops further processing and reports the issue.  
5. After all records are processed, the program commits the transaction (or rolls back if necessary).  
6. Finally, it outputs a summary of how many records were read, written, rewritten, and how many log entries were generated, then exits.  

#### Program Linkages  
- acas-get-params  
- acas006  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-main-start, performing argument parsing, system file opening, and loading RDB parameters. [Seen in: aa000-main-start.]  
It then opens the GL posting file and prepares to read records, entering the main processing loop at aa010-Read. [Seen in: aa010-Proc-Override.]  
Each posting record is written to the RDB via acas006-Write, with duplicate keys rewritten and errors logged, until EOF triggers aa999-Finish. [Seen in: aa010-Read.]

5.2 Initialization  
The program performs argument validation (zz020-Get-Program-Args), sets logging parameters, and opens the System-File to read configuration. [Seen in: aa000-main-start.]  
It loads RDB connection details from the system record or acas.param file, initializing variables and performing early exits on missing configuration. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: Entry to aa000-main-start after argument parsing.  
Key steps: Open System-File, read record 1, load RDB settings, call acas-get-params if needed.  
I/O: System-File.  
Outcomes: RDB parameters set; program may exit if missing.  
[Seen in: aa000-main-start.]

Path: Posting File Open  
Trigger: After system parameters are loaded, aa010-Proc-Override performs acas006-Open-Input.  
Key steps: Set file open flags, call acas006, check FS-Reply for EOF or errors, exit if file missing.  
I/O: System-File, posting file (via acas006).  
Outcomes: Posting file opened or program exits.  
[Seen in: aa010-Proc-Override.]

Path: Posting Record Processing  
Trigger: aa010-Read loop.  
Key steps: Read next posting record via acas006-Read-Next, write to RDB via acas006-Write, handle duplicate key or other errors, update counters, loop until EOF.  
I/O: posting file, RDB (via acas006-Write).  
Outcomes: Records transferred, duplicate rewrites counted, errors logged.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: Duplicate key detected in aa010-Read (SQL-State "23000" or FS-Reply 22/99 or SQL-Err 1062/1022).  
Key steps: Reset FS-Reply and WE-Error to zero, perform acas006-Rewrite, increment rewrite counter, continue loop.  
I/O: posting file, RDB.  
Outcomes: Duplicate record rewritten, rewrite counter incremented.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: Any FS-Reply not zero in aa010-Read or aa100-Check-4-Errors.  
Key steps: Log error messages via Call-Sysout, optionally rollback (aa020-Rollback), set return-code, exit loop.  
I/O: none specific; uses system file for logging.  
Outcomes: Program terminates with error status.  
[Seen in: aa010-Read, aa100-Check-4-Errors.]

Path: Finish  
Trigger: aa999-Finish after EOF or error exit.  
Key steps: Log record counts, close posting file and RDB via acas006-Close, close System-File, output final messages, goback.  
I/O: System-File, posting file, RDB.  
Outcomes: Program exits cleanly.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program closes all files, logs final counts, and performs a GOBACK to terminate. [Seen in: aa999-Finish.]  
No explicit commit is performed; rollback is invoked only on error paths. [Seen in: aa020-Rollback.]

---
## glpostingMT
*[81/267]*

### Business/Functional Perspective
### GL Posting Database Access  

**Program Purpose**  
The GL Posting handler manages the creation, retrieval, update and deletion of General Ledger posting records in the database. It opens a database connection, executes SQL commands, and returns the requested record and status information to the calling module. By centralising all GL‑post record access it ensures data integrity, prevents duplicate entries, and provides consistent error reporting across the accounting system.

**Screen Interactions**  
No user‑directed screens are displayed by this program. It is invoked by other modules after data entry has been completed and it supplies the results back to the calling context.

**Messages and Errors**  
- **No Data Found** – When a read operation returns no rows, the program reports “No Data” and indicates end‑of‑file.  
- **Duplicate Key** – Attempts to write a record that already exists generate a duplicate‑key message.  
- **Record Not Found** – If a requested key does not exist during a read‑indexed or delete operation, an “Invalid Key” status is returned.  
- **Database Error** – Any SQL or MySQL error results in an error status with a brief message such as “SQL error” and a description of the issue.  
- **End‑of‑File** – When all rows have been read, the program returns an EOF indicator.  
- **General Failure** – Unexpected or unspecified problems produce a generic failure status.

**User Flow Summary**  
1. The calling module prepares a GL posting record and specifies a file‑function code (e.g., 1=Open, 5=Write, 4=Read‑Indexed, 6=Delete‑All).  
2. The program opens a connection to the GL posting table (if not already open) and performs the requested SQL operation.  
3. For reads, it fetches the matching record and returns it along with a success status; for writes and deletes, it confirms the action or reports duplicates or missing keys.  
4. If the operation ends the data set (e.g., end‑of‑file after a read‑next loop) the program signals completion with a special status.  
5. The calling module receives the record (if any) and the status codes, and then continues its own workflow (display to the user, audit logging, or further processing).

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- MySQL_query

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program entry occurs in the **ba-ACAS-DAL-Process** section where the File-Function is evaluated to dispatch to a specific processing paragraph. [Seen in: ba-ACAS-DAL-Process.]  
The selected paragraph performs the requested database operation (open, close, read, write, delete, etc.) and sets FS-Reply, WE-Error, SQL-Err, SQL-Msg, and WS-File-Key accordingly. [Seen in: ba020-Process-Open.]  
After the operation, cleanup and logging are performed in **ba999-end** before exiting the program. [Seen in: ba999-end.]

5.2 Initialization  
On entry, **ba-ACAS-DAL-Process** accepts environment lines, sets screen exception handling, and clears error and status fields. [Seen in: ba-ACAS-DAL-Process.]  
The program then evaluates File-Function to determine the operation path. [Seen in: ba-ACAS-DAL-Process.]

5.3 Core Processing  

Path: **Process-Open**  
Trigger: File-Function = 1  
Key steps: Initialize MySQL connection parameters, perform MYSQL-1000-OPEN, set WS-File-Key to "OPEN GLPOSTING", set Most-Cursor-Set to zero.  
I/O: MySQL connection (ACASDB)  
Outcomes: FS-Reply set to 0 on success, WE-Error cleared, cursor inactive.  
[Seen in: ba020-Process-Open.]

Path: **Process-Read-Next**  
Trigger: File-Function = 3  
Key steps: If no cursor active, build WHERE clause for POST-KEY >= '0000000000', execute SELECT, store result, set cursor active; fetch first record; if no rows, set FS-Reply 10 and WE-Error 10.  
I/O: MySQL table GLPOSTING-REC, cursor TP-GLPOSTING-REC  
Outcomes: FS-Reply 0 on record fetched, WE-Error 0; if EOF, FS-Reply 10, WE-Error 10; WS-File-Key set to record key.  
[Seen in: ba040-Process-Read-Next, ba041-Reread.]

Path: **Process-Start**  
Trigger: File-Function = 9  
Key steps: Validate access-type, clear active cursor, build WHERE clause based on Access-Type relation, execute SELECT, set cursor active if rows found.  
I/O: MySQL table GLPOSTING-REC, cursor TP-GLPOSTING-REC  
Outcomes: FS-Reply 0 and WE-Error 0 if rows found; FS-Reply 21 if no rows; WS-File-Key contains key; cursor active for subsequent fetch.  
[Seen in: ba060-Process-Start.]

Path: **Process-Write**  
Trigger: File-Function = 5  
Key steps: Load HV fields from WS-Posting-Record, build INSERT statement, execute, check affected rows, handle duplicate key error.  
I/O: MySQL table GLPOSTING-REC  
Outcomes: FS-Reply 0 on success; FS-Reply 22 on duplicate key; WE-Error set accordingly; WS-File-Key set to key.  
[Seen in: ba070-Process-Write, bb200-Insert.]

Path: **Process-Delete-ALL**  
Trigger: File-Function = 6  
Key steps: Set key to maximum value, build DELETE WHERE clause, execute DELETE, handle errors.  
I/O: MySQL table GLPOSTING-REC  
Outcomes: FS-Reply 0 on success; FS-Reply 99 on error; WE-Error 995 on delete error; WS-File-Key set for logging.  
[Seen in: ba085-Process-Delete-ALL.]

Path: **Process-Rewrite**  
Trigger: File-Function = 7  
Key steps: Load HV fields, build UPDATE statement with WHERE key, execute, check affected rows, handle errors.  
I/O: MySQL table GLPOSTING-REC  
Outcomes: FS-Reply 0 on success; FS-Reply 99 on error; WE-Error 994 on update error; WS-File-Key set to key.  
[Seen in: ba090-Process-Rewrite, bb300-Update.]

5.4 Termination  
After each operation, **ba999-end** performs optional logging and exits the program. [Seen in: ba999-end.]  
The program ensures any active cursor is freed via **ba998-Free** before exiting. [Seen in: ba998-Free.]

---
## glpostingRES
*[82/267]*

### Business/Functional Perspective
### Posting File Backup  

**Program Purpose**  
The program creates a backup copy of the accounting posting data. It reads the sequential posting file and writes each record to a new file, preserving the data for later restoration. This activity safeguards the posting records against loss or corruption and supports compliance by providing an audit‑ready archive.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the source posting file is missing or cannot be opened, a notice is logged that no posting file was found.  
- Any error while opening the destination file is reported with a message indicating the failure.  
- Errors that occur while reading the source file are logged with a brief description.  
- Errors that occur while writing to the destination file result in a write‑error message.  
- Upon successful completion, the program logs the number of records read and the number of records written.  

**User Flow Summary**  
The user runs the program (typically via a scheduled job or manual start). The program attempts to open the source posting file. If the file is available, it reads each record and writes it to a new file, keeping a running count of records processed. Throughout the run, status messages are sent to the system log. When all records have been copied, the program logs the total records processed and exits.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins execution at paragraph aa000-Main-Start, where it retrieves command‑line arguments, configures logging parameters, and initiates file operations. [Seen in: aa000-Main-Start.]  
It then opens the sequential posting input file posting-File-Seq, checks for errors, opens the output posting file posting-File, and enters a loop to read and write records while counting them. [Seen in: aa000-Main-Start.]  
Upon reaching the end of the input file or encountering an error, control transfers to aa020-Finish-Off, where files are closed, a summary is logged, and the program exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The initialization phase performs zz020-Get-Program-Args to capture command‑line arguments, sets WS-Log-System and WS-Log-File-no, clears SO-Print, and logs the start message via Call‑Sysout. [Seen in: aa000-Main-Start.]  
It then opens posting-File-Seq for input, verifies FS-Reply, and if successful, opens posting-File for output, verifying FS-Reply again before proceeding to record processing. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read and Write Posting Records  
Trigger: Loop in aa010-Read-Recs until end of file or error.  
Key steps: Read next record from posting-File-Seq, check FS-Reply, increment WS-Rec-Cnt-In, write record to posting-File, check FS-Reply, increment WS-Rec-Cnt-Out.  
I/O: posting-File-Seq (input), posting-File (output).  
Outcomes: Counters updated, errors logged and cause transition to aa020-Finish-Off if FS-Reply non‑zero.  
[Seen in: aa010-Read-Recs.]  

Path: Finish-Off  
Trigger: End of input file or error causes go to aa020-Finish-Off.  
Key steps: Close posting-File-Seq and posting-File, compose summary message with record counts, log via Call‑Sysout, set Return-Code to zero, goback.  
I/O: posting-File-Seq, posting-File.  
Outcomes: Files closed, summary logged, program exits.  
[Seen in: aa020-Finish-Off.]  

Path: Open Input File Failure  
Trigger: FS-Reply non‑zero after opening posting-File-Seq.  
Key steps: Log "No Posting file to process", close posting-File (though not open), log close message, goback.  
I/O: posting-File-Seq.  
Outcomes: Program terminates early with error message.  
[Seen in: aa000-Main-Start.]  

Path: Open Output File Failure  
Trigger: FS-Reply non‑zero after opening posting-File.  
Key steps: Log "Failed on open - Posting file = " + FS-Reply, close posting-File, log close message, goback.  
I/O: posting-File.  
Outcomes: Program terminates early with error message.  
[Seen in: aa000-Main-Start.]  

Path: Read Error  
Trigger: FS-Reply non‑zero during read in aa010-Read-Recs.  
Key steps: Log SY003 + FS-Reply, call Call‑Sysout, go to aa020-Finish-Off.  
I/O: posting-File-Seq.  
Outcomes: Transition to Finish-Off, program exits after cleanup.  
[Seen in: aa010-Read-Recs.]  

Path: Write Error  
Trigger: FS-Reply non‑zero during write in aa010-Read-Recs.  
Key steps: Log SY006, call Call‑Sysout, go to aa020-Finish-Off.  
I/O: posting-File.  
Outcomes: Transition to Finish-Off, program exits after cleanup.  
[Seen in: aa010-Read-Recs.]

5.4 Termination  
The program concludes by closing any open files, logging a summary of records processed, setting Return-Code to zero, and exiting via goback. [Seen in: aa020-Finish-Off.]  
In error scenarios, it logs the appropriate error message, closes any open files, and exits immediately via goback. [Seen in: aa000-Main-Start.]

---
## glpostingUNL
*[83/267]*

### Business/Functional Perspective
### Posting File Backup

**Program Purpose**  
This program creates a backup of the current posting data by copying all records from the primary posting file to a new sequential file named *posting.seq*. The operation is logged so that the backup process can be audited and verified. By maintaining this backup, the system ensures data integrity and provides a quick restore point in case the original file becomes corrupted or is lost.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the primary posting file does not exist, the program reports “No posting file to process” and stops.  
- Errors while reading the posting file produce a message indicating a problem reading the file.  
- Write errors when creating *posting.seq* result in a message about a write error on the .seq file.  
- Upon completion, the program reports how many records were read and written.  
- If the required environment variables are not set, an abort message is issued.

**User Flow Summary**  
A user initiates the program (typically via command line or a scheduled task). The program attempts to open the existing posting file. If the file is found, it reads each record in turn and writes it to the sequential backup file *posting.seq*. Throughout the process, status and any issues are logged to *SYS‑DISPLAY.log*. When all records have been processed or an error occurs, the program closes both files, logs the total number of records handled, and exits. The user can then verify the backup by reviewing the log output.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa000-Main-Start, performing argument retrieval and initializing logging parameters. [Seen in: aa000-Main-Start.]  
It then opens the source posting file for input, handling missing file errors before proceeding. [Seen in: aa000-Main-Start.]  
After successfully opening the source, it opens the sequential output file and enters a loop in aa010-Read-Recs to copy each record. [Seen in: aa010-Read-Recs.]  
Upon reaching end‑of‑file or encountering an error, control transfers to aa020‑Finish‑Off to close files, report counts, and terminate. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020‑Get‑Program‑Args to capture command line parameters and sets logging system identifiers. [Seen in: aa000-Main-Start.]  
It initializes working‑storage counters to zero and prepares the SO‑Print buffer for status messages. [Seen in: aa000-Main-Start.]  
The posting‑File is opened for input, and if the status indicates failure, an error message is logged and the program exits. [Seen in: aa000-Main-Start.]  
The posting‑File‑Seq is then opened for output, ready to receive copied records. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Get Program Args  
Trigger: Program start  
Key steps: perform zz020‑Get‑Program‑Args; set logging identifiers.  
I/O: none.  
Outcomes: arguments stored, logging configured.  
[Seen in: aa000-Main-Start.]

Path: Open Posting File  
Trigger: after argument retrieval  
Key steps: open input posting‑File; check FS‑Reply; on error log and exit.  
I/O: posting‑File.  
Outcomes: file opened or program terminated.  
[Seen in: aa000-Main-Start.]

Path: Open Posting‑Seq File  
Trigger: after posting file opened  
Key steps: open output posting‑File‑Seq.  
I/O: posting‑File‑Seq.  
Outcomes: output file ready.  
[Seen in: aa000-Main-Start.]

Path: Read and Write Records  
Trigger: aa010‑Read‑Recs loop  
Key steps: read next record; if FS‑Reply not zero, log error and exit; increment input count; write record to posting‑File‑Seq; if FS‑Reply not zero, log error and exit; increment output count.  
I/O: posting‑File, posting‑File‑Seq.  
Outcomes: records copied, counts updated, possible early exit on error.  
[Seen in: aa010-Read-Recs.]

Path: Finish Off  
Trigger: aa020‑Finish‑Off  
Key steps: close posting‑File‑Seq and posting‑File; build summary string; log counts; log “CLOSE” message; set Return‑Code to zero; goback.  
I/O: posting‑File‑Seq, posting‑File.  
Outcomes: files closed, program exits.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program terminates by executing goback in aa020‑Finish‑Off after closing both files and logging the final record counts. [Seen in: aa020-Finish-Off.]  
No additional cleanup occurs beyond the file closures and final status message. [Seen in: aa020-Finish-Off.]

---
## irs
*[84/267]*

### Business/Functional Perspective
### IRS System Menu

**Program Purpose**  
The IRS system menu is the central control point for the accounting suite. It presents the user with a list of functions that manage dates, account and nominal set‑up, posting, trial balances, audit trails, production runs, and reporting. By selecting a function, the program invokes the appropriate processing module, ensuring that system parameters are current, backups are performed when required, and data integrity is maintained throughout the accounting cycle. The menu thus safeguards compliance, supports audit readiness, and reduces operational risk by coordinating all IRS‑related activities from a single interface.

**Screen Interactions**  
The program displays one screen, “IRS System Menu”, with the following elements:

| # | Screen Element | Description |
|---|----------------|-------------|
| 1 | Title line | “IRS System Menu” at the top, showing the run date from the system parameters. |
| 2 | Client & Dates | Client name, start date, and end date are shown in cyan, allowing the user to confirm the accounting period. |
| 3 | Function list | Keys 1‑9, A, and Z are listed with their corresponding actions: |
|   | 1 | Date Entry |
|   | 2 | Accounts Set‑Up & Maintenance |
|   | 3 | Default A/Cs Set‑Up & Maintenance |
|   | 4 | Posting |
|   | 5 | Trial Balance |
|   | 6 | Audit Trail |
|   | 7 | Accounts Production |
|   | 8 | Posting Amendments |
|   | 9 | Analysis Report |
|   | A | Nominal File Fix‑up |
|   | Z | System Set‑Up |
|   | X | Exit |
| 4 | Function‑key mapping | F1‑F10 correspond to options 1‑A; the Return key accepts data; Escape or X quits. |
| 5 | Status line | Displays OS name (Linux, Windows, Mac, etc.), any backup script status, and a copyright notice. |

**Messages and Errors**  
The program informs the user of the following conditions:

* **Startup Validation** – If the terminal window is shorter than 24 lines or narrower than 80 columns, a message is shown and the program terminates.  
* **Argument Errors** – If more than two command‑line arguments are supplied or the arguments are malformed, a clear error message appears and the program aborts.  
* **Environment Setup** – If required environment variables are missing, a message is displayed and the program exits.  
* **Backup Script Availability** – If no backup script is found in the user’s bin directory, the status line shows “No BackUp Script in Bin”.  
* **Module Processing Errors** – When a called module (e.g., irs000, irs010, …, irs090) encounters a failure, the module displays a short error such as “Error on … processing”. These messages are shown on the screen and the menu is redisplayed.  
* **Pre‑/Post‑Backup Notice** – When a pre‑backup script is run before an end‑of‑year process, the screen shows “Running Back up, prior to running EOY process”. A similar message appears for the post‑backup script.

**User Flow Summary**  
1. **Start** – The user runs the IRS program. The menu screen appears with current run, client, and date information.  
2. **Select Function** – The user presses a key (1‑9, A, Z, or the corresponding function key). The program validates the choice.  
3. **Execute Module** – The selected option invokes the appropriate IRS module (e.g., pressing “7” runs the production modules irs065 and irs060, with optional pre‑ and post‑backup scripts).  
4. **Backup Handling** – If backup scripts are available, the program runs them before or after the production run, displaying a short notice.  
5. **Return to Menu** – After the module completes (or aborts with an error), control returns to the menu screen, showing any updated system information.  
6. **Repeat or Exit** – The user can perform additional functions or press “X” (or Escape) to exit. Upon exit, the program writes any changed system parameters to the parameter file, runs a final backup script if present, and terminates cleanly.

**Program Linkages**  
- maps04  
- sys002  
- irs000  
- irs010  
- irs020  
- irs030  
- irs040  
- irs050  
- irs060  
- irs065  
- irs070  
- irs080  
- irs085  
- irs090  
- SYSTEM  (used to execute backup scripts)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by initializing the environment, reading command‑line arguments, and opening the ACAS system parameter file. [Seen in: irs-main section.]  
It then reads the system record, sets up IRS‑specific data structures, and may automatically invoke the date entry routine if the menu reply is “1”. [Seen in: aa010-Get-System-Recs.]  
The main loop displays the menu, dispatches user selections to the appropriate IRS subprograms, and loops until the user exits. [Seen in: Main-Loop.]

5.2 Initialization  
Environment variables for screen exceptions and escape handling are set, and the current date is loaded into working storage. [Seen in: irs-main section.]  
The ACAS system parameter file is opened for input, read into the system record, and then closed; the IRS system data is prepared via zz090‑Set‑Up‑IRS‑System‑Data. [Seen in: aa005-Open-System and aa010-Get-System-Recs.]

5.3 Core Processing  
Path: Auto‑Run Date Entry  
Trigger: Menu‑Reply = “1” at program start  
Key steps: Call irs000 to perform date entry, then update run date via zz090‑Proc‑Run‑Date.  
I/O: IRS‑System‑Params record, system param file.  
Outcomes: Run date updated in working storage, menu reply reset.  
[Seen in: aa010-Get-System-Recs.]

Path: Accounts Set‑Up (Option 2)  
Trigger: Menu‑Reply = “2” or F2 key  
Key steps: Call irs010 with IRS‑System‑Params, system record, and file definitions.  
I/O: IRS‑System‑Params, system record, file definitions.  
Outcomes: System parameters may be modified; control returns to main loop.  
[Seen in: Main-Loop.]

Path: Posting (Option 7)  
Trigger: Menu‑Reply = “7” or F7 key  
Key steps: Execute EOJ‑Pre backup, call irs065 (posting preparation), call irs060 (posting execution), execute EOJ‑Post backup, then return to main loop.  
I/O: System param file, backup scripts, IRS‑System‑Params, system record.  
Outcomes: Posting data processed, system record updated, backup scripts run.  
[Seen in: Main-Loop.]

Path: System Set‑Up (Option Z)  
Trigger: Menu‑Reply = “Z”  
Key steps: Open system param file, rewrite any changes, close, invoke sys002 to reconfigure parameters, then re‑open system and re‑setup IRS data.  
I/O: System param file, sys002 program.  
Outcomes: System parameters refreshed; IRS data reinitialized.  
[Seen in: Main-Loop.]

Path: End‑of‑Cycle (EOJ)  
Trigger: User selects exit (Menu‑Reply = “X” or Esc) or loop ends  
Key steps: Read and rewrite system param file, restore IRS data via zz095‑Restore‑IRS‑System‑Data, run backup script if present.  
I/O: System param file, backup script, IRS‑System‑Params.  
Outcomes: System record persisted, backup executed, program terminates.  
[Seen in: EOJ.]

Path: Trial Balance (Option 6)  
Trigger: Menu‑Reply = “6” or F6 key  
Key steps: Call irs050 which internally calls sorting program irs055, then return to main loop.  
I/O: IRS‑System‑Params, system record, file definitions, sorting program.  
Outcomes: Trial balance generated; system record unchanged.  
[Seen in: Main-Loop.]

5.4 Termination  
Upon exit, the program writes any pending changes to the system parameter file, runs the final backup script if configured, and performs GOBACK. [Seen in: EOJ-End.]  
The program then terminates cleanly, returning control to the operating system. [Seen in: EOJ-End.]

---
## irs000
*[85/267]*

### Business/Functional Perspective
### IRS Start Of Day

**Program Purpose**  
This program initializes the IRS processing for the current day. It collects the user’s current date and optional time, validates that the date is correct, and sets up the internal run‑date record. The result is a reliable start‑of‑day timestamp that supports accurate reporting, compliance checks, and downstream processing.

**Screen Interactions**  
1. **Header Screen** – Displays the client name, user name (if available), program name, and the text “IRS – Start Of Day”.  
   *Shows the current system time in the format “at hh:mm:ss” if a time is supplied.*  
2. **Date Entry Screen** – Prompts the user to enter today’s date in the format that matches the system setting:  
   - “Enter today’s date as dd/mm/yyyy – [          ]”  
   - “Enter today’s date as mm/dd/yyyy – [          ]”  
   - “Enter today’s date as yyyy/mm/dd – [          ]”  
   The user types the date into the field and submits it.

**Messages and Errors**  
- If the entered date is not in a valid format or represents an impossible calendar date, the program displays the message “IR005 Invalid Date” and returns the user to the date entry prompt.  
- Once a valid date is entered, the message area is cleared, indicating success.

**User Flow Summary**  
When the program starts, the user sees a header screen that lists the client, the program title, and an optional time stamp. The user then receives a prompt to enter the current date in the appropriate format. After submitting the date, the program checks its validity. If the date is invalid, an “Invalid Date” message appears and the user re‑enters the date. When a valid date is provided, the program clears any error messages, records the run date, and exits, allowing the next stage of the application to continue with a confirmed start‑of‑day timestamp.

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **main** paragraph, setting screen exception flags, initializing dates, and displaying the header screen. [Seen in: main.]  
It then enters the **date-entry** paragraph where the user is prompted for today’s date, which is converted to the standard UK format and validated by calling **maps04**. [Seen in: date-entry.]  
Upon successful validation, the program proceeds to **chain-menu** to set run‑date variables and then exits via **main-exit**. [Seen in: chain-menu.]

5.2 Initialization  
The **main** paragraph sets screen exception handling, moves the passed‑in `to-day` to `u-date`, accepts the system date, and displays client and program information. [Seen in: main.]  
It also displays the current time if available and prepares the date entry prompt based on the configured `Date-Form`. [Seen in: main.]

5.3 Core Processing  
Path: Date Entry  
Trigger: User enters a date at the prompt in **date-entry**.  
Key steps: display prompt, accept `u-date`, convert to UK form, call `maps04` to validate.  
I/O: none (internal conversion and call).  
Outcomes: sets `u-bin`; if zero, error displayed and loop back to date-entry.  
[Seen in: date-entry.]

Path: Invalid Date  
Trigger: `maps04` returns `u-bin = 0`.  
Key steps: display `IR005` error, go to **date-entry** to re‑prompt.  
I/O: none.  
Outcomes: user re‑enters date.  
[Seen in: date-entry.]

Path: Valid Date  
Trigger: `maps04` returns `u-bin > 0`.  
Key steps: clear error display, proceed to **chain-menu**.  
I/O: none.  
Outcomes: `Run-Date` and `to-day` set, program ready to exit.  
[Seen in: chain-menu.]

Path: Chain Menu  
Trigger: Successful date validation.  
Key steps: move `u-bin` to `Run-Date`, move `u-date` to `to-day`.  
I/O: none.  
Outcomes: variables set for downstream use, program exits.  
[Seen in: chain-menu.]

Path: Exit  
Trigger: Execution reaches **main-exit**.  
Key steps: `exit program`.  
I/O: none.  
Outcomes: program terminates.  
[Seen in: main-exit.]

5.4 Termination  
The program terminates by executing the **main-exit** paragraph, which performs a `exit program`. [Seen in: main-exit.]  
No additional cleanup is performed beyond this exit. [Seen in: main-exit.]

---
## irs010
*[86/267]*

### Business/Functional Perspective
### Chart of Accounts Utilities  

#### Program Purpose  
This program lets users manage the Chart of Accounts (CoA) for a client.  
From the menu users can create a new CoA, add or edit existing accounts, view a list of accounts, print the list to a report, export the CoA to a file for backup, or import a new CoA from a text file. The tool validates input, prevents duplicate account keys, and protects against accidental data loss by confirming overwrites.  

#### Screen Interactions  

1. **Accounts File Utilities Menu** – shows the six main functions (Setup, Amend, Display, Print, Export, Import) and a “Return to System Menu” option. Users type a number or press F1‑F6 to choose.  

2. **Chart of Accounts Setup Screen** – displays client and date range, then asks “Add to Existing Chart (Y/N) ?”. Choosing **N** starts a clean chart; choosing **Y** appends to the current chart.  

3. **Chart of Accounts Amend Screen** – header “Chart of Accounts Amendments” followed by the standard account entry form (main account, sub‑account, description, type).  

4. **Chart of Accounts Display Screen** – lists all accounts page by page. At the bottom the user can press **N** for the next page or **X** to quit back to the menu.  

5. **Export Warning Screen** – informs the user that the current CoA will be written to a file, warns that a new export will overwrite any existing file, and asks for confirmation (Y/N).  

6. **Export File Prompt** – after confirmation, the user enters the desired file name and selects the format (Text or Comma‑delimited).  

7. **Import Warning Screen** – informs the user that a new CoA will overwrite the current chart, warns that the operation is irreversible, and asks for confirmation (Y/N).  

8. **Import File Prompt** – after confirmation, the user enters the name of the text file to import.  

#### Messages and Errors  
- **Duplicate key** – If an account number already exists, the screen flashes “Record already exists re‑enter!” and the user must supply a different key.  
- **Missing data** – If a required field (e.g., main account, description) is left blank, the program returns to the input field and prompts the user to correct it.  
- **File operation errors** – When a file cannot be opened, written to, or closed, a simple error message is shown (e.g., “Problem opening Export File…”) and the user is returned to the menu.  
- **Import format error** – If the selected file is not a text file, the program displays an error and aborts the import.  
- **Cancellation** – Pressing the escape key or selecting the “Return to System Menu” option immediately takes the user back to the main system menu.  

#### User Flow Summary  
1. The user starts the program and sees the menu of utilities.  
2. Selecting **1 (Setup)** opens the setup screen where the user confirms whether to start fresh or append to the existing chart. The user then enters each account’s main number, optional sub‑account, description, and type; the program validates uniqueness and writes the record.  
3. Choosing **2 (Amend)** displays the same entry form but allows editing or deleting existing accounts. The user can change any field, delete an account, or add new ones.  
4. Option **3 (Display)** lists all accounts on screen, page by page, and lets the user scroll through with **N** or exit with **X**.  
5. Option **4 (Print)** writes the entire chart to a printer file, showing page headers and a count of records.  
6. Option **5 (Export)** prompts the user to confirm overwriting, choose a file name, and select format (text or comma‑delimited). The program writes the chart to the file and reports the total records written.  
7. Option **6 (Import)** warns the user that the current chart will be replaced. After confirmation, the user supplies the name of a text file. The program reads each record, determines whether it is a main or sub‑account, and writes it to the chart, reporting the total records created.  
8. Selecting **9** or pressing escape returns the user to the overarching system menu.  

#### Program Linkages  
- CBL_CHECK_FILE_EXIST  
- SYSTEM   (used to invoke the system print routine)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program enters procedure division, initializes environment, then enters main loop displaying menu and awaiting user input. [Seen in: inita.]  
Based on the menu reply or function key, the program performs one of the six functional sections: set‑up, amend, show, listing, export, or import. [Seen in: main01-loop.]  
After completing the selected section, control returns to the main loop until the user chooses to exit, at which point the program terminates. [Seen in: main01-exit.]

5.2 Initialization  
The inita section sets screen exception flags, accepts environment line count, records current time, and checks the First‑Time‑Flag to possibly clear existing chart data. [Seen in: inita.]  
If First‑Time‑Flag is zero, the program calls zz000‑clear‑NL to prompt the user and, if confirmed, clears all amounts from the nominal ledger before proceeding to the menu. [Seen in: zz000-clear-NL section.]

5.3 Core Processing  
Path: Set‑Up Chart of Accounts  
Trigger: User selects option 1 or presses F1. [Seen in: main01-loop.]  
Key steps: Display Setup‑Screen‑1, accept Setup‑Screen‑2Q, open nominal ledger via acasirsub1‑Open, display Setup‑Amend‑Screen‑3, perform setup‑display, loop inputting new records (input02‑loop), write each record with acasirsub1‑Write, and close the ledger. [Seen in: set‑up section, main02, main02-loop, main02-output, main02-exit.]  
I/O: Nominal ledger file. [Seen in: set‑up section.]  
Outcomes: New chart records are written and the ledger is closed, ready for further operations. [Seen in: set‑up section.]

Path: Amend Chart of Accounts  
Trigger: User selects option 2 or presses F2. [Seen in: main01-loop.]  
Key steps: Display Amend‑screen‑1 and Setup‑Amend‑Screen‑3, open nominal ledger, loop reading existing records (input03‑loop), allow delete, modify, or add new entries, write or rewrite records via acasirsub1‑Write or acasirsub1‑Rewrite, and close the ledger. [Seen in: amend section, main03, main03-loop, main03-output, main03-exit.]  
I/O: Nominal ledger file. [Seen in: amend section.]  
Outcomes: Existing chart entries are updated, added, or removed as requested. [Seen in: amend section.]

Path: Show Chart of Accounts  
Trigger: User selects option 3 or presses F3. [Seen in: main01-loop.]  
Key steps: Open nominal ledger for input, display header, loop reading records (main04-loop), display each record on screen, wait for user to continue or exit. [Seen in: show section, main04, main04-loop, main04-display, main04-exit.]  
I/O: Nominal ledger file. [Seen in: show section.]  
Outcomes: The chart is presented to the user on the screen. [Seen in: show section.]

Path: Listing (Print) Chart of Accounts  
Trigger: User selects option 4 or presses F4. [Seen in: main01-loop.]  
Key steps: Open nominal ledger for input, open print‑file, loop reading records, write formatted lines to print‑file, close files, invoke system print. [Seen in: listing section, main04, main04-loop, listing section.]  
I/O: Nominal ledger file, print‑file. [Seen in: listing section.]  
Outcomes: A printable file containing the chart is generated. [Seen in: listing section.]

Path: Export Chart of Accounts  
Trigger: User selects option 5 or presses F5. [Seen in: main01-loop.]  
Key steps: Display warning, obtain file name and format, open output export file, open nominal ledger for input, loop reading records, write each record to export file in text or comma format, close files. [Seen in: ea‑Export‑CoA section, ea020‑Open‑Output, ea010‑Warning‑Notice, ea020‑Open‑Output.]  
I/O: Nominal ledger file, Saved‑CoA (output). [Seen in: ea‑Export‑CoA section.]  
Outcomes: Export file containing the chart is created. [Seen in: ea‑Export‑CoA section.]

Path: Import Chart of Accounts  
Trigger: User selects option 6 or presses F6. [Seen in: main01-loop.]  
Key steps: Display warning, obtain file name, open input export file, open nominal ledger for output, loop reading input file, write each record to ledger, close files. [Seen in: fa‑Import‑CoA section, fa020‑Open‑Files, fa030‑Read‑Input, fa040‑End‑Of‑Input.]  
I/O: Saved‑CoA (input), nominal ledger file. [Seen in: fa‑Import‑CoA section.]  
Outcomes: The nominal ledger is populated with the imported chart. [Seen in: fa‑Import‑CoA section.]

Path: Clear NL (First‑time clear)  
Trigger: First‑Time‑Flag zero and menu‑reply = "0" during main loop. [Seen in: main01-loop.]  
Key steps: Check for existence of CoA and posting files, prompt user, open nominal ledger, loop reading each record, set all amount fields to zero, rewrite record, close ledger. [Seen in: zz000‑clear‑NL section, zz020‑Read‑A‑Record, zz030‑Exit.]  
I/O: Nominal ledger file. [Seen in: zz000‑clear‑NL section.]  
Outcomes: All amounts in the chart are cleared, leaving a clean chart. [Seen in: zz000‑clear‑NL section.]

5.4 Termination  
When the user selects option 9 or presses Escape, the program exits the main loop and performs a GOBACK to terminate. [Seen in: main01-exit.]  
All open files are closed by their respective sections before program exit. [Seen in: main01-exit.]

---
## irs020
*[87/267]*

### Business/Functional Perspective
### Posting Defaults Management  

**Program Purpose**  
This program lets a user define, change, view, and print the set of posting default accounts used by the accounting system. It ensures that the necessary chart of accounts exists, that the key default accounts (30‑32) are assigned, and that final accounts are properly set up. By maintaining these defaults the system can post transactions consistently, support audit trails, and reduce the risk of posting errors.

**Screen Interactions**  

1. **Menu Screen** – Shows program title, client name, run‑date, start‑ and end‑dates, and a list of numbered options:  
   * 1 Set‑Up Default Accounts  
   * 2 Amend Default Accounts  
   * 3 Display Defaults  
   * 4 Print Defaults  
   * 5 Set‑Up Final Accounts  
   * 9 Return to System Menu  
   Users press a function key (F1‑F5) or type the corresponding number. Esc exits.

2. **Setup Header Screen** – Displays the same header information plus the title “Default Accounts Setup”.  
   * No input on this screen.

3. **Add‑to‑Existing Defaults Prompt** – Asks “Add to Existing Defaults (Y/N) ?” with a single‑character Y/N input.  
   * N means the program will initialise new defaults; Y keeps any existing defaults.

4. **Account Entry Screen (Setup‑Amend‑Screen‑3)** – Lists account numbers 1‑16 and 17‑32 side‑by‑side.  
   * For each account the user can enter:  
     * Account number (must be > 0)  
     * Posting code (two letters)  
     * VAT flag (I, N, or O)  
   * The screen highlights the current row; the user navigates with the cursor.

5. **Display Screen** – Shows the full list of default accounts with number, description, posting code, and VAT flag.  
   * The user can press Enter to return to the menu.

6. **Finished Accounts Setup Screen** – Provides a field for the “P & L Appropriation Account” and a list of finished account headings with signs.  
   * The user enters the account number for the appropriation account.

**Messages and Errors**  
The program informs the user of the following situations:  

- *Invalid or missing account number*: the user is prompted to re‑enter.  
- *Missing chart of accounts*: a message indicates that the chart must be created first.  
- *Default accounts 30‑32 not defined*: the user is warned that these must be set before proceeding.  
- *Sub‑program errors*: a generic “error on processing” message is shown with a code; the user is asked to retry or exit.  
- *End of listing*: when a displayed list finishes, a prompt lets the user press Enter to return to the menu.  
- *Successful completion*: no explicit success message, but the program returns to the menu after each action.

**User Flow Summary**  
When the program starts, the user sees the menu screen and selects a function.  

- *Set‑Up*: the program asks whether to keep existing defaults. It then displays the account entry screen, where the user inputs account numbers, posting codes, and VAT flags for all 32 default accounts. After validation, the defaults are written and the program returns to the menu.  
- *Amend*: the user selects an account number to change; the same entry screen is shown with the current values pre‑filled, allowing edits. The new data are written and the program returns to the menu.  
- *Display*: the program shows a read‑only list of all current defaults; pressing Enter returns to the menu.  
- *Print*: a print job is generated, sending the default list and finished account data to the spool. After the print completes, control returns to the menu.  
- *Set‑Up Final Accounts*: the user specifies the P & L appropriation account and, if needed, edits finished account headings. The data are written and the program returns to the menu.  
Choosing option 9 or pressing Esc exits the program back to the main system menu.

**Program Linkages**  

- SYSTEM (for printing the report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program enters init01, sets screen exception flags, copies print‑spool‑name to PSN, and sets File‑Key‑No to 1 before entering main-loop. [Seen in: init01.]  
In main-loop, menu‑screen‑1 is displayed and user input determines dispatch to Set‑Up, Amend, Show, Listing, or Set‑Up‑Finished based on menu‑reply or function keys. [Seen in: main-loop.]  
After executing the chosen routine, control returns to main-loop until the user selects exit, at which point the program performs goback. [Seen in: main01-exit.]

5.2 Initialization  
init01 sets screen exception flags, copies print‑spool‑name to PSN, and sets File‑Key‑No to 1. [Seen in: init01.]  
It then enters main-loop after initializing menu‑reply to zero. [Seen in: init01.]

5.3 Core Processing  

Path: Set‑Up  
Trigger: menu‑reply = 1 or Cob‑Crt‑Status = Cob‑Scr‑F1.  
Key steps: display Setup‑Screen‑1, accept Setup‑Screen‑2Q, decide to file‑init or not, display Setup‑Amend‑Screen‑3, loop to get input for accounts 1‑16, call acasirsub1‑Read‑Indexed for code, accept codes and VAT, write defaults via acasirsub3‑Write, check defaults 30‑32, then perform amend.  
I/O: acasirsub1 (read indexed), acasirsub3 (write), acasirsub1 (close).  
Outcomes: defaults written, if missing 30‑32 displayed error, then enters amend mode.  
[Seen in: Set-Up-Main.]

Path: Amend  
Trigger: menu‑reply = 2 or Cob‑Crt‑Status = Cob‑Scr‑F2.  
Key steps: display Amend‑Screen‑1, display Setup‑Amend‑Screen‑3, loop to get input for account number, read indexed, accept new code and VAT, write defaults, close files.  
I/O: acasirsub1‑Read‑Indexed, acasirsub3‑Write, acasirsub1‑Close.  
Outcomes: defaults updated.  
[Seen in: amend.]

Path: Set‑Up‑Finished  
Trigger: menu‑reply = 5 or Cob‑Crt‑Status = Cob‑Scr‑F5.  
Key steps: read next final account record via acasirsub5‑Read‑Next, open nominal input, accept Finished‑Account‑Setup‑Screen‑1, if PL‑Approp‑AC set, read indexed, write final via acasirsub5‑Write, close nominal.  
I/O: acasirsub5‑Read‑Next, acasirsub1‑Open‑Input, acasirsub1‑Read‑Indexed, acasirsub5‑Write, acasirsub1‑Close.  
Outcomes: final accounts written, PL‑Approp‑AC set.  
[Seen in: Set-Up-Finished.]

Path: Show  
Trigger: menu‑reply = 3 or Cob‑Crt‑Status = Cob‑Scr‑F3.  
Key steps: display Display‑Screen‑1, Setup‑Amend‑Screen‑3, input headings, accept ws‑reply to continue, close nominal via acasirsub1‑Close.  
I/O: acasirsub1‑Close.  
Outcomes: screen displayed, nominal closed.  
[Seen in: Show.]

Path: Listing  
Trigger: menu‑reply = 4 or Cob‑Crt‑Status = Cob‑Scr‑F4.  
Key steps: clear screen, set date/time, open print‑file, open nominal input, write report headers, loop over 1‑32 to write defaults, close nominal, open final accounts, write finished accounts report, close print‑file, call SYSTEM to spool.  
I/O: print‑file, acasirsub1‑Open‑Input, acasirsub3‑Read‑Next, acasirsub5‑Read‑Next, acasirsub1‑Close, print‑file close, SYSTEM call.  
Outcomes: report printed.  
[Seen in: listing.]

5.4 Termination  
Each routine ends with an exit statement that returns control to main-loop or main01-exit. [Seen in: main01-exit.]  
The program terminates by executing goback in main01-exit, returning control to the caller. [Seen in: main01-exit.]

---
## irs030
*[88/267]*

### Business/Functional Perspective
### Transaction Posting  

**Program Purpose**  
The program enables users to record and manage accounting postings for a company’s general ledger.  From a single screen it allows the user to view default account sets, add new postings (debited or credited amounts, VAT, narratives) and update the underlying account balances.  It guarantees that postings are correctly typed, that VAT is calculated, and that balances are updated atomically, thereby supporting audit trails, compliance, and risk control.  

**Screen Interactions**  
1. **Heading‑Screen** – Displays the title “Transaction Posting” and the menu:  
   * `<99>`  Display Existing Defaults  
   * `<88>`  Add to Existing Postings  
   * `<77>`  Clear Existing Postings  
   * `<66>`  Add PL or SL Postings from File  
   * `<Return>`  Exit to System Menu  
   The user types the chosen option number.  

2. **Default Accounts Display** – Shows a table of default account numbers, descriptions, VAT codes, and associated account numbers.  The list is scrollable and each row can be inspected for details.  

3. **Posting Entry Screen** – For each new posting the user is prompted for:  
   * Date (validated to a correct calendar date)  
   * Account number (must exist and not equal the default account)  
   * Narrative (optional)  
   * Amount (numeric; negative values allowed for reverse entries)  
   * VAT code – “P” (percent), “M” (fixed), or blank for no VAT  
   The screen also displays the running totals for the batch (net, VAT, and overall posting total).  A `<F3>` key can be used to cycle back to the defaults screen during entry.  

**Messages and Errors**  
- **Validation Errors** – Non‑numeric amounts, invalid dates, account numbers that do not exist, or attempting to post to the default account itself.  
- **VAT Errors** – Missing or invalid VAT account definitions, or attempting to post to an account that is not a VAT account.  
- **System Errors** – Failures to open or read the posting or nominal ledger files, or internal processing errors (shown with a concise message and a prompt to press Return).  
- **Confirmation Messages** – After posting completion, a message indicates the number of records processed and asks whether the temporary posting file should be cleared.  

**User Flow Summary**  
1. The user runs the program and is presented with the heading screen.  
2. By entering **99** the user can view the existing set of default accounts.  
3. By entering **88** the user selects a default account number (1‑33).  The program shows the details for that default, verifies VAT accounts, and prompts the user for posting characteristics (Debit/Credit).  
4. The user then enters a series of postings: each iteration requests a date, an account number, a narrative, an amount, and optionally a VAT code.  The program validates each entry, updates running totals, and writes the posting record to an internal file while also adjusting the ledger balances in real time.  
5. When the user enters a blank date or selects `<Return>` from the heading screen, the posting batch ends.  Totals are displayed, the posting file is closed, and the program returns to the main menu.  
6. Alternative options: **66** loads and posts a pre‑prepared file of postings; **77** clears all existing postings; **Return** exits to the overall system menu.  

**Program Linkages**  
- scr_dump  
- scr_restore  
- CBL_DELETE_FILE

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by performing initialization in Init-Main section, opening necessary files and validating VAT accounts. [Seen in: Init-Main section.]  
The main menu loop displays options and accepts a run option, branching to actions such as showing defaults, clearing postings, adding postings, or exiting. [Seen in: Main-Loop.]  
When a default number is entered, Get-Default retrieves the default account record, validates it, and sets up posting parameters before proceeding to the posting input loop. [Seen in: Get-Default.]  
The posting input loop (Input-Loop) collects date, account, narrative, amount, and VAT information, performs calculations, updates account balances, and writes posting records. [Seen in: Input-Loop.]  
After all postings are entered, End-Batch finalizes totals, updates the nominal ledger, closes files, and returns to the main menu. [Seen in: End-Batch.]

5.2 Initialization  
Init-Main sets screen exception flags, reads terminal line count, and initializes screen dimensions. [Seen in: Init-Main section.]  
It then opens the default account file and verifies that VAT accounts 31 and 32 exist, aborting if not. [Seen in: Init-Main section.]  
The VAT rates are loaded into WS-Vat-Rates from the system record, and the COA search table is populated from the nominal ledger. [Seen in: Init-Main section.]  
If any errors are found during initialization, the program exits to the system menu. [Seen in: Init-Main section.]

5.3 Core Processing  
Path: Display Defaults  
Trigger: w = 99  
Key steps: perform Show-Default, display default screen, wait for return.  
I/O: none.  
Outcomes: sets up default display.  
[Seen in: Main-Loop, Show-Default section.]

Path: Clear Existing Postings  
Trigger: w = 77  
Key steps: perform file-init, if reply not Z, set next-post to zero, get-default.  
I/O: file-init opens posting file.  
Outcomes: clears posting file, resets next-post.  
[Seen in: Main-Loop, file-init section.]

Path: Add PL or SL Postings  
Trigger: w = 66  
Key steps: perform Ledger-Postings-Add.  
I/O: opens posting file, reads SL/PL posting file, updates nominal ledger, writes posting records.  
Outcomes: updates ledger and posting file.  
[Seen in: Main-Loop, Ledger-Postings-Add section.]

Path: Posting Input  
Trigger: default selected and posting loop.  
Key steps: set up posting parameters, loop over Input-Loop collecting data, calculate VAT, update balances, write posting record.  
I/O: acasirsub1 (read/write nominal), acasirsub4 (write posting).  
Outcomes: updated balances, posting record written.  
[Seen in: Get-Default, Input-Loop, Input-End-1.]

Path: End Batch  
Trigger: post-date empty or F3.  
Key steps: finalize totals, update nominal ledger for default and VAT accounts, close posting file, return to main loop.  
I/O: acasirsub1 (rewrite nominal), acasirsub4 (close).  
Outcomes: totals displayed, posting file closed.  
[Seen in: End-Batch.]

5.4 Termination  
On exit, Main-Exit performs a GOBACK, returning control to the system menu. [Seen in: Main-Exit.]  
All open files are closed by the respective subroutines before the program terminates. [Seen in: End-Batch, Ledger-Postings-Add section.]

---
## irs040
*[89/267]*

### Business/Functional Perspective
### Trial Balance Display  

#### Program Purpose  
This program generates a trial‑balance report for the accounting system. It allows the user to choose a summary or detailed view, decide whether to include zero balances, and select display or print output. The report shows all account balances, totals, and a brief summary of any sub‑account activity. By providing a clear audit trail of debits and credits, the program supports financial integrity and compliance.

#### Screen Interactions  
1. **Initial prompt** – The screen shows the program title, the current date, and the following input fields:  
   - “Summary or Detail <S> or <D>…” – enter **S** for summary or **D** for detail.  
   - “Zero balances to Print (Y/N)…” – enter **Y** to include zero balances or **N** to omit them.  
   - “Press Return to exit” – pressing Enter exits the program.  
   - “Display or Print <D> or <P>…” – enter **D** to view the report on the screen or **P** to print it.  
2. **Report display** – The screen lists each account with its name, debit, and credit amounts. After each page the following message appears:  
   - “Enter <N> for next screen <X> to exit…” – **N** advances to the next page, **X** ends the report.  
3. **Totals page** – Shows the total debits and credits, the count of sub‑account lines, and the message “IR040 End of listing. Hit return for Menu.” – pressing Return returns to the main menu.  

#### Messages and Errors  
- If the program cannot read accounting data, it stops and shows a message indicating a data‑access error, then returns to the menu.  
- If the print spool cannot be written to, a message is displayed explaining the printing failure, and the program returns to the menu.  
- Any unexpected errors during processing are reported with a generic error message and the program exits to the menu.  

#### User Flow Summary  
1. The user runs the trial‑balance program.  
2. They choose whether to view a summary or a detailed list of accounts, whether to include accounts with zero balances, and whether to display the report on the screen or print it.  
3. The program reads the accounting records, calculates totals, and shows each page of the report.  
4. The user can view successive pages by pressing **N** or finish by pressing **X**.  
5. After the final totals are displayed, the user presses Return to return to the main menu. If printing was selected, the report is sent to the printer or spool.  

#### Program Linkages  
- `SYSTEM` (used for print spool command)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins in the **init01** section, performs environment setup and displays the initial menu prompting for summary/detail, zero balance preference, and output type. [Seen in: init01 section.]  
Based on the user's output choice, the program branches to either **display-tb** for on‑screen display or **print-tb** for generating a printed report. [Seen in: run-loop.]  
After completing the chosen path, control returns to the run‑loop to allow another run or exit. [Seen in: total-display.]

5.2 Initialization  
The **init01** section accepts terminal line count, sets environment exceptions, captures current time, and displays the program header and input prompts. [Seen in: init01 section.]  
It initializes key variables such as totals, page counters, and flags before entering the main run‑loop. [Seen in: init01 section.]

5.3 Core Processing  

Path: System Setup  
Trigger: Program start  
Key steps: accept environment lines, set environment exceptions, accept time, display header, prompt for summary/detail, zero balance preference, and output type.  
I/O: none  
Outcomes: sets `tipe`, `empty`, `output-reply`, and determines next paragraph.  
[Seen in: init01 section.]

Path: Display  
Trigger: `output-reply = "D"`  
Key steps: perform `acasirsub1-Open-Input`, initialize totals, set page, display headers, loop `main-loop`, process records, display lines, handle paging, invoke `total-display`, close input file.  
I/O: `acasirsub1-Open-Input`, `acasirsub1-Read-Next`, `acasirsub1-Close`  
Outcomes: displays trial balance, updates totals, may exit to run‑loop.  
[Seen in: display-tb.]

Path: Print  
Trigger: `output-reply = "P"`  
Key steps: open `print-file`, perform `headings`, open input, loop `main-loop-p`, write lines to print file, write totals, close file, call `SYSTEM` to print.  
I/O: `print-file`, `acasirsub1-Open-Input`, `acasirsub1-Read-Next`, `acasirsub1-Close`  
Outcomes: generates printed report, returns to run‑loop.  
[Seen in: print-tb.]

Path: Total Display  
Trigger: end of record processing or user requests exit  
Key steps: display totals, display sub‑not count, accept reply, close input file.  
I/O: `acasirsub1-Close`  
Outcomes: shows totals, returns to run‑loop.  
[Seen in: total-display.]

Path: Program Exit  
Trigger: user presses Return at initial prompt or after total display  
Key steps: exit program.  
I/O: none  
Outcomes: program terminates.  
[Seen in: main01-exit.]

5.4 Termination  
The program exits via the **main01-exit** paragraph, which performs a GOBACK to terminate execution. [Seen in: main01-exit.]  
No additional cleanup is performed beyond closing any open files in the respective processing paths. [Seen in: total-display, main-end.]

---
## irs050
*[90/267]*

### Business/Functional Perspective
### Posting Report Generation  

**Program Purpose**  
The program produces posting‑based financial reports for the accounting system. It allows the user to generate an audit trail, a VAT day‑book, or ledger summaries, view them on screen or print them to a spool file. By sorting the data in code, date, or transaction number order and applying appropriate VAT calculations, the program ensures accurate, audited records that support compliance and internal financial control.  

**Screen Interactions**  
1. **Main Menu** – Displays a menu with the following options and prompts:  
   - **Report type**: (A)‑Audit Report, (L)‑Ledgers, (D)‑VAT Day Book.  
   - **Output mode**: Press <D> to view on screen or <P> to print.  
   - **Sort order**: (1) Code order, (2) Date order, (3) Transaction number order.  
   - Exit by pressing <RETURN> on the “Input Report required by letter… ” prompt.  

2. **Ledger Account Prompt** – When “Ledgers” is chosen, the screen asks: “Enter account code required (zero for all)… [     ]”.  

3. **Display/Print Screen** – Shows a header line, followed by rows of transaction details (date, code, account, debit/credit, net amount, VAT, etc.).  
   - At the bottom, a message “Press return to continue or Esc to quit” appears.  
   - The user can press <RETURN> to see the next page or <ESC> to return to the main menu.  

**Messages and Errors**  
- **No data** – “No Posting data present” appears when no postings exist for the selected period.  
- **Sorting or file access errors** – General error messages such as “Error on systemMT processing” or “Error on irsnominalMT processing” are displayed when the underlying sort or data‑read modules fail.  
- **Invalid input** – If non‑numeric characters are entered for dates or account codes, the program re‑prompts the user for correct input.  
- **Exit** – “Press <RETURN> to exit” or “Return for next screen or <X> to exit” messages indicate that the user can leave the program.  

**User Flow Summary**  
1. The user launches the program and sees the main menu.  
2. They type a letter to choose the report type: Audit, Ledger, or VAT Day Book.  
3. They select whether to display the report on screen (D) or print it (P).  
4. They pick a sort order (code, date, or transaction number).  
5. If Ledgers were chosen, they are prompted for an account code; entering zero lists all ledgers.  
6. The program sorts the postings, gathers the required data, and either prints the report or displays it page by page.  
7. While viewing, the user can press <RETURN> to advance pages or <ESC>/<X> to return to the main menu or exit.  
8. After printing, a spool command is issued to the system to produce the physical report.  

**Program Linkages**  
- `irs055`  
- `irsubp`  
- `SYSTEM` (Print-Report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in main-flow, initializing screen parameters, reading system dates, and calling acasirsub3 to load default parameters. [Seen in: main-flow.]  
It then enters the run-loop, presenting a menu of report types and capturing user choice in tipe. [Seen in: run-loop.]  
Depending on the selected tipe, the program may prompt for a date range, output mode, and sort sequence before invoking proceed-run to open posting data. [Seen in: date-select, output-select, sort-select, proceed-run.]  
If the user selects ledgers, ledger-report is executed; otherwise, the program performs either a display-report or report-print based on the output-reply. [Seen in: ledger-report, display-report, report-print.]  
After completing the chosen report, control returns to run-loop for another iteration until the user exits by pressing return at the tipe prompt. [Seen in: run-loop-accept, main99-exit.]

5.2 Initialization  
The program accepts environment lines to determine terminal size, sets screen exception flags, and captures the current time into hdtime. [Seen in: main-flow.]  
It moves the print spool name to PSN, sets file-function to 3 to read the next default record, and performs acasirsub3 to load defaults. [Seen in: main-flow.]  
Variables such as total-in-net, total-in-vat, total-out-net, total-out-vat, total-dr, total-cr are initialized to zero at the start of each run-loop iteration. [Seen in: run-loop.]  
The program displays the main menu and prompts for report type, initializing tipe and output-reply to spaces. [Seen in: run-loop.]

5.3 Core Processing  
Path: Menu Dispatch  
Trigger: User enters a report type (tipe) at run-loop-accept.  
Key steps: Accept tipe, validate, if not valid go back to run-loop; if vat-report skip output-select; otherwise go to output-select; then date-select, sort-select, proceed-run; then open postings; then choose display or print; then loop.  
I/O: None (screen only).  
Outcomes: sets tipe, output-reply, sort-sequ, period dates, leads to report generation.  
[Seen in: run-loop-accept, date-select, output-select, sort-select, proceed-run, display-report, report-print.]

Path: Ledger Report  
Trigger: tipe = "L" (ledgers selected).  
Key steps: ledger-report sets counter, opens posting file, prompts for account code, reads postings via get-postings, displays or prints ledger lines, totals, and closes.  
I/O: posting file (via acasirsub1), print-file if output-reply = "P".  
Outcomes: ledger report displayed or printed, totals computed.  
[Seen in: ledger-report, start-ledgers, get-postings, main-loop, main-exit.]

Path: Display Report  
Trigger: output-reply = "D" after proceed-run.  
Key steps: display-report initializes counter, prompts for use-code if audit, sets page, displays headers, loops through postings via main-loop, filters by use-code, displays lines, handles VAT area, totals, screen paging.  
I/O: posting file via acasirsub1, screen display.  
Outcomes: report displayed on screen, page count, totals displayed.  
[Seen in: display-report, main-loop, vat-area, main-display, end-display1, end-total-display.]

Path: Print Report  
Trigger: output-reply = "P" after proceed-run.  
Key steps: report-print opens print-file, writes headers, loops through postings via main-loop-p, handles VAT area, writes lines, totals, closes print-file, calls SYSTEM to print.  
I/O: posting file via acasirsub1, print-file.  
Outcomes: report printed to spool, totals printed.  
[Seen in: report-print, main-loop-p, vat-area-p, main-print, end-print, end-returne.]

Path: End-of-Cycle  
Trigger: User exits by pressing return at tipe prompt or Esc during display.  
Key steps: main99-exit performs no further actions and control passes to main-term which exits the program.  
I/O: None.  
Outcomes: program terminates.  
[Seen in: main99-exit, main-term.]

5.4 Termination  
Upon exit, main99-exit performs no further actions and control passes to main-term which exits the program. [Seen in: main99-exit, main-term.]  
If a print-file was opened, report-print ensures it is closed and the SYSTEM call is made before exiting. [Seen in: report-print, end-returne.]

---
## irs055
*[91/267]*

### Business/Functional Perspective
### Sort Posting File  

**Program Purpose**  
The program reorganises a posting file into a temporary work file that is later used by two other programs in the system. It orders the records according to the user‑selected sequence—by code, by date, or by key—to guarantee that downstream processes receive data in a predictable, sorted order. By ensuring a correctly ordered file, the program supports accurate financial reporting, reduces the risk of duplicate or misplaced entries, and improves overall system reliability.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the sorting routine cannot create the temporary file, the user is shown a “Sort Failed” message and asked to press return.  
- If an error occurs while opening or reading the original posting file, the program stops without creating the sorted file.  
- A generic “Note message & Hit return” prompt may appear if the system requires user acknowledgement after a failure.  

**User Flow Summary**  
The user initiates the program after a posting file has been prepared. The program reads each record from that file, applies the chosen sorting sequence, and writes the sorted records to a temporary file. Once completed, the program terminates and the sorted file is available for the next stage of processing. If any error occurs, the user receives a clear message and can take corrective action before rerunning the program.  

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry executes the **init01** section which performs a sort of the temporary work file based on the **Save-Sequ** parameter. [Seen in: init01 section.]  
After sorting, the program checks the sort status and displays an error if the sort failed. [Seen in: init01 section.]  
The program then exits via the **main-exit** paragraph. [Seen in: main-exit.]

5.2 Initialization  
The program initializes by selecting the sort-file and output-file definitions and setting up the file-control entries. [Seen in: data division.]  
It performs a sort on **sort-file** with a key order determined by **Save-Sequ** and uses **input-to-sort** as the input procedure, giving **output-file**. [Seen in: init01 section.]  
If the sort returns a non‑zero status, it displays the IR061, fs-reply, and SY008 messages and accepts user input to continue. [Seen in: init01 section.]

5.3 Core Processing  
Path: Sorting Path  
Trigger: **Save-Sequ** value (1, 2, or 3).  
Key steps: perform sort on **sort-file** with the appropriate key order, using **input-to-sort** as the input procedure, and output to **output-file**.  
I/O: **sort-file**, **output-file**.  
Outcomes: **fs-reply** status; possible error display.  
[Seen in: init01 section.]

Path: Input-to-Sort Path  
Trigger: external call to **input-to-sort** section (not invoked in this file).  
Key steps: perform **acasirsub4-Open-Input** to open the posting file; perform **acasirsub4-Read-Next** to read each posting record; release **sort-record** from **posting-record**; loop until **FS-Reply = 10**; perform **acasirsub4-Close** to close the posting file.  
I/O: **posting-file**, **sort-record**.  
Outcomes: **sort-record** loaded into **sort-file**; **FS-Reply** status.  
[Seen in: input-to-sort section, process-input-record, end-of-input.]

5.4 Termination  
The program exits by performing the **main-exit** paragraph, which exits the program. [Seen in: main-exit.]  
No additional cleanup is performed beyond the exit. [Seen in: main-exit.]

---
## irs060
*[92/267]*

### Business/Functional Perspective
### Final Accounts Production  

**Program Purpose**  
The program generates a year‑end profit and loss statement and balance sheet for a business, using the sorted nominal ledger data supplied from a previous step. It also offers an optional end‑of‑period processing that zeroes revenue accounts and updates capital and VAT accounts. By producing fully‑compliant financial statements and supporting end‑of‑year adjustments, the program helps users meet reporting deadlines and maintain accurate accounting records.  

**Screen Interactions**  
1. **Title Screen** – Displays “Final Accounts Production” with the current run date.  
2. **Comparative Selection** – Prompt: “Enter comparative to use (0 to 4) –  [ ]”.  
3. **Report Title** – Prompt: “Enter Profit & Loss Report Title [ ]”.  
4. **Period Type** – Prompt: “Period Report (P) or Year Report (Y) [ ]”.  
5. **Finished Account Titles** – Prompt: “Use Finished Account Titles if set up? [ ]”.  
6. **Processing Status** – Displays “Checking Accounts Please Wait”.  
7. **End‑of‑Period Decision** – Prompt: “Do you require end of period processing (Y/N) :- ”.  
8. **Comparative Field for EO‑P** – Prompt: “Comparative field to use – ”.  
9. **P/L Appropriation / Capital Account** – Prompt: “Enter P/L Appropriation or Capital A/C – (enter zero to quit)”.  
10. **EO‑P Confirmation** – Prompt: “Is This Correct? (Y/N) – ”.  
11. **End‑of‑Period Output Message** – Displays: “End of period processing outputs the current year figures to a comparative.” and “Revenue accounts are zeroed but Capital Accounts retain their value.”  

**Messages and Errors**  
- *Missing default accounts*: Alerts the user if mandatory default accounts (30 or 31) are not configured.  
- *Work file access failure*: Informs the user when the sorted nominal ledger file cannot be opened.  
- *Invalid account data*: Notifies the user if an account record appears malformed or out of sequence.  
- *End‑of‑file or data consistency errors*: Alerts when expected data is missing or corrupt, pausing for user acknowledgment.  
- *General system error*: Provides a generic message and requests the user to press return before the program terminates.  

**User Flow Summary**  
The user runs the program and is greeted with a title screen showing the run date. They are guided through a series of prompts to specify a comparative period, a custom report title, whether to use a period or year view, and whether finished account titles should be applied. After confirming these settings, the program reads the sorted nominal ledger, aggregates totals, and prints a profit‑and‑loss statement followed by a balance sheet. Once the primary reports are finished, the user is asked whether end‑of‑period adjustments are needed. If they agree, the program verifies default account settings, prompts for the P/L appropriation or capital account to adjust, and confirms the selection. The program then updates revenue, capital, and VAT accounts accordingly, prints a sales‑ratio report, and displays a final message confirming that the end‑of‑period processing has been completed. The program exits after all reports are generated.  

**Program Linkages**  
- acasirsub5  
- acasirsub3  
- acasirsub1  
- acasirsub4

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **init01**, setting environment flags, displaying headers, and opening the work file for reading. [Seen in: init01.]  
The work file is read sequentially in **Read-Loop**, accumulating totals per account type in **Accumulate**, then closed in **Read-End**. [Seen in: Read-Loop.]  
After totals are computed, the program reopens the work file and the print file, then prints the Profit & Loss and Balance Sheet reports through a series of loops (loop‑1 to loop‑9) followed by a sales ratio report. [Seen in: loop-1.]  

5.2 Initialization  
init01 sets screen exception flags, copies run‑date to display, justifies client name, clears totals, and opens the final record via acasirsub5. [Seen in: init01.]  
The program prompts the user for comparative field, report title, period type, and whether to use finished account titles, then opens the work file for reading. [Seen in: init01.]  

5.3 Core Processing  

Path: Report Generation  
Trigger: Program entry after init01 and successful opening of work file.  
Key steps: Read‑Loop reads each record, Accumulate updates totals per account type, Read‑End closes file; then work file reopened, print file opened, and loops (loop‑1 to loop‑9) output P&L and balance sheet lines, followed by ratio report.  
I/O: work‑file, print‑file.  
Outcomes: totals in total‑1/total‑2, printed report.  
[Seen in: loop-1.]  

Path: End‑of‑Period Processing  
Trigger: User selects Y at E‑o‑P‑Option prompt.  
Key steps: acasirsub3 reads default record, chk‑defs verifies defaults, Get‑PL obtains P/L appropriation, get‑pl‑rest confirms, loop‑a/b process NL records updating dr/cr totals, e‑o‑p‑fin calls VAT‑AC‑TidyUp and PL‑Capital‑AC‑Tidyup, Reset‑Postings generates posting records, ratio report printed.  
I/O: work‑file, print‑file, NL file via acasirsub1, posting file via acasirsub4.  
Outcomes: updated NL records, posting file populated, final ratio report.  
[Seen in: E‑o‑P‑Option.]  

Path: Date Validation  
Trigger: Called from Reset‑Postings to convert end‑date to binary days.  
Key steps: date‑validate converts dd/mm/yy to binary days since 01/01/2000, used for posting dates.  
I/O: none (internal).  
Outcomes: u‑bin set for posting dates.  
[Seen in: date-validate.]  

Path: VAT Tidy Up  
Trigger: e‑o‑p‑fin after NL processing.  
Key steps: VAT‑AC‑TidyUp reads VAT input account, aggregates dr/cr across NL records, rewrites NL record.  
I/O: NL file via acasirsub1.  
Outcomes: VAT input account totals updated.  
[Seen in: VAT‑AC‑TidyUp.]  

Path: PL Capital Tidy Up  
Trigger: e‑o‑p‑fin after VAT tidy.  
Key steps: PL‑Capital‑AC‑Tidyup reads PL/capital account, aggregates dr/cr, rewrites NL record.  
I/O: NL file via acasirsub1.  
Outcomes: PL/capital account totals updated.  
[Seen in: PL‑Capital‑AC‑Tidyup.]  

5.4 Termination  
After printing reports, the program performs a final ratio report, closes print‑file, and calls SYSTEM to print. [Seen in: E‑o‑P‑End.]  
The program exits via E‑o‑P‑End or goback statements, ensuring all files are closed. [Seen in: E‑o‑P‑End.]

---
## irs065
*[93/267]*

### Business/Functional Perspective
### Nominal Ledger File Sort  

**Program Purpose**  
The program creates a sorted work file from the existing nominal ledger data. It filters out only the relevant owner records, organizes them by account key, and writes the results to a temporary file that will be used by the subsequent processing routine. This step guarantees that the ledger data are in the correct order and that only valid entries are passed on, supporting accurate reporting and compliance.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the nominal ledger file cannot be opened or read, the program stops and shows an error message, allowing the operator to acknowledge it.  
- If any file access or write operation fails during processing, a descriptive error message is displayed and the program halts.  
- Successful completion produces no user‑visible message; the sorted file is ready for the next stage.

**User Flow Summary**  
A user (or a batch job) invokes the program after the ledger data have been loaded. The program opens the nominal ledger file, reads each record, keeps only the owner entries, and writes them into a sorted output file. If any file‑access issue occurs, the user is notified and must resolve the problem before retrying. Upon completion, the sorted work file is available for the following accounting steps, and the operator can proceed with the next part of the process.

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by executing the SORT statement in the init01 section, which sets up the sort-file to receive records from the input procedure input-to-sort. [Seen in: init01 section.]  
The input-to-sort section opens the nominal ledger file via acasirsub1-Open-Input, then repeatedly reads records with acasirsub1-Read-Next, filtering out non‑owner records and releasing each qualifying record into the sort-file. [Seen in: input-to-sort section.]  
When the end of the input file is reached (fs-reply = 10), the program closes the input file and exits the sort operation, completing the sort and returning control to the caller. [Seen in: end-of-input.]

5.2 Initialization  
The init01 section issues a SORT statement that specifies ascending key sort-ac, designates input procedure input-to-sort, and directs output to output-file. [Seen in: init01 section.]  
The input-to-sort section performs acasirsub1-Open-Input to open the nominal ledger file and checks fs-reply for errors, displaying messages and aborting if necessary. [Seen in: input-to-sort section.]

5.3 Core Processing  
Path: Normal Record Processing  
Trigger: acasirsub1-Read-Next returns fs-reply not 10 and Sub is false.  
Key steps: read next record, test Sub, release sort-record, loop back to process-input-record.  
I/O: input file (NL), sort-file (output-file).  
Outcomes: record added to sort-file, loop continues.  
[Seen in: process-input-record.]  

Path: Skip Owner Check  
Trigger: Sub is true for a record.  
Key steps: read next record, detect Sub true, skip release, loop back.  
I/O: input file.  
Outcomes: record ignored, no sort-record released.  
[Seen in: process-input-record.]  

Path: End-of-Input  
Trigger: fs-reply = 10 from acasirsub1-Read-Next.  
Key steps: perform acasirsub1-Close, exit section.  
I/O: input file.  
Outcomes: input file closed, sort operation ends.  
[Seen in: end-of-input.]  

Path: Error on Open  
Trigger: fs-reply not zero after acasirsub1-Open-Input.  
Key steps: display IR912, FS-Reply, SY008, accept reply, open output-file, close output-file, perform acasirsub1-Close, goback.  
I/O: output-file.  
Outcomes: program aborts with error.  
[Seen in: input-to-sort section.]  

Path: Main Exit  
Trigger: goback or exit program.  
Key steps: exit program.  
I/O: none.  
Outcomes: program terminates.  
[Seen in: main-exit.]

5.4 Termination  
The program terminates by executing the exit statement in the main-exit section, which ends the program and returns control to the caller. [Seen in: main-exit.]  
No additional cleanup beyond the implicit closure of the sort-file is performed. [Seen in: main-exit.]

---
## irs070
*[94/267]*

### Business/Functional Perspective
### Posting Amendment

---

**Program Purpose**  
The program lets a user correct or delete existing accounting postings.  
It pulls the selected posting, displays all its details, lets the user amend amounts, dates, narration, or VAT, and then writes the corrected record back to the system. The ability to delete a posting is also provided. At the end the user may choose to renumber all postings for consistency.

---

**Screen Interactions**  
1. **Posting Amendment Screen** – Shows the following fields and instructions:  
   - **Number** – Enter posting key.  
   - **Code** – Posting code.  
   - **Date** – Posting date.  
   - **Debit** – Debit amount.  
   - **Credit** – Credit amount.  
   - **Net** – Net amount (displayed).  
   - **Narrative** – Text description.  
   - **VAT Type** – 31 for input, 32 for output.  
   - **VAT Side** – “CR” or “DR”.  
   - **VAT** – VAT amount.  
   - Instruction line: “Enter code of <**> to delete”.  
   - Instruction line: “Enter number or ESC to exit”.  
   The screen uses color highlights and accepts direct keyboard entry.  

---

**Messages and Errors**  
- **Posting does not exist!** – Shown when the entered key has no matching record.  
- **Reversing posting. please wait** – Informational message while the program reverts the original entry.  
- **Correct the transaction** – Prompt after reversal, indicating the user should adjust fields.  
- **'**' Here, will delete transaction** – Confirmation prompt when the delete code “**” is entered.  
- **Error** – General numeric or format error for VAT type or side entry.  
- **Inconsistent** – Shown when a VAT amount is entered but no VAT account is specified.  
- **Amount not numeric. Re‑Enter** – When a monetary field contains non‑numeric characters.  
- **Sorting please wait** – Informational message during post‑renumbering.  
- **Renumber the postings (Y/N) - [ ]** – Prompt asking whether to renumber after finishing edits.  

---

**User Flow Summary**  
The user starts the program and is presented with the amendment screen. They enter the posting key; if the record exists, its current details populate the fields. The user can modify any of the editable values (date, debit, credit, narration, VAT type/side/amount). After editing, the program reverses the original posting, applies the new values, and writes the updated record. The screen then clears and allows entry of another key. If the user types “**” for the code, the program deletes that posting. When the user presses the ESC key, the program offers to renumber all postings; a “Y” triggers a background sort and renumber routine, while “N” exits. Finally the program closes all files and terminates.

---

**Program Linkages**  
- acasirsub3  
- acasirsub1  
- acasirsub4  
- irs055  
- irsubp

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by executing the init01 section which sets screen exceptions, opens the default, NL, and posting files, and displays the header screen. [Seen in: init01.]  
Control then enters the input-loop paragraph where the user is prompted for a posting number, and the program reads and displays the selected posting, reverses its effects, and allows the user to edit or delete it. [Seen in: input-loop.]  
After processing a posting, the program returns to the input-loop until the user exits by pressing ESC, at which point it proceeds to End‑of‑Amend to close files and optionally renumber postings before terminating. [Seen in: End-of-Amend.]

5.2 Initialization  
init01 sets the COBOL screen exception environment variables, initializes save‑sequ to zero, and performs file operations to open the defaults (acasirsub3), NL (acasirsub1), and postings (acasirsub4). [Seen in: init01.]  
It then displays the program title, run‑date, and a series of input prompts on the screen before transferring control to the input-loop. [Seen in: init01.]

5.3 Core Processing  
Path: Posting Reversal and Edit  
Trigger: User enters a posting number (post‑key) and does not press ESC. [Seen in: input-loop.]  
Key steps: Read posting record via acasirsub4 (function 4), display posting details, reverse DR and CR amounts by updating NL balances, accept new posting data (date, amounts, VAT), validate accounts, and rewrite the posting record. [Seen in: input-loop, reverse-cr, reverse-vat, reverse-end, rewrite-posting.]  
I/O: Posting file (acasirsub4), NL file (acasirsub1). [Seen in: input-loop, reverse-cr, reverse-vat, reverse-end, rewrite-posting.]  
Outcomes: Posting record updated or error‑flag set if account read fails; posting balances adjusted. [Seen in: input-loop, reverse-cr, reverse-vat, reverse-end, rewrite-posting.]

Path: Delete Posting  
Trigger: After reversal, user enters "**" as post‑code. [Seen in: reverse-end.]  
Key steps: Perform acasirsub4 with function 8 to delete the posting record. [Seen in: post-delete.]  
I/O: Posting file. [Seen in: post-delete.]  
Outcomes: Posting removed from file. [Seen in: post-delete.]

Path: Renumber Postings  
Trigger: User replies "Y" to the renumber prompt after End‑of‑Amend. [Seen in: end-option.]  
Key steps: Call irs055 to sort postings, then loop through postings using irsubp and rewrite each with a new sequential key. [Seen in: end-option, rewrite-loop, end-of-run.]  
I/O: Posting file. [Seen in: end-option, rewrite-loop, end-of-run.]  
Outcomes: Postings renumbered, next‑post updated. [Seen in: end-option, rewrite-loop, end-of-run.]

Path: Exit Program  
Trigger: User presses ESC in input‑loop or replies "N" to renumber prompt. [Seen in: End‑of‑Amend, end-option.]  
Key steps: Close posting and NL files, display exit message, and execute GOBACK via main99‑exit. [Seen in: End‑of‑Amend, main99-exit.]  
I/O: Posting file, NL file. [Seen in: End‑of‑Amend, main99-exit.]  
Outcomes: Program terminates. [Seen in: End‑of‑Amend, main99-exit.]

5.4 Termination  
The program exits by closing the posting and NL files, optionally renumbering postings, and executing GOBACK via main99‑exit. [Seen in: main99-exit.]  
No additional cleanup is performed beyond file closure and program termination. [Seen in: main99-exit.]

---
## irs080
*[95/267]*

### Business/Functional Perspective
### Nominal Ledger Fixup  

**Program Purpose**  
This program reconciles the nominal ledger totals by resetting all balances to zero, then re‑calculating them from the postings file. It applies any default VAT accounts defined for accounts 31 and 32 during the update. The result is a clean, accurate ledger that can be used for subsequent reporting or audit purposes.  

**Screen Interactions**  
1. **Confirmation Prompt** – Displays “Fixup Accounts File” and asks the user to press **Y** to continue or **N** to quit.  
2. **Clear Totals Display** – Shows “Cleared Nominal Ledger of totals” followed by the number of records cleared.  
3. **Processing Status** – Prints “Updating Nominal Ledger” while the program reads and updates posting records.  
4. **Completion Screen** – At the end, shows “Processing Complete on *n* records” with a note to press return to return to the menu.  

**Messages and Errors**  
- If the ledger cannot be reset due to a system error, a notice is shown that the nominal processing failed.  
- When a required nominal record (key 31 or 32) cannot be found, the program informs the user of an “Invalid key” error and prompts for continuation.  
- If the postings file is missing or unreadable, the user is notified that no postings are available.  
- Any unexpected system failure during a file operation results in a general error message indicating that the operation was unsuccessful.  

**User Flow Summary**  
The user starts the program and is asked whether to proceed. Upon confirmation, the program wipes the current totals from the nominal ledger, then reads each posting record one by one. For each posting, it updates the debit or credit balance for the appropriate account, applies VAT amounts to the special default accounts when needed, and writes the updated balances back to the ledger. The user sees status updates on the screen and, when finished, is shown the total number of records processed and asked to press return to return to the menu.  

**Program Linkages**  
- acasirsub1  
- acasirsub1-Close  
- acasirsub3  
- acasirsub4

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the init01 section, displaying header information, prompting the user to confirm clearing totals, and opening the nominal ledger file for processing. [Seen in: init01.]  
The Clear‑nl loop then reads each nominal ledger record, resetting totals for records with zero balances and rewriting them until the end of the file is reached. [Seen in: Clear‑nl.]  
After clearing, the program retrieves default records 31 and 32, opens the posting file, and processes each posting record, updating the nominal ledger and VAT defaults before writing the updated records back. [Seen in: repost, input-loop.]  
Upon completion, the program writes the final default records, closes files, displays a summary, and exits. [Seen in: eoj, main99-exit.]

5.2 Initialization  
The init01 section clears counters, displays program information, prompts the user to confirm clearing totals, and exits if the user declines. [Seen in: init01.]  
It then opens the nominal ledger file for read/write access and begins the Clear‑nl loop to reset totals. [Seen in: init01.]

5.3 Core Processing  
Path: Clear‑nl Loop  
Trigger: performed after opening the nominal ledger file.  
Key steps: read a nominal ledger record, check for end‑of‑file, reset totals for zero‑balance records, and rewrite the record.  
I/O: nominal ledger file via acasirsub1.  
Outcomes: post‑record‑cnt incremented, file pointer advanced, loop continues until EOF.  
[Seen in: Clear‑nl.]  

Path: Default‑Record Retrieval  
Trigger: after Clear‑end.  
Key steps: perform acasirsub3 to obtain default record, then acasirsub1 to read NL records for defaults 31 and 32 into nl31‑record and nl32‑record.  
I/O: default record via acasirsub3, nominal ledger file via acasirsub1.  
Outcomes: nl31‑record and nl32‑record populated for later use.  
[Seen in: init01.]  

Path: Posting File Open & Processing  
Trigger: after default records loaded.  
Key steps: open posting file with acasirsub4, loop input‑loop reading posting records, update NL records for DR and CR amounts, handle VAT updates, and rewrite NL records.  
I/O: posting file via acasirsub4, nominal ledger file via acasirsub1.  
Outcomes: post‑record‑cnt incremented, NL records updated, posting file processed.  
[Seen in: repost, input-loop.]  

Path: VAT Processing (within input‑loop)  
Trigger: when vat‑ac‑def is non‑zero.  
Key steps: update nl31 or nl32 DR/CR amounts based on vat‑ac‑def and vat‑vat‑side.  
I/O: nominal ledger records via acasirsub1.  
Outcomes: nl31‑record or nl32‑record updated with VAT amounts.  
[Seen in: input-loop.]  

Path: Final Write & Exit  
Trigger: after eoj.  
Key steps: write nl31 and nl32 records to nominal ledger, close posting file, display completion message, accept user acknowledgement, and exit.  
I/O: nominal ledger file via acasirsub1, posting file via acasirsub4.  
Outcomes: final totals written, program terminates.  
[Seen in: eoj, main99-exit.]

5.4 Termination  
The program exits cleanly via the main99-exit paragraph after displaying a completion message and awaiting user acknowledgement. [Seen in: main99-exit.]  
If the user declines the initial confirmation, the program terminates immediately from init01. [Seen in: init01.]

---
## irs085
*[96/267]*

### Business/Functional Perspective
### Posting File Sorting  

**Program Purpose**  
The program reorganizes posting data by sorting records first by account number and then by month. It prepares the data for subsequent posting steps, ensuring that debits, credits, and tax deferral entries are in the correct order. By performing this sort, the system can reliably update ledger balances and maintain accurate audit trails.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the posting file cannot be opened or read, a single error message is displayed and the program stops.  
- Successful completion does not generate user‑visible output; the sorted data is written to a temporary file for later use.  

**User Flow Summary**  
The user (or calling program) initiates the posting process, and this program automatically reads the raw posting file. Each record is examined, amounts are adjusted (debits become negative, credits remain positive), and tax deferral entries are incorporated. The records are then sorted by account and month and written to a temporary output file. If any file‑access problem occurs, a concise error message is shown, otherwise the program ends silently, ready for the next step in the posting workflow.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in the init01 section, setting the file-function to 3 and invoking acasirsub3 to prepare posting file handling. [Seen in: init01 section.]  
It then initiates a sort of the sort-file on sort-account and sort-month, using input-to-sort as the input procedure and output-file as the output destination. [Seen in: init01 section.]  
After the sort completes, control passes to main-exit which exits the program. [Seen in: main-exit.]

5.2 Initialization  
The init01 section moves the value 3 into the file-function field to indicate a posting file operation. [Seen in: init01 section.]  
It performs acasirsub3 to set up necessary environment and file definitions for the posting file. [Seen in: init01 section.]  
The sort-file is defined with organization sequential and is opened for output by the sort statement, while output-file is assigned to "workpost.tmp". [Seen in: init01 section.]

5.3 Core Processing  
Path: Input-to-Sort Open  
Trigger: acasirsub4-Open-Input  
Key steps: open the posting-file, check fs-reply, display an error message if fs-reply is not zero, and jump to end-of-input.  
I/O: posting-file  
Outcomes: sets fs-reply; may terminate early if opening fails.  
[Seen in: input-to-sort section.]

Path: Read-Next Loop  
Trigger: acasirsub4-Read-Next  
Key steps: read the next posting record; if fs-reply = 10, jump to end-of-input; otherwise proceed to process the record.  
I/O: posting-file  
Outcomes: loads post-mm, post-amount, post-cr, post-dr, vat-ac-def, vat-amount, def-acs into working storage.  
[Seen in: process-input-record.]

Path: Process Record  
Trigger: process-input-record  
Key steps: write a credit sort-record (post-cr, post-amount, sort-month), write a debit sort-record (post-dr, -post-amount, sort-month), and if vat-ac-def ≠ 0, write a VAT sort-record (def-acs(vat-ac-def), vat-amount, sort-month).  
I/O: sort-file  
Outcomes: three sort-records are released per posting record, sorted by account and month.  
[Seen in: process-input-record.]

Path: End-of-Input  
Trigger: end-of-input  
Key steps: perform acasirsub4-Close to close the posting-file, then copy Proc-ZZ100-ACAS-IRS-Calls.cob for finalization.  
I/O: posting-file  
Outcomes: posting-file is closed; final cleanup routines are executed.  
[Seen in: end-of-input, Proc-ZZ100-ACAS-IRS-Calls.cob.]

5.4 Termination  
After closing the posting-file, the program performs any finalization routines in Proc-ZZ100-ACAS-IRS-Calls.cob and then exits via main-exit. [Seen in: end-of-input, Proc-ZZ100-ACAS-IRS-Calls.cob.]  
No additional cleanup is performed beyond closing files and exiting. [Seen in: main-exit.]

---
## irs090
*[97/267]*

### Business/Functional Perspective
### Monthly Posting File Report  

**Program Purpose**  
The program compiles a month‑by‑month analysis of the posting file. It reads transaction amounts for each account, sums the totals by month, and produces a printable report that lists each account’s monthly balances and yearly totals. The report supports compliance and audit activities by providing an accurate, consolidated view of postings for a selected tax year.  

**Screen Interactions**  
1. **Prompt Screen** – Displays the program title, current date, and a note that 132‑column paper is required. It then asks the user to enter the month (01‑12) that marks the start of the tax year. The user types a number and presses Enter.  

**Messages and Errors**  
- If the posting file or nominal ledger cannot be accessed, the program stops and displays a clear error message indicating the missing file.  
- If writing to the temporary work file fails, the user is notified with an error message and prompted to acknowledge before the program terminates.  
- If a record cannot be found in the nominal ledger for a referenced account, a descriptive message is shown and the program exits.  
- General system or processing errors produce a generic error message that indicates the operation failed, allowing the user to review the cause.  

**User Flow Summary**  
The user launches the program and is presented with a simple screen that asks for the month that starts the tax year. After entering a value between 01 and 12, the screen clears. The program then reads the posting file, aggregates amounts per month for each account, and pulls account names from the nominal ledger. It compiles a report that lists each account, shows the amount for each month, and displays a yearly total. The report is written to the print spool; the user may view or print the final output. If any file or data errors occur, the user receives a message and the program terminates gracefully.  

**Program Linkages**  
- SYSTEM   (used for printing the report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by performing **lb-init** which sets up time, clears accumulators, prompts for the tax year start month, and opens the nominal ledger and print files. [Seen in: lb-init.]  
The main processing loop in **lc-process** reads nominal ledger records, aggregates amounts per month for each account, and writes a temporary work file when the account changes. [Seen in: lc-process.]  
After all records are read, **ld-output-final** reopens the temporary work file, iterates through the sorted accounts, and prints formatted report lines using **lzd-headings** and **lze-print-line**. [Seen in: ld-output-final.]  
Finally, **le-close** writes a footer, closes all files, and invokes the print spooler before exiting. [Seen in: le-close.]

5.2 Initialization  
**lb-init** accepts the current time, initializes month accumulators to zero, and sets the run-date and client information on the header. [Seen in: lb-init.]  
It then prompts the user for the month the tax year starts, validates the input, opens the nominal ledger input file, and prepares the print file and work files. [Seen in: lb-init.]

5.3 Core Processing  
Path: **lc-process main loop**  
Trigger: start of lc-process.  
Key steps: read work-file, accumulate amounts per month, detect account change, write work-file-2.  
I/O: work-file, work-file-2.  
Outcomes: work-file-2 contains aggregated amounts per account per month.  
[Seen in: lc-process, lca-start, lzf-get-nominal, lzf-read, lzf-exit.]

Path: **ld-output-final output loop**  
Trigger: after lc-process completes.  
Key steps: open work-file-2, read sequentially, print headings, print lines, handle page breaks.  
I/O: work-file-2, print-file.  
Outcomes: print-file contains formatted report.  
[Seen in: ld-output-final, ldb, lzg-read-nl-seq, lzd-headings, lze-print-line.]

Path: **lzc-set-report-months**  
Trigger: during lb-init.  
Key steps: set month labels for report header.  
I/O: none.  
Outcomes: l3-litmonth array set.  
[Seen in: lzc-set-report-months, lzc-set-mth.]

Path: **lzf-get-nominal**  
Trigger: when a new account is encountered.  
Key steps: set owning and sub-nominal.  
I/O: work-file.  
Outcomes: owning set for subsequent processing.  
[Seen in: lzf-get-nominal.]

Path: **lzg-read-nl-seq**  
Trigger: during output loop to read next nominal record.  
Key steps: read next, skip sub-nominals, set owning.  
I/O: work-file-2.  
Outcomes: owning updated.  
[Seen in: lzg-read-nl-seq.]

5.4 Termination  
**le-close** writes a final note line, closes print-file, work-file, and work-file-2, and calls the system print spooler. [Seen in: le-close.]  
The program then reopens the work files for cleanup and exits via GOBACK. [Seen in: le-close.]

---
## irsdfltLD
*[98/267]*

### Business/Functional Perspective
### IRS Default Table Load  

**Program Purpose**  
The program copies IRS default table records from a local file into a MySQL database. It reads the system configuration to obtain database connection details, validates each record, and writes it into the target table, rewriting any duplicate entries. This process ensures that the system’s default values are consistently populated, supporting accurate reporting and compliance checks while reducing the risk of missing data.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the system configuration file cannot be opened or read, the program stops and informs the user that the system is not set up.  
- If database parameters are missing or the database is unavailable, it aborts with a message indicating the missing setup.  
- When writing a record, duplicate keys are detected and the existing record is rewritten.  
- For other database or file errors, the program displays the error details and terminates.  
- Upon completion it reports the number of records read, written, rewritten, and the number of log entries produced.  

**User Flow Summary**  
The user launches the program, which automatically loads the system parameters and accesses the IRS default file. For each record, the program attempts to insert it into the MySQL table, handling duplicates by rewriting existing entries. Throughout the run, status messages are printed to the console, showing progress and any issues. When finished, a final summary of record counts and log activity is displayed, and the program exits.  

**Program Linkages**  
- acas-get-params  
- acasirsub3  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program starts by parsing command‑line arguments, initializing logging, and opening the system parameter file to load RDBMS settings. [Seen in: aa000-main-start.]  
It then overrides any default RDBMS parameters with values from the acas.param file if necessary, and opens the RDBMS connection via acasirsub3. [Seen in: aa010-Proc-Override.]  
The main processing loop reads each Default record from the IRS default file and writes it to the RDBMS table, handling duplicate keys and other database errors, before finally closing files and reporting counts. [Seen in: aa010-Read.]

5.2 Initialization  
The program performs an early PERFORM of zz020-Get-Program-Args to capture command‑line arguments, sets up logging identifiers, and opens the System‑File for reading. [Seen in: aa000-main-start.]  
It verifies the System‑File read status, loads RDBMS parameters from the record, and if necessary calls acas-get-params to obtain missing database connection details. [Seen in: aa000-main-start.]  
If the RDBMS parameters are incomplete or the acas.param file is missing, the program aborts with an error message and a return code of 128. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: Program start after zz020-Get-Program-Args.  
Key steps: Open System‑File, read first record, load RDBMS parameters, optionally call acas-get-params.  
I/O: System‑File.  
Outcomes: RDBMS connection details set, error status set if read fails.  
[Seen in: aa000-main-start.]

Path: Override RDBMS Parameters  
Trigger: RDBMS‑DB‑Name empty or FS‑Cobol‑Files‑Used true.  
Key steps: Call acas-get-params, move returned values to RDBMS variables, go to aa010-Proc-Override.  
I/O: acas.param file via acas-get-params.  
Outcomes: RDBMS variables populated, logging of parameters, transition to database open.  
[Seen in: aa010-Proc-Override.]

Path: Default Record Load  
Trigger: Successful read of a Default record from the IRS default file.  
Key steps: Increment input record count, set File‑System‑Used to RDBMS, perform acasirsub3‑Write, handle duplicate key or write errors, increment output record count.  
I/O: IRS‑Default‑File (via acasirsub3‑Read‑Next), RDBMS table (via acasirsub3‑Write).  
Outcomes: Record written or rewritten, error messages logged, counts updated.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: acasirsub3‑Write returns SQL‑State “23000” or fs‑reply 22/99 or SQL‑Err 1062/1022.  
Key steps: Reset fs‑reply and WE‑Error, perform acasirsub3‑ReWrite, log duplicate key message.  
I/O: RDBMS table.  
Outcomes: Duplicate record rewritten, error status cleared, processing continues.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: Any non‑zero fs‑reply after acasirsub3 operations.  
Key steps: Log detailed error information, optionally perform aa020‑Rollback, set return‑code 16, exit to aa999‑Finish.  
I/O: None (logging only).  
Outcomes: Error reported, transaction rolled back if possible, program terminates with error status.  
[Seen in: aa100-Check-4-Errors, aa020-Rollback.]

Path: Finish/Close  
Trigger: End of processing loop or error exit.  
Key steps: Close RDBMS via acasirsub3‑Close, close System‑File, reset file‑system flags, output record counts, log exit message, goback.  
I/O: System‑File, RDBMS connection.  
Outcomes: Resources released, final counts reported, program exits cleanly.  
[Seen in: aa999-Finish, aa999-Finish-2.]

5.4 Termination  
The program reports the total number of records processed and the number of log records written before closing all files and returning control to the operating system. [Seen in: aa999-Finish.]  
It sets the return‑code to indicate success or failure based on earlier error handling and then performs a GOBACK to terminate. [Seen in: aa999-Finish-2.]

---
## irsdfltMT
*[99/267]*

### Business/Functional Perspective
### IRS Default Record Access  

**Program Purpose**  
The program provides a unified interface for opening, reading, writing, and updating the IRS default record table. It ensures that default record data is retrieved accurately, can be modified, and that changes are written back to the database while maintaining consistency and integrity. This function supports data validation, audit trails, and reduces the risk of duplicate or corrupted records.  

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- Successful completion of an operation is indicated by a reply code of 0.  
- If the requested key is not found or a duplicate key is detected, the program signals an error with a non‑zero reply.  
- When the database connection fails or a query cannot be executed, the program reports an error that includes the database error message.  
- End‑of‑file or no‑data conditions return a reply that tells the caller that no records were found.  

**User Flow Summary**  
The calling module specifies the action to perform by setting a *File‑Function* value:  
1. **Open** – The program connects to the database and prepares for subsequent operations.  
2. **Read Next** – It fetches up to 32 rows of default records, loading them into a single record structure for the caller to use.  
3. **Write** – It inserts up to 32 new records into the table, handling duplicate keys or other insertion errors.  
4. **Rewrite** – It updates existing records in the table based on the key value in each row.  
5. **Close** – The database connection is cleanly terminated.  

After each operation, the program returns status codes, any relevant error messages, and, where applicable, the data that was read or written. The calling module then uses this information to update the user interface, log changes, or handle errors.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the ba-ACAS-DAL-Process section, accepting linkage parameters and setting screen exception handling. [Seen in: ba-ACAS-DAL-Process.]  
It performs initialization in ba010-Initialise, clearing error fields and setting up environment variables. [Seen in: ba010-Initialise.]  
The File-Function value determines the processing path via an EVALUATE statement, dispatching to ba020-Process-Open, ba030-Process-Close, ba040-Process-Read-Next, ba070-Process-Write, ba090-Process-Rewrite, or ba100-Bad-Function. [Seen in: ba-ACAS-DAL-Process.]  
After the selected path completes, control returns to ba999-exit where the program exits. [Seen in: ba999-exit.]

5.2 Initialization  
The program accepts the environment line count and sets the screen exception and escape handling in ba-ACAS-DAL-Process. [Seen in: ba-ACAS-DAL-Process.]  
The ba010-Initialise paragraph clears all error and status fields, initializing the MySQL error message buffer and SQL state. [Seen in: ba010-Initialise.]  
No database connection is established until the Process-Open path is taken. [Seen in: ba020-Process-Open.]

5.3 Core Processing  
Path: Process-Open  
Trigger: File-Function = 1 (Open)  
Key steps: Build MySQL connection parameters from linkage, perform MYSQL-1000-OPEN to open DB, set WS-File-Key to "OPEN IRS DEFAULT", set Most-Cursor-Set to zero, go to end.  
I/O: MYSQL-1000-OPEN.  
Outcomes: fs-reply set if open fails, WE-Error set, exit.  
[Seen in: ba020-Process-Open.]  

Path: Process-Close  
Trigger: File-Function = 2 (Close)  
Key steps: If cursor active, perform ba998-Free to free result set; perform MYSQL-1980-CLOSE to close DB; set WS-File-Key to "CLOSE IRS DEFAULT".  
I/O: MYSQL-1980-CLOSE.  
Outcomes: cursor cleared, exit.  
[Seen in: ba030-Process-Close.]  

Path: Process-Read-Next  
Trigger: File-Function = 3 (Read-Next)  
Key steps: If cursor not active, build WHERE clause for DEF-REC-KEY > "000", perform SELECT via MYSQL-1210-COMMAND, store result via MYSQL-1220-STORE-RESULT, set TP-IRSDFLT-REC, if no rows set fs-reply 10 and WE-Error 10, else set Most-Cursor-Set to 1; then fetch rows in loop up to 32, mapping fields to Default-Record arrays, handling EOF and errors.  
I/O: MYSQL-1210-COMMAND, MYSQL-1220-STORE-RESULT, MySQL_fetch_record.  
Outcomes: fs-reply 0 or 10, WE-Error 0 or 10, cursor active, data loaded into Default-Record.  
[Seen in: ba040-Process-Read-Next.]  

Path: Process-Write  
Trigger: File-Function = 5 (Write)  
Key steps: Loop over 32 records, set fields from Default-Record arrays to HV-DEF-..., perform bb200-Insert for each, check MySQL-COUNT-ROWS, handle duplicate key errors (set fs-reply 22) or other errors (99).  
I/O: bb200-Insert (MYSQL-1210-COMMAND).  
Outcomes: fs-reply set to 0 or error code, WE-Error may be set, data inserted.  
[Seen in: ba070-Process-Write, bb200-Insert Section.]  

Path: Process-Rewrite  
Trigger: File-Function = 7 (Rewrite)  
Key steps: Loop over 32 records, set fields, build WHERE clause using key, perform bb300-Update for each, check MySQL-COUNT-ROWS, handle errors.  
I/O: bb300-Update (MYSQL-1210-COMMAND).  
Outcomes: fs-reply set to 0 or error code, WE-Error may be set.  
[Seen in: ba090-Process-Rewrite, bb300-Update Section.]  

Path: Bad-Function  
Trigger: File-Function other  
Key steps: Set WE-Error 990, Fs-Reply 99, exit.  
I/O: none.  
Outcomes: error status.  
[Seen in: ba100-Bad-Function.]  

5.4 Termination  
After processing, control returns to ba999-exit which exits the program, optionally logging via Ca-Process-Logs if Testing-1 is set. [Seen in: ba999-exit.]  
The ba998-Free paragraph frees any MySQL result set and clears the cursor when invoked. [Seen in: ba998-Free.]

---
## irsdfltRES
*[100/267]*

### Business/Functional Perspective
### Restore Default File from Backup  

**Program Purpose**  
The program recovers the system’s default settings by copying records from a backup sequential file (`irsdflt.seq`) into the primary default file. It is used during system restore or migration to ensure that configuration data is accurately re‑established. By validating the source file and reporting any problems, the program helps prevent data loss and supports rapid recovery after a failure.  

**Screen Interactions**  
No direct user screens are presented. The program writes status messages to a log file (`SYS-DISPLAY.log`) via the ACAS‑Sysout service.  

**Messages and Errors**  
- *Missing source file*: “No irsdefault file to process”  
- *Open failure for destination file*: “Failed on open - IRS Default file = ” followed by an error code  
- *Read error while processing the backup file*: “Problem reading .seq file = ” followed by an error code  
- *Write error when creating the destination file*: “SYS06 Write error on .dat file”  
- *Completion notice*: records read and written counts are logged.  

**User Flow Summary**  
A user initiates the restore operation (typically via a command line or a scheduled job). The program attempts to open the backup file `irsdflt.seq`. If it exists, each record is read and written to the primary default file; any I/O problems are logged and the process stops. Once all records are processed, the program logs the total number of records successfully restored and exits. The user can review the log file to confirm success or diagnose any errors.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph **aa000-Main-Start**, performing argument retrieval, logging initialization, and file opening. [Seen in: aa000-Main-Start.]  
It then enters a loop in paragraph **aa010-Read-Recs** that reads each record from the sequential input file and writes it to the output file, handling any I/O errors. [Seen in: aa010-Read-Recs.]  
Upon completion or error, control moves to paragraph **aa020-Finish-Off**, which closes the files, logs a summary, sets the return code, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to capture command‑line parameters and sets logging identifiers (WS-Log-System and WS-Log-File-no). [Seen in: aa000-Main-Start.]  
It opens the input file **irsdflt-File-Seq** and, if successful, opens the output file **Default-File**; any open failures are logged via **Call-Sysout** and the program terminates early. [Seen in: aa000-Main-Start.]

5.3 Core Processing  

Path: Program Start  
Trigger: Entry into **aa000-Main-Start**  
Key steps: Retrieve arguments, set logging parameters, call Sysout, open input file, handle missing file, open output file, handle open errors, initialize record counters.  
I/O: irsdflt-File-Seq, Default-File  
Outcomes: Files opened (or error logged), counters set to zero, program ready to read records.  
[Seen in: aa000-Main-Start.]

Path: Read-Records  
Trigger: Loop in **aa010-Read-Recs**  
Key steps: Read next record from irsdflt-File-Seq; if end‑of‑file, jump to aa020-Finish-Off; on read error, log message and exit loop; write record to Default-File; on write error, log message and exit loop; increment input and output counters.  
I/O: irsdflt-File-Seq, Default-File  
Outcomes: Record counts updated, any I/O errors logged, loop exits on error or end‑of‑file.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: **aa020-Finish-Off** after loop completion or error.  
Key steps: Close irsdflt-File-Seq and Default-File, construct summary string with record counts, log summary via Call‑Sysout, set Return-Code to zero, and goback to terminate.  
I/O: irsdflt-File-Seq, Default-File  
Outcomes: Files closed, summary logged, program exits cleanly.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program ends by executing **goback** in paragraph **aa020-Finish-Off**, after closing both files and logging a final summary. [Seen in: aa020-Finish-Off.]  
The Return-Code is set to zero just before exit, indicating successful completion. [Seen in: aa020-Finish-Off.]

---
## irsdfltUNL
*[101/267]*

### Business/Functional Perspective
### IRS Default File Backup  

**Program Purpose**  
The program creates a sequential backup copy of the IRS default data file. It transfers every record from the existing ISAM source file into a new `.seq` file, allowing the data to be restored later if needed. By preserving a reliable copy, the program reduces the risk of data loss, supports compliance audits, and ensures business continuity.  

**Screen Interactions**  
No direct screens. This program is run from the command line and writes progress messages to a log file, returning control to the calling environment.  

**Messages and Errors**  
- If the source file cannot be opened, the program reports “No irsdefault file to process.”  
- If a record cannot be read, it logs the read error and stops.  
- If a record cannot be written to the backup file, it logs a write‑error message and stops.  
- Upon successful completion, it logs the total number of records read and written.  

**User Flow Summary**  
The user starts the program from the command line. The program checks for the presence of the IRS default data file. If the file exists, it reads each record in sequence and writes the record unchanged to a new backup file named `irsdflt.seq`. As it runs, the program records status messages to a log file. When finished, it reports the count of records processed and then exits, leaving the backup file available for future restoration or further processing.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins at aa000-Main-Start, retrieves command line arguments and logs program header. [Seen in: aa000-Main-Start.]  
It opens the source Default-File for reading, verifies its existence, then opens the target irsdflt-File-Seq for writing. [Seen in: aa000-Main-Start.]  
The main loop in aa010-Read-Recs reads each record from Default-File, writes it to irsdflt-File-Seq, and handles any read or write errors before proceeding to aa020-Finish-Off for cleanup. [Seen in: aa010-Read-Recs.]

5.2 Initialization  
zz020-Get-Program-Args is performed to capture command line arguments into Arg-Vals. [Seen in: aa000-Main-Start.]  
Logging system identifiers WS-Log-System and WS-Log-File-no are set, and a header message is sent to ACAS-Sysout via Call-Sysout. [Seen in: aa000-Main-Start.]  
The program opens Default-File for input; if the file is missing, a message is logged and the program exits early. [Seen in: aa000-Main-Start.]  
After confirming the input file, it opens irsdflt-File-Seq for output and initializes record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read and Write Records  
Trigger: Successful open of both input and output files and entering aa010-Read-Recs loop.  
Key steps: Read next record from Default-File; on success, increment ws-Rec-Cnt-In, write record to irsdflt-File-Seq, increment ws-Rec-Cnt-Out; loop until end of file or error.  
I/O: Default-File, irsdflt-File-Seq.  
Outcomes: Record counts updated; on read or write error, error message logged and loop exits to aa020-Finish-Off.  
[Seen in: aa010-Read-Recs.]

Path: Missing Input File  
Trigger: FS-Reply status after opening Default-File indicates file not found.  
Key steps: Log "No irsdefault file to process", close Default-File, log close message, goback.  
I/O: Default-File.  
Outcomes: Program terminates without creating output file.  
[Seen in: aa000-Main-Start.]

Path: Read Error  
Trigger: FS-Reply non-zero during a read operation in aa010-Read-Recs.  
Key steps: Construct error message with SY003 and FS-Reply, log via Call-Sysout, exit loop to aa020-Finish-Off.  
I/O: Default-File.  
Outcomes: Error logged, program proceeds to cleanup.  
[Seen in: aa010-Read-Recs.]

Path: Write Error  
Trigger: FS-Reply non-zero after attempting to write to irsdflt-File-Seq.  
Key steps: Set SO-Print to SY006, log via Call-Sysout, exit loop to aa020-Finish-Off.  
I/O: irsdflt-File-Seq.  
Outcomes: Error logged, program proceeds to cleanup.  
[Seen in: aa010-Read-Recs.]

Path: Finish  
Trigger: End of file or any error causes transition to aa020-Finish-Off.  
Key steps: Close both files, log record counts, set Return-Code to zero, goback.  
I/O: Default-File, irsdflt-File-Seq.  
Outcomes: Files closed, counts reported, program exits.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
In aa020-Finish-Off, both irsdflt-File-Seq and Default-File are closed, a summary of records processed is logged, and the program returns with Return-Code zero. [Seen in: aa020-Finish-Off.]  
The final goback statement ends program execution, returning control to the caller. [Seen in: aa020-Finish-Off.]

---
## irsfinalLD
*[102/267]*

### Business/Functional Perspective
### IRS Final Table Load

**Program Purpose**  
This program transfers data from the IRS Final data file into a MySQL database table. It reads system configuration to locate the database, processes each record, and writes it to the target table. The operation ensures that all final IRS records are available for reporting and analysis, maintaining data integrity by handling duplicate entries and reporting any database errors. By loading the data reliably, the program supports compliance reporting and reduces the risk of missing or inconsistent financial information.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- *System configuration issues*: If the system file or database parameters cannot be read, the program stops and reports the missing or invalid configuration.  
- *File access problems*: Errors opening or reading the IRS Final data file are reported and halt the load.  
- *Database errors*: Any problems writing to the MySQL table—such as constraint violations or connection failures—are logged with the SQL error details.  
- *Duplicate records*: When a record already exists, the program rewrites the entry and logs a “Rewriting” notice.  
- *Completion status*: At the end of the run, the program reports the number of records processed, any rewrites performed, and a final “EOJ - Load IRS Final Table” message.

**User Flow Summary**  
The user initiates the load by executing the program, optionally supplying up to two command‑line arguments. The program reads system settings to connect to the database and opens the IRS Final data file. It then reads each record, attempts to insert it into the MySQL table, and handles any duplicate keys by rewriting the existing entry. Throughout the process, informational and error messages are sent to a system log. When all records have been processed or a fatal error occurs, the program outputs counts of processed and rewritten records, closes the database connection, and terminates.

**Program Linkages**  
- acas-get-params  
- acasirsub5  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at aa000-main-start, performing argument parsing, system file opening, and loading RDBMS parameters before proceeding to data processing. [Seen in: aa000-main-start.]  
It then enters the record processing loop via aa010-Read, reading each IRS final record, writing it to the database, handling duplicates or errors, and updating counters. [Seen in: aa010-Read.]  
Upon completion of all records, the program executes aa999-Finish to commit any remaining changes, close files, and exit. [Seen in: aa999-Finish.]

5.2 Initialization  
The program parses command line arguments with zz020-Get-Program-Args and sets up logging identifiers. [Seen in: aa000-main-start.]  
It opens the system file, reads the system record, and validates the RDBMS configuration, loading defaults from acas.param if necessary. [Seen in: aa000-main-start.]  
If RDBMS parameters are missing, the program aborts with an error message. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: aa000-main-start during system file read  
Key steps: open System-File, read record, check fs-reply, load RDBMS fields, possibly call acas-get-params  
I/O: System-File  
Outcomes: RDBMS-Host, User, Passwd, DB-Name, Port, Socket set; flags for file system used  
[Seen in: aa000-main-start.]

Path: Override Process  
Trigger: aa010-Proc-Override  
Key steps: set Log-file-rec-written to zero, set File-System-Used to 1, set File-Key-No to 1, go to aa010-Read  
I/O: none  
Outcomes: prepares for RDB processing  
[Seen in: aa010-Proc-Override.]

Path: Record Read/Write  
Trigger: aa010-Read loop  
Key steps: acasirsub5-Read-Next, check EOF, write via acasirsub5-Write, handle duplicate key via rewrite, error handling, increment counters  
I/O: System-File (via acasirsub5), database via acasirsub5  
Outcomes: counters updated, errors reported, possible rewrite  
[Seen in: aa010-Read.]

Path: Commit  
Trigger: aa030-Commit (called after successful writes)  
Key steps: call MySQL_commit  
I/O: none  
Outcomes: transaction committed  
[Seen in: aa030-Commit.]

Path: Finish  
Trigger: aa999-Finish  
Key steps: output record counts, close System-File, set flags, goback  
I/O: System-File  
Outcomes: program exits  
[Seen in: aa999-Finish.]

5.4 Termination  
The program finalizes by closing the system file, resetting file system flags, and printing an end‑of‑job message before returning control. [Seen in: aa999-Finish.]  
It then performs a GOBACK to terminate execution. [Seen in: aa999-Finish.]

---
## irsfinalMT
*[103/267]*

### Business/Functional Perspective
### IRS Final Table Handler  

**Program Purpose**  
The program manages records in the IRS FINAL database table. It opens a connection to the database, retrieves up to 26 rows, and can insert or update rows supplied by higher‑level modules. By enforcing unique keys and recording any database errors, it helps maintain accurate IRS tax data and supports audit‑ready reporting. The module is called by other accounting routines rather than used directly by end users.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – The requested operation completes without error.  
- **No Data** – When a read request returns no rows, the program reports that no data was found.  
- **Duplicate Key** – If an insert or update attempts to use a key that already exists, a duplicate‑key error is returned.  
- **Database Failure** – Any other database error (connection loss, syntax error, etc.) results in a general error message.  
- **Internal Failure** – Unexpected internal failures generate a generic error indicator for the caller to handle.  

**User Flow Summary**  
A higher‑level routine initiates the process by calling this module with a file‑function code. The module first opens a database connection, then performs the requested action:  
1. **Open** – Establishes the MySQL session.  
2. **Read‑Next** – Executes a SELECT query, fetches up to 26 rows, and populates a record structure that the caller can use for display or further processing.  
3. **Write** – Loops through supplied rows, inserting each into the table and handling duplicate‑key situations.  
4. **Rewrite** – Updates existing rows based on their key values.  
After each operation the module logs the activity, clears any temporary resources, and returns a status code and key information to the calling routine. If any step fails, an error status is returned and logged for review.  

**Program Linkages**  
- MySQL_errno  
- MySQL_error  
- MySQL_sqlstate  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **ba-ACAS-DAL-Process**, where it sets screen exception flags and then evaluates **File-Function** to dispatch to the appropriate database operation paragraph. [Seen in: ba-ACAS-DAL-Process.]  
Each dispatched paragraph (Open, Close, Read‑Next, Write, Rewrite, or Bad‑Function) performs its MySQL operation and then transfers control to **ba999‑exit** for program termination. [Seen in: ba-ACAS-DAL-Process.]  
On exit, **ba999‑end** performs optional logging before the program exits via **ba999‑exit**. [Seen in: ba999‑end.]

5.2 Initialization  
The **ba010‑Initialise** paragraph accepts environment lines, sets screen exception flags, and clears all error and status fields before dispatching to the requested operation. [Seen in: ba010‑Initialise.]  
The program also initializes the MySQL command buffer and related variables in the same paragraph. [Seen in: ba010‑Initialise.]

5.3 Core Processing  

Path: Open  
Trigger: File‑Function = 1  
Key steps: Construct MySQL connection parameters, perform **MYSQL‑1000‑OPEN** to establish a connection, and set cursor state to inactive.  
I/O: MySQL connection (no tables accessed).  
Outcomes: Successful open sets **Most‑Cursor‑Set** to 0 and returns to exit; on error, sets **fs‑Reply** and **WE‑Error**.  
[Seen in: ba020‑Process‑Open.]

Path: Read‑Next  
Trigger: File‑Function = 3  
Key steps: If cursor inactive, build a SELECT statement for all rows where key > "000", execute it, store the result set, and fetch up to 26 rows into AR1/AR2 arrays.  
I/O: Reads from **IRSFINAL‑REC** table via MySQL SELECT and FETCH.  
Outcomes: Populates AR1/AR2, sets **WS‑File‑Key** to the last key read, and sets **fs‑Reply** and **WE‑Error** to zero on success; on no data or fetch error, sets appropriate error codes and flags.  
[Seen in: ba040‑Process‑Read‑Next.]

Path: Write  
Trigger: File‑Function = 5  
Key steps: Loop over 1‑26, construct an INSERT statement for each populated AR1/AR2 entry, execute it, and capture any duplicate‑key or other MySQL errors.  
I/O: Writes to **IRSFINAL‑REC** table via MySQL INSERT.  
Outcomes: Records inserted; if a duplicate key occurs, **fs‑Reply** set to 22; other errors set to 99; the last error is preserved for the final status.  
[Seen in: ba070‑Process‑Write.]

Path: Rewrite  
Trigger: File‑Function = 7  
Key steps: Loop over 1‑26, build an UPDATE statement for each AR1/AR2 entry using the key, execute it, and handle MySQL errors.  
I/O: Updates **IRSFINAL‑REC** table via MySQL UPDATE.  
Outcomes: Updated records; on error, **fs‑Reply** set to 99 and **WE‑Error** to 994; otherwise status cleared.  
[Seen in: ba090‑Process‑Rewrite.]

Path: Bad‑Function  
Trigger: File‑Function not 1,2,3,5,7  
Key steps: Set generic error codes **WE‑Error** = 990 and **fs‑Reply** = 99, then exit.  
I/O: None.  
Outcomes: Signals invalid function request to caller.  
[Seen in: ba100‑Bad‑Function.]

5.4 Termination  
The **ba999‑end** paragraph optionally logs activity if **Testing‑1** is set, then proceeds to **ba999‑exit** which performs the program exit. [Seen in: ba999‑end.]  
The **ba999‑exit** paragraph simply exits the program, completing the processing cycle. [Seen in: ba999‑exit.]

---
## irsfinalRES
*[104/267]*

### Business/Functional Perspective
### IRS Final File Restore  

**Program Purpose**  
The program rebuilds the IRS final data file from a sequential backup archive. It copies each record from the backup file to the live IRS final file, ensuring the restored file contains all original data. This process supports routine data recovery, audit trails, and compliance with record‑keeping requirements, reducing the risk of data loss during system maintenance or migration.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry or batch step and returns results back to that context.  

**Messages and Errors**  
- Indicates if the backup file is missing.  
- Reports failures opening the live IRS final file.  
- Signals problems reading the backup file.  
- Alerts to write errors when creating the live file.  
- Provides a summary of records read and written.  

**User Flow Summary**  
The user initiates the restore by running the program, typically from a command line with optional arguments. The program checks for the presence of the backup archive and opens it. It then reads each record, writes it to the live IRS final file, and logs progress messages. Upon completion, the program displays the total number of records processed and terminates, leaving the restored file ready for use.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-Main-Start, retrieves command line arguments and initializes logging parameters. [Seen in: aa000-Main-Start.]  
It then opens the source sequential file irsfinal.seq for input and the target final-File for output, handling any open errors. [Seen in: aa000-Main-Start.]  
The main processing loop reads each record from the source, writes it to the final file, and counts records until end‑of‑file, after which it closes files and reports totals. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and sets logging system and file numbers. [Seen in: aa000-Main-Start.]  
It opens the input and output files, initializing record counters to zero and preparing for processing. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Successful Read/Write Loop  
Trigger: Input and output files opened successfully and FS-Reply zero.  
Key steps: Loop reading records, increment input counter, write to final file, increment output counter, handle read/write errors.  
I/O: irsfinal-File-Seq, Final-File.  
Outcomes: Record counts updated, errors logged via Call‑Sysout, loop exits on EOF or error.  
[Seen in: aa010-Read-Recs.]

Path: Input File Open Failure  
Trigger: FS-Reply non‑zero after opening irsfinal-File-Seq.  
Key steps: Log message “No irsdefault file to process”, close Final-File, exit.  
I/O: Final-File.  
Outcomes: Program terminates early with goback.  
[Seen in: aa000-Main-Start.]

Path: Output File Open Failure  
Trigger: FS-Reply non‑zero after opening Final-File.  
Key steps: Log failure message with FS-Reply, close Final-File, exit.  
I/O: Final-File.  
Outcomes: Program terminates early with goback.  
[Seen in: aa000-Main-Start.]

Path: Read Error  
Trigger: FS-Reply non‑zero during read of irsfinal-File-Seq.  
Key steps: Log SY003 with FS-Reply, exit loop to finish.  
I/O: irsfinal-File-Seq.  
Outcomes: Loop terminates, proceeds to finish.  
[Seen in: aa010-Read-Recs.]

Path: Write Error  
Trigger: FS-Reply non‑zero during write to Final-File.  
Key steps: Log SY006, exit loop to finish.  
I/O: Final-File.  
Outcomes: Loop terminates, proceeds to finish.  
[Seen in: aa010-Read-Recs.]

Path: End-of-File  
Trigger: End of input file reached.  
Key steps: Go to aa020-Finish-Off, close files, log totals.  
I/O: irsfinal-File-Seq, Final-File.  
Outcomes: Program completes, sets Return-Code zero, goback.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs the record counts, sets Return-Code to zero, and exits via goback. [Seen in: aa020-Finish-Off.]  
All cleanup is performed within aa020-Finish-Off, ensuring no open file descriptors remain. [Seen in: aa020-Finish-Off.]

---
## irsfinalUNL
*[105/267]*

### Business/Functional Perspective
### IRS Final File Unload  

**Program Purpose**  
The program creates a sequential backup of the IRS final file. It copies each record from the existing ISAM file to a new file named *irsfinal.seq* and records progress in a system log. The backup protects data integrity and provides a recoverable copy for audit or restore operations.  

**Screen Interactions**  
No direct screens. This program is run automatically after a data‑entry step and writes its results to a log file that can be reviewed by an operator.  

**Messages and Errors**  
- Indicates if the original IRS file cannot be opened or is missing.  
- Reports read‑errors when a record cannot be retrieved.  
- Reports write‑errors when a record cannot be written to the backup file.  
- Flags incorrect program arguments or missing environment settings.  

**User Flow Summary**  
An operator or scheduler starts the program with optional arguments. The program opens the source IRS file and, if it is present, reads each record in turn. Each record is written to the sequential backup file. Throughout the process, status messages are written to a system log. When all records have been processed or an error occurs, the program closes the files, writes a final summary of how many records were read and written, and then exits. The operator can view the log to confirm successful completion or diagnose any errors.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at aa000-Main-Start, performing argument retrieval, logging setup, and a header output via Call‑Sysout. [Seen in: aa000-Main-Start.]  
It then opens the source Final‑File for input, verifies the status, and opens the destination irsfinal‑File‑Seq for output, initializing record counters. [Seen in: aa000-Main-Start.]  
The core processing loop aa010‑Read‑Recs reads each record, writes it to the sequential file, and updates counters until end‑of‑file or an error occurs, after which control passes to aa020‑Finish‑Off for cleanup and summary output. [Seen in: aa010-Read-Recs.]

5.2 Initialization  
The program retrieves command‑line arguments via zz020‑Get‑Program‑Args, sets logging parameters (WS‑Log‑System and WS‑Log‑File‑no), and prints a startup message using Call‑Sysout. [Seen in: aa000-Main-Start.]  
It opens Final‑File for input, checks FS‑Reply for errors, then opens irsfinal‑File‑Seq for output, and initializes ws‑Rec‑Cnt‑In and ws‑Rec‑Cnt‑Out to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Read Loop  
Trigger: Execution of aa010‑Read‑Recs loop.  
Key steps: Read next record from Final‑File; on end‑of‑file go to aa020‑Finish‑Off; on read error output SY003 and finish; increment ws‑Rec‑Cnt‑In; write WS‑Final‑Record to irsfinal‑File‑Seq; on write error output SY006 and finish; increment ws‑Rec‑Cnt‑Out.  
I/O: Final‑File, irsfinal‑File‑Seq.  
Outcomes: Record counters updated; errors cause early termination.  
[Seen in: aa010-Read-Recs.]

Path: Input File Open Error  
Trigger: FS‑Reply not zero after opening Final‑File.  
Key steps: Output error message “No irsdefault file to process”, close Final‑File, log closure, and goback.  
I/O: Final‑File.  
Outcomes: Program exits before processing any records.  
[Seen in: aa000-Main-Start.]

Path: Write Error  
Trigger: FS‑Reply not zero after writing to irsfinal‑File‑Seq.  
Key steps: Output SY006 via Call‑Sysout and go to aa020‑Finish‑Off.  
I/O: irsfinal‑File‑Seq.  
Outcomes: Termination of loop, cleanup, and summary output.  
[Seen in: aa010-Read-Recs.]

Path: Finish‑Off  
Trigger: Completion of reading loop or any error path.  
Key steps: Close irsfinal‑File‑Seq and Final‑File; output record count summary; log closure; set Return‑Code to zero; goback.  
I/O: irsfinal‑File‑Seq, Final‑File.  
Outcomes: Files closed, summary logged, program exits cleanly.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs a final summary of records processed, sets Return‑Code to zero, and exits via goback. [Seen in: aa020-Finish-Off.]  
All cleanup actions are performed in aa020‑Finish‑Off, ensuring no open file descriptors remain. [Seen in: aa020-Finish-Off.]

---
## irsnominalLD
*[106/267]*

### Business/Functional Perspective
### IRS Nominal Table Load  

#### Program Purpose  
The program transfers IRS nominal records from a flat file into the MySQL nominal table used by the accounting system. It validates the data file, applies duplicate‑key logic, logs progress and any errors, and ensures that the database is correctly configured before data insertion. This process keeps the accounting database current and accurate, supporting auditability and compliance with tax reporting requirements.  

#### Screen Interactions  
No direct screens. This program is invoked by a batch or script after data entry and displays only log messages to the system console or log file.  

#### Messages and Errors  
- **File access issues** – unable to open or read the nominal file, or the system configuration file is missing or corrupt.  
- **Database configuration problems** – database name, user, host, or connection details are not supplied.  
- **Missing nominal file** – no data file is found; the program terminates with a “nothing to do” message.  
- **Duplicate key detected** – when a record already exists, it is rewritten and counted; the error is logged but processing continues.  
- **Write or transaction failures** – any error writing to the database (other than a duplicate) is logged with details and the program aborts.  
- **General operational failures** – any unexpected reply from the data access module causes a log entry and program termination.  

#### User Flow Summary  
1. The user (or automated system) runs the program with optional command‑line arguments.  
2. The program reads the system configuration file to obtain database connection settings; if these are missing, it attempts to load them from an auxiliary parameter file.  
3. It opens the IRS nominal data file for reading and the MySQL nominal table for writing.  
4. The program reads each record, ignores any with a zero key, and attempts to insert it into the database.  
5. If the record already exists, it is rewritten; all insert attempts are counted.  
6. Any non‑duplicate write error causes the program to log details and abort.  
7. Upon reaching the end of the file, the program outputs a summary of records processed, rewritten, and logged, then closes all files and exits.  

#### Program Linkages  
- acas-get-params  
- acasirsub1  
- ACAS-Sysout  
- MySQL_rollback  
- MySQL_commit

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program starts at paragraph **aa000-main-start**, performing argument parsing, system file opening, and database parameter loading before opening the nominal file and RDB table. It then enters the **aa010-Read** loop, reading each nominal record, writing it to the RDB table, handling duplicates, and counting processed records. Upon reaching end‑of‑file or encountering an unrecoverable error, control passes to **aa999-Finish**, where statistics are logged, files are closed, and the program exits. [Seen in: aa000-main-start, aa010-Read, aa999-Finish.]

5.2 Initialization  
The program parses command‑line arguments via **zz020-Get-Program-Args**, sets logging identifiers, and opens the system parameter file; it reads the first system record and, if necessary, retrieves RDBMS settings from **acas-get-params**. It then opens the nominal file for input and the RDB table for output through **acasirsub1-Open-Input** and **acasirsub1-Open-Output** before proceeding to the main read loop. [Seen in: aa000-main-start, aa010-Proc-Override.]

5.3 Core Processing  
Path: Nominal File Load  
Trigger: Entry to **aa010-Read** loop after files are opened.  
Key steps: read next nominal record, skip zero keys, write record to RDB via **acasirsub1-Write-Raw**, increment input and output counters, and loop until EOF.  
I/O: System file (read once), nominal file (read), RDB table (write).  
Outcomes: Updated record counters, potential error flags set for later handling.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: Duplicate key detected during **acasirsub1-Write-Raw** (SQL‑State "23000" or fs‑reply 22/99).  
Key steps: clear error flags, rewrite the existing record via **acasirsub1-Rewrite**, increment rewrite counter, and continue reading.  
I/O: RDB table (rewrite).  
Outcomes: Duplicate record updated, counters adjusted, processing continues.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: Any fs‑reply not zero during read or write operations.  
Key steps: log error message via **Call‑Sysout**, optionally rollback (commented out), set return‑code, and exit to **aa999-Finish**.  
I/O: System file (closed), nominal file (closed), RDB table (closed).  
Outcomes: Program terminates with error status, cleanup performed.  
[Seen in: aa100-Check-4-Errors, aa010-Read.]

Path: Finish  
Trigger: End‑of‑file reached or error exit.  
Key steps: log record counts and log‑file statistics, close RDB and nominal files, close system file, and perform final log messages before **GOBACK**.  
I/O: System file, nominal file, RDB table.  
Outcomes: All resources released, program exits cleanly.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program logs final statistics, closes the RDB and nominal files, closes the system file, and performs a final log message before returning control to the caller. [Seen in: aa999-Finish.]

---
## irsnominalMT
*[107/267]*

### Business/Functional Perspective
### IRS Nominal Record Handler  

#### Program Purpose  
The program provides a single interface for accessing the IRS nominal table in the accounting system. It allows callers to open and close the database connection, read records sequentially or by key, add new records, modify existing ones, and delete records—including the ability to clear the entire table. By centralising these operations, the program ensures data integrity, enforces unique keys, and logs any database errors for audit and troubleshooting purposes.  

#### Screen Interactions  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

#### Messages and Errors  
* **Open/Close errors** – reports problems connecting to or disconnecting from the database.  
* **Record not found** – returned when a requested key does not exist in the table.  
* **Duplicate key** – issued when attempting to insert a record that already exists.  
* **Database error** – generic message for SQL problems such as syntax errors or constraints violations.  
* **End‑of‑data** – indicates that a read‑next operation has reached the end of the table.  

#### User Flow Summary  
1. **Open** – The user or calling module starts the program, which opens a connection to the IRS nominal table and prepares the cursor.  
2. **Read or Search** – The user requests a record by key or sequentially. The program retrieves the record, fills the data structure, and returns the data together with a status code indicating success or the reason for failure.  
3. **Write/Update** – When adding or changing a record, the user provides the new data. The program validates the input, performs the database operation, and reports success or any constraint violations (e.g., duplicate keys).  
4. **Delete** – The user can remove a specific record or clear the entire table. The program executes the delete and returns a confirmation status.  
5. **Close** – After operations are complete, the user or caller closes the connection. The program ensures all cursors are released and logs the action.  

Throughout the session, the program uses internal status indicators (e.g., FS‑Reply, WE‑Error) to convey success, failure, or database error details back to the calling context.  

#### Program Linkages  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs at **ba-ACAS-DAL-Process**, which sets up screen exceptions and initializes environment variables. [Seen in: ba-ACAS-DAL-Process.]  
The **File-Function** value determines the operation via an EVALUATE statement, dispatching to specific paragraphs for open, close, read, write, delete, etc. [Seen in: ba-ACAS-DAL-Process.]  
After performing the requested operation, control flows to **ba999-end** for cleanup and exit. [Seen in: ba999-end.]

5.2 Initialization  
**ba010-Initialise** clears error flags (**We-Error**, **Fs-Reply**) and resets SQL message buffers. [Seen in: ba010-Initialise.]  
Screen environment variables are set to detect exceptions and escape keys before any database action. [Seen in: ba-ACAS-DAL-Process.]

5.3 Core Processing  

Path: **Open**  
Trigger: **File-Function = 1**. [Seen in: ba020-Process-Open.]  
Key steps: Build MySQL connection parameters from DB-Host, DB-User, etc.; perform **MYSQL-1000-OPEN**; set cursor inactive; log operation. [Seen in: ba020-Process-Open.]  
I/O: None (initializes connection). [Seen in: ba020-Process-Open.]  
Outcomes: **fs-reply** set to zero on success; **ws-No-Paragraph** set to 1; **WS-File-Key** set to "OPEN IRSNOMINAL (RDB)". [Seen in: ba020-Process-Open.]

Path: **Read-Next**  
Trigger: **File-Function = 3**. [Seen in: ba040-Process-Read-Next.]  
Key steps: If cursor inactive, construct WHERE clause for TIPE='O' and key > '0000000000'; execute SELECT; fetch first row; set cursor active; load HVs into record. [Seen in: ba040-Process-Read-Next, ba041-Reread.]  
I/O: IRSNL-REC table via **MYSQL-1210-COMMAND** and **MYSQL-1220-STORE-RESULT**. [Seen in: ba040-Process-Read-Next.]  
Outcomes: **WE-Error** set to 3 on EOF; **fs-reply** set to 10 on error; record fields populated; **WS-File-Key** set to key value. [Seen in: ba040-Process-Read-Next.]

Path: **Read-Indexed**  
Trigger: **File-Function = 4**. [Seen in: ba050-Process-Read-Indexed.]  
Key steps: Build WHERE clause using key value; execute SELECT; fetch row; load HVs into record; handle not-found errors. [Seen in: ba050-Process-Read-Indexed.]  
I/O: IRSNL-REC table via **MYSQL-1210-COMMAND** and **MYSQL-1220-STORE-RESULT**. [Seen in: ba050-Process-Read-Indexed.]  
Outcomes: **fs-reply** set to 21 on not found; **WE-Error** set to 2; record fields populated; **WS-File-Key** set to key. [Seen in: ba050-Process-Read-Indexed.]

Path: **Write**  
Trigger: **File-Function = 5**. [Seen in: ba070-Process-Write.]  
Key steps: Load host variables from record (**bb000-HV-Load**); perform INSERT via **bb200-Insert**; handle duplicate key errors; optionally rewrite owner record if sub‑nominal. [Seen in: ba070-Process-Write, bb200-Insert, ba072-Proc-Write-Subs, ba073-Fix-Up-Subs.]  
I/O: IRSNL-REC table via **MYSQL-1210-COMMAND**. [Seen in: bb200-Insert.]  
Outcomes: **fs-reply** set to 22 on duplicate; **WE-Error** set to 994 on rewrite failure; record inserted or updated; **WS-File-Key** set to key. [Seen in: ba070-Process-Write.]

Path: **Delete**  
Trigger: **File-Function = 8**. [Seen in: ba080-Process-Delete.]  
Key steps: Build WHERE clause for key; execute DELETE; if owner, exit; else delete pointer record. [Seen in: ba080-Process-Delete.]  
I/O: IRSNL-REC table via **MYSQL-1210-COMMAND**. [Seen in: ba080-Process-Delete.]  
Outcomes: **fs-reply** set to 99 on error; **WE-Error** set to 995 on delete failure; record removed; **WS-File-Key** set to key. [Seen in: ba080-Process-Delete.]

Path: **Rewrite**  
Trigger: **File-Function = 7**. [Seen in: ba090-Process-Rewrite.]  
Key steps: Load host variables (**bb000-HV-Load**); perform UPDATE via **bb300-Update**; handle errors; log. [Seen in: ba090-Process-Rewrite, bb300-Update.]  
I/O: IRSNL-REC table via **MYSQL-1210-COMMAND**. [Seen in: bb300-Update.]  
Outcomes: **fs-reply** set to 99 on error; **WE-Error** set to 994 on failure; record updated; **WS-File-Key** set to key. [Seen in: ba090-Process-Rewrite.]

5.4 Termination  
**ba999-end** performs optional logging via **Ca-Process-Logs**, then transfers control to **ba999-exit**. [Seen in: ba999-end.]  
**ba999-exit** exits the program with `EXIT PROGRAM`. [Seen in: ba999-exit.]

---
## irsnominalRES
*[108/267]*

### Business/Functional Perspective
### IRS Nominal Ledger Restore  

**Program Purpose**  
The program recreates the IRS nominal ledger by copying records from a sequential backup file into the indexed nominal ledger file. It provides a reliable restore path for accounting data, ensuring that the ledger can be rebuilt after data loss or corruption. This helps maintain regulatory compliance, audit readiness, and overall data integrity for the accounting system.  

**Screen Interactions**  
No direct screens. This program is run from the command line or as a scheduled task and writes status messages to a log file.  

**Messages and Errors**  
- If the backup file is missing or unreadable, a message is logged: “No irsnominal file to process.”  
- If the target ledger file cannot be opened for writing, an error is logged with the system status.  
- Any error while reading a record from the backup file is reported with a “Problem reading .seq file” message.  
- If a record fails to write to the ledger, a “Write error on .dat file” message is logged.  
- Upon completion, a summary of records read and written is logged.  

**User Flow Summary**  
The user initiates the restore program, typically after a backup has been created or when a data restoration is required. The program automatically opens the backup sequential file and the nominal ledger file. It reads each record from the backup, writes it to the ledger, and counts the processed records. Throughout the process, the program writes status messages to a log file, allowing the user to review progress and confirm successful restoration. If any step fails, an explanatory message is logged, enabling the user to investigate and resolve the issue.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and initializing logging parameters, then attempts to open the source sequential file and the destination indexed file, exiting if either open fails. [Seen in: aa000-Main-Start.]  
It reads each record from the sequential file, writes it to the indexed file while maintaining input and output record counts, and handles any read or write errors by logging a message and terminating the loop. [Seen in: aa010-Read-Recs.]  
Upon completion or error, it closes both files, logs the total records processed, sets the return code to zero, and exits the program. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs a PERFORM of zz020-Get-Program-Args to capture command‑line parameters, then sets the logging system identifiers and logs an initial message. [Seen in: aa000-Main-Start.]  
It opens the input sequential file (irsnominal-File-Seq) and the output indexed file (nominal-ledger), checking the FS-Reply status after each open and aborting with a log message if an error occurs. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Open Files  
Trigger: After program arguments are retrieved.  
Key steps: open irsnominal-File-Seq for input, check FS-Reply; open nominal-ledger for output, check FS-Reply.  
I/O: irsnominal-File-Seq, nominal-ledger.  
Outcomes: files opened successfully or program exits with error.  
[Seen in: aa000-Main-Start.]

Path: Read and Write Records  
Trigger: Each iteration of the forever loop in aa010-Read-Recs.  
Key steps: read next record from irsnominal-File-Seq, check FS-Reply; write record to nominal-ledger, check FS-Reply; increment input and output counters; on error log message and exit loop.  
I/O: irsnominal-File-Seq, nominal-ledger.  
Outcomes: records transferred, counters updated, or error handling invoked.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: End of the read loop (end‑of‑file or error).  
Key steps: close irsnominal-File-Seq and nominal-ledger, log total records processed, set Return-Code to zero, goback.  
I/O: irsnominal-File-Seq, nominal-ledger.  
Outcomes: files closed, program terminates cleanly.  
[Seen in: aa020-Finish-Off.]

Path: Logging Start  
Trigger: Immediately after initialization.  
Key steps: set SO-Print with program name and file usage, call Call‑Sysout to write the message.  
I/O: none.  
Outcomes: initial log entry created.  
[Seen in: aa000-Main-Start.]

5.4 Termination  
The program closes both the input and output files, logs the final record counts, sets the return code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]  
All file handles are released before the program terminates. [Seen in: aa020-Finish-Off.]

---
## irsnominalUNL
*[109/267]*

### Business/Functional Perspective
### IRS Nominal File Backup  

**Program Purpose**  
The program copies all records from the indexed IRS nominal ledger file to a new sequential file named *irsacnts.seq*. It creates a backup that can be used for recovery or for generating reports that require sequential file access. The backup preserves record integrity and provides a simple, reliable way to archive the nominal data without affecting the live system.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the source nominal file cannot be opened, the user sees a “No IRS nominal file to process” message.  
- Read failures produce a “Problem reading IRS nominal file” warning.  
- Write failures to the sequential file generate a “Write error on .seq file” notification.  
- Incorrect command‑line arguments trigger an “Program arguments incorrect” notice.  
- Missing required environment settings result in an “Environment variables not yet set up : ABORTING” alert.  

**User Flow Summary**  
The user runs the program (typically from a command line or job scheduler) with any required arguments. The program opens the indexed IRS nominal ledger file and creates a new sequential file. It reads each record, writes it to the sequential file, and counts the number of records processed. After all records are copied, it closes the files, logs a summary of records in and out, and exits. If any errors occur—such as the source file missing, read errors, or write failures—the program logs an appropriate message and stops further processing. All messages are written to *SYS-DISPLAY.log* via the ACAS‑Sysout routine, allowing the user to review the outcome.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command line arguments and initializing logging parameters before opening the indexed irsnominal file for reading. [Seen in: aa000-Main-Start.]  
It then enters a loop that reads each record from the indexed file, writes it to a sequential output file, and counts input and output records, handling any read or write errors by logging and aborting. [Seen in: aa010-Read-Recs.]  
Upon reaching the end of the input file or encountering an error, the program closes both files, logs a summary of records processed, sets the return code to zero, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and sets up logging system identifiers before opening the nominal-ledger file for input. [Seen in: aa000-Main-Start.]  
If the nominal-ledger file cannot be opened, it logs a message and terminates early. [Seen in: aa000-Main-Start.]  
It then opens the output sequential file irsnominal-File-Seq for writing and initializes record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Read/Write Loop  
Trigger: Successful open of nominal-ledger and irsnominal-File-Seq  
Key steps: Loop reading records, writing to seq file, increment counters, error handling  
I/O: Nominal-Ledger (indexed), irsnominal-File-Seq (sequential)  
Outcomes: ws-Rec-Cnt-In and ws-Rec-Cnt-Out updated, errors logged, program may exit on error  
[Seen in: aa010-Read-Recs.]  

Path: Input File Not Found  
Trigger: FS-Reply not equal to zeros after opening Nominal-Ledger  
Key steps: Log "No irsnominal file to process", close file, goback  
I/O: Nominal-Ledger  
Outcomes: Program exits without processing any records  
[Seen in: aa000-Main-Start.]  

Path: Read Error During Loop  
Trigger: FS-Reply not equal to zeros during read  
Key steps: Log SY003 with FS-Reply, go to finish-off  
I/O: Nominal-Ledger  
Outcomes: Program exits loop, closes files, logs summary  
[Seen in: aa010-Read-Recs.]  

Path: Write Error During Loop  
Trigger: FS-Reply not equal to zero after write  
Key steps: Log SY006, go to finish-off  
I/O: irsnominal-File-Seq  
Outcomes: Program exits loop, closes files, logs summary  
[Seen in: aa010-Read-Recs.]  

Path: End of File  
Trigger: Read reaches end  
Key steps: Go to aa020-Finish-Off  
I/O: Nominal-Ledger  
Outcomes: Close files, log summary, exit  
[Seen in: aa010-Read-Recs.]

5.4 Termination  
The program closes both the input and output files, logs a summary of records processed, sets the return code to zero, and performs a GOBACK to terminate. [Seen in: aa020-Finish-Off.]  
Any earlier error paths also perform a GOBACK after logging the error and closing the input file. [Seen in: aa000-Main-Start.]

---
## irsnominalUNL2
*[110/267]*

### Business/Functional Perspective
### IRS Nominal Backup  

**Program Purpose**  
The program creates a backup copy of the IRS nominal ledger by transferring every record from the indexed file into a sequential file named *irsacnts.seq*. This allows system administrators to restore the ledger if the original becomes corrupted or inaccessible. The operation logs progress and any problems to the system log for audit and troubleshooting purposes.  

**Screen Interactions**  
No direct screens. This program runs in the background and records its status in the system log.  

**Messages and Errors**  
- File not found or cannot be opened.  
- Error reading a record from the source file.  
- Error writing a record to the backup file.  
- Missing or incorrect command‑line arguments.  
- Environment variables required for the program are not set.  

**User Flow Summary**  
1. The user initiates the program (typically via a command line or scheduled job).  
2. The program attempts to open the IRS nominal ledger; if the file is missing it records a message and ends.  
3. It then opens the backup sequential file.  
4. For each record in the ledger, the program copies the record to the backup file, keeping a count of records processed.  
5. If any read or write error occurs, the program logs the issue, displays the problematic record, pauses for the user to press Enter, and then stops.  
6. After all records have been processed or an error stops the run, the program logs the total number of records read and written, closes both files, and exits.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and initializing logging parameters. [Seen in: aa000-Main-Start.]  
It then opens the indexed irsnominal file for input and a sequential output file for writing, handling the case where the input file is missing. [Seen in: aa000-Main-Start.]  
A loop reads each record from the input file, copies it to the output file, and counts records, terminating when the end of file is reached or an error occurs. [Seen in: aa010-Read-Recs.]  
After processing, the program closes both files, reports the record counts, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs a call to zz020-Get-Program-Args to capture command‑line arguments and sets up logging identifiers for the IRS system. [Seen in: aa000-Main-Start.]  
It opens the nominal‑ledger file for input and the irsnominal‑File‑Seq for output, initializing record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Processing  
Trigger: Successful open of both input and output files and no early exit.  
Key steps: Read each record from Nominal‑Ledger, copy to WS‑Nominal‑Record, write to irsnominal‑File‑Seq, increment counters.  
I/O: Nominal‑Ledger (input), irsnominal‑File‑Seq (output).  
Outcomes: Record counts incremented; any write error causes exit to Finish‑Off.  
[Seen in: aa010-Read-Recs.]

Path: Read‑Error Handling  
Trigger: FS‑Reply non‑zero after a READ of Nominal‑Ledger.  
Key steps: Construct error message with SY003 and FS‑Reply, log via Call‑Sysout, exit to Finish‑Off.  
I/O: Nominal‑Ledger (input).  
Outcomes: Program terminates early, no records written.  
[Seen in: aa010-Read-Recs.]

Path: Write‑Error Handling  
Trigger: FS‑Reply non‑zero after a WRITE to irsnominal‑File‑Seq.  
Key steps: Construct error message with SY006 and FS‑Reply, log via Call‑Sysout, display record and prompt user, exit to Finish‑Off.  
I/O: irsnominal‑File‑Seq (output).  
Outcomes: Program terminates early, partial output may exist.  
[Seen in: aa010-Read-Recs.]

Path: Missing‑Input‑File  
Trigger: FS‑Reply non‑zero after attempting to OPEN Nominal‑Ledger.  
Key steps: Log message “No irsnominal file to process”, close file, exit.  
I/O: Nominal‑Ledger (input).  
Outcomes: Program exits without processing any records.  
[Seen in: aa000-Main-Start.]

5.4 Termination  
The program closes both the input and output files, logs the total records processed, and sets Return‑Code to zero before GOBACK. [Seen in: aa020-Finish-Off.]  
All logging is performed via Call‑Sysout, which calls the external ACAS‑Sysout routine. [Seen in: Call‑Sysout.]

---
## irspostingLD
*[111/267]*

### Business/Functional Perspective
### IRS Posting Table Load  

**Program Purpose**  
This program imports IRS posting data from a text‑formatted file into a MySQL database table. It is used by accounting staff to refresh the posting table for reporting and compliance purposes. The process can be limited to a specific date range, making it useful for testing or partial updates. By handling duplicate records and reporting failures, it ensures the database remains accurate and audit‑ready.  

**Screen Interactions**  
No direct screens. The program runs from the command line, displays status and error messages to the console, and then exits.  

**Messages and Errors**  
- **Missing or invalid command‑line arguments** – prompts that the supplied dates are incorrect or too many arguments were given.  
- **System or database configuration missing** – indicates that required database settings were not found in the parameter file.  
- **Posting file not found** – stops the run when the expected input file is absent.  
- **File or database open errors** – reports problems opening the input file or the MySQL table.  
- **Duplicate record** – notes that an entry already exists and is ignored, but counts it as a rewrite.  
- **Write or commit failure** – signals a serious problem with the database transaction and terminates the load.  
- **General error** – shows details of any unexpected failure (error code, message, SQL state) and aborts.  

**User Flow Summary**  
1. The user runs the program from a terminal, optionally supplying a start and end date in the form `YYMMDD`.  
2. The program reads system parameters to obtain MySQL connection details.  
3. It opens the IRS posting file and the MySQL table.  
4. Each record in the file is processed: if a date range was supplied, records outside that range are skipped; otherwise all records are transferred.  
5. Records that duplicate existing entries are noted and skipped.  
6. Successful writes are committed; any database error causes a rollback and the program stops.  
7. Upon completion, the program prints a summary: number of records read, number written, and number rewritten due to duplicates.  
8. The program exits, leaving the database updated for use by other accounting functions.  

**Program Linkages**  
- acas-get-params  
- acasirsub4  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins in aa000-main-start, performing argument parsing, system file opening, and parameter loading before proceeding to data transfer. [Seen in: aa000-main-start.]  
The core data transfer loop is handled in aa010-Read, which reads each posting record, applies optional date filtering, and writes or rewrites records into the MySQL posting table. [Seen in: aa010-Read.]  
Upon completion, aa999-Finish summarizes counts, closes all files and database connections, and exits. [Seen in: aa999-Finish.]

5.2 Initialization  
The program initializes by calling zz020-Get-Program-Args, setting logging parameters, and validating optional start/end dates. [Seen in: aa000-main-start.]  
It opens the system parameter file, reads the RDBMS configuration, and may invoke acas-get-params to obtain missing database settings before proceeding. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Setup (aa010-Proc-Override)  
Trigger: After system file read, before opening posting file.  
Key steps: set file system flags, open posting file via acasirsub4-Open-Input, open RDB via acasirsub4-Open, initialize access type, then go to aa010-Read.  
I/O: System-File, Posting-File, RDB via acasirsub4.  
Outcomes: Files opened, flags set, ready for read loop.  
[Seen in: aa010-Proc-Override.]

Path: Posting File Open (acasirsub4-Open-Input)  
Trigger: Called from aa010-Proc-Override to open the COBOL posting file.  
Key steps: set fn-open and fn-input true, call acasirsub4, check FS-Reply for errors.  
I/O: Posting-File.  
Outcomes: Posting file opened or error handled.  
[Seen in: acasirsub4-Open-Input.]

Path: Read/Write Loop (aa010-Read)  
Trigger: Each iteration of the main loop, starting after opening files.  
Key steps: read next record via acasirsub4-Read-Next, handle EOF, optional date filtering, write record via acasirsub4-Write, handle duplicate key or write errors, update counters, loop.  
I/O: Posting-File, RDB via acasirsub4.  
Outcomes: Records transferred, counters updated, errors logged, duplicates rewritten.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling (within aa010-Read)  
Trigger: When acasirsub4-Write returns SQL-State "23000" or FS-Reply 22/99 or SQL-Err 1062/1022.  
Key steps: reset FS-Reply and WE-Error, attempt acasirsub4-Rewrite, log duplicate key, increment rewrite counter, continue loop.  
I/O: RDB via acasirsub4.  
Outcomes: Duplicate records rewritten, counters updated.  
[Seen in: aa010-Read.]

Path: Rollback (aa020-Rollback)  
Trigger: Called when a write error occurs (not shown in code but referenced).  
Key steps: call MySQL_rollback, optionally check return-code.  
I/O: RDB.  
Outcomes: Transaction rolled back.  
[Seen in: aa020-Rollback.]

5.4 Termination  
The program prints summary statistics, closes the RDB and posting files, and performs a final log message before exiting. [Seen in: aa999-Finish.]  
It uses goback to return control to the caller after all resources are released. [Seen in: aa999-Finish.]

---
## irspostingMT
*[112/267]*

### Business/Functional Perspective
### IRS Posting File Handler  

**Program Purpose**  
This program manages IRS posting records stored in a MySQL database. It opens and closes the data connection, retrieves, inserts, updates, and deletes posting records, and can clear the entire posting table. By ensuring each posting is stored correctly and that duplicate keys are prevented, it supports accurate financial reporting and audit compliance for the accounting system.  

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – The requested operation completes and the program returns a zero error code along with the key or record data.  
- **No Data** – When a read operation finds no matching records, the program returns a “No Data” status.  
- **Duplicate Key** – If an insert or update attempts to use an existing key, the program returns a duplicate‑key error.  
- **Database Failure** – Any MySQL error (connection issues, syntax errors, etc.) causes the program to return an error code and a descriptive message indicating the nature of the failure.  

**User Flow Summary**  
A caller supplies a function code (e.g., open, read, write, delete) and the relevant posting key or data record. The program opens a connection to the database if needed, executes the requested action, and then closes the connection when finished. After execution, the caller receives status information (success or specific error) and, for read operations, the posting record data. This enables higher‑level modules or user interfaces to present results or prompt the user for corrections.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- MySQL_query  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **ba-ACAS-DAL-Process**, where it evaluates the `File-Function` to dispatch to the appropriate processing paragraph. After the selected path completes, control flows to **ba999-end** for cleanup and logging before exiting. The final exit occurs in **ba999-exit**. [Seen in: ba-ACAS-DAL-Process.]

5.2 Initialization  
Paragraph **ba010-Initialise** clears error flags, message buffers, and sets screen exception handling. It also initializes environment line counts and prepares the program for subsequent operations. [Seen in: ba010-Initialise.]

5.3 Core Processing  

Path: **Process-Open**  
Trigger: `File-Function` = 1  
Key steps: Build MySQL connection strings, perform `MYSQL-1000-OPEN`, set cursor inactive, and set `WS-File-Key` to "OPEN IRSPOSTING".  
I/O: MySQL connection parameters (`WS-MYSQL-BASE-NAME`, etc.) and the MySQL open routine.  
Outcomes: `fs-reply` set to zero on success; on error control jumps to **ba999-end**. [Seen in: ba020-Process-Open.]

Path: **Process-Start**  
Trigger: `File-Function` = 9  
Key steps: Validate `access-type`, clear any active cursor, construct a WHERE clause using `MOST-Relation` and the key, perform a SELECT, and activate the cursor if rows are returned.  
I/O: SELECT from `IRSPOSTING-REC`.  
Outcomes: Cursor becomes active, `WS-File-Key` holds the key value, and `fs-reply` is zero; errors set `fs-reply` to 99 and `WE-Error` to 997. [Seen in: ba060-Process-Start.]

Path: **Process-Write**  
Trigger: `File-Function` = 5  
Key steps: Load host variables from the posting record, build an INSERT statement, execute it, and check the affected row count.  
I/O: INSERT into `IRSPOSTING-REC`.  
Outcomes: On duplicate key (`1062`, `1022`, or SQLSTATE `23000`) `fs-reply` is set to 22; otherwise `fs-reply` remains zero. [Seen in: ba070-Process-Write.]

Path: **Process-Delete**  
Trigger: `File-Function` = 8  
Key steps: Build a WHERE clause for the key, execute a DELETE, and verify that exactly one row was removed.  
I/O: DELETE from `IRSPOSTING-REC`.  
Outcomes: `fs-reply` is zero on success; on failure `fs-reply` is set to 99 and `WE-Error` to 995. [Seen in: ba080-Process-Delete.]

Path: **Process-Delete-ALL**  
Trigger: `File-Function` = 6  
Key steps: Construct a WHERE clause that selects all keys less than the current `Post-Key`, perform a DELETE, and handle any errors.  
I/O: DELETE from `IRSPOSTING-REC`.  
Outcomes: `fs-reply` is zero if rows were deleted; otherwise `fs-reply` is set to 99 and `WE-Error` to 995. [Seen in: ba085-Process-Delete-ALL.]

Path: **Process-Rewrite**  
Trigger: `File-Function` = 7  
Key steps: Load host variables, build an UPDATE statement with the key, execute it, and confirm that one row was updated.  
I/O: UPDATE `IRSPOSTING-REC`.  
Outcomes: `fs-reply` is zero on success; on error `fs-reply` is set to 99 and `WE-Error` to 994. [Seen in: ba090-Process-Rewrite.]

5.4 Termination  
Paragraph **ba999-end** optionally performs logging via `Ca-Process-Logs` if `Testing-1` is set, then proceeds to **ba999-exit** which exits the program. [Seen in: ba999-end.]  
The program terminates cleanly with all resources released by **ba998-Free** when a cursor is active. [Seen in: ba998-Free.]

---
## irspostingRES
*[113/267]*

### Business/Functional Perspective
### IRS Posting Backup  

**Program Purpose**  
The program creates a backup of the IRS posting data by copying each record from a sequential input file into a new indexed posting file. It ensures that posting data is safely stored for later restoration, supports compliance with accounting audit requirements, and helps maintain data integrity when the original file is unavailable or corrupted.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- Indicates if the input sequential file is missing or cannot be opened.  
- Reports failures when opening the destination posting file.  
- Signals errors that occur while reading records from the input file.  
- Alerts the user to write errors when creating the posting file.  
- Provides a final message showing how many records were read and written.  
- Notes that required environment variables are not set (program aborts).  

**User Flow Summary**  
A user starts the program from the command line. The program logs its start and checks for any arguments or environment settings. It attempts to open the source sequential file that contains IRS posting records. If the file is not available, a message is logged and the program stops. If the source file opens successfully, the program opens the destination posting file for writing. It then reads each record from the source, writes it to the destination, and keeps a count of records processed. If any read or write error occurs, an appropriate message is logged and the program stops. Once all records are processed, the program logs the total numbers of records read and written, closes both files, and exits cleanly.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and initializing logging parameters. [Seen in: aa000-Main-Start.]  
It opens the source sequential file for reading and the target indexed file for writing, aborting if either open fails. [Seen in: aa000-Main-Start.]  
It then reads each record from the sequential file, writes it to the indexed file, counts records, and handles any I/O errors, terminating when the end of file or an error occurs. [Seen in: aa010-Read-Recs.]  
After processing, it closes both files, outputs a summary of records processed, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs a call to obtain program arguments and sets up logging system and file numbers for the FHlogger. [Seen in: aa000-Main-Start.]  
It clears the record counters and prepares the output message buffer before opening the input and output files. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Open Files  
Trigger: Execution of aa000-Main-Start after argument retrieval.  
Key steps: open input sequential file (irsposting-File-Seq); if FS-Reply non‑zero, log error and exit; open output indexed file (Posting-File); if FS-Reply non‑zero, log error and exit.  
I/O: irsposting-File-Seq, Posting-File.  
Outcomes: files opened successfully or program terminated with error status.  
[Seen in: aa000-Main-Start.]

Path: Read/Write Loop  
Trigger: Entry to aa010-Read-Recs.  
Key steps: read next record from irsposting-File-Seq; if end of file, go to aa020-Finish-Off; if FS-Reply non‑zero, log error and go to aa020-Finish-Off; increment input counter; write record to Posting-File; if FS-Reply non‑zero, log error and go to aa020-Finish-Off; increment output counter.  
I/O: irsposting-File-Seq, Posting-File.  
Outcomes: records transferred, counters updated, or error‑driven exit.  
[Seen in: aa010-Read-Recs.]

Path: Finish Off  
Trigger: Reaching aa020-Finish-Off either from end of file or an error.  
Key steps: close irsposting-File-Seq and Posting-File; compose summary message with record counts; log summary; set Return-Code to zero; goback.  
I/O: irsposting-File-Seq, Posting-File.  
Outcomes: files closed, summary logged, program terminated.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs a final summary of records processed, sets the return code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]

---
## irspostingUNL
*[114/267]*

### Business/Functional Perspective
### Posting File Unload  

**Program Purpose**  
This program creates a backup of the accounting posting file used by ACAS. It copies each record from the indexed ISAM file into a sequential file that can be restored later if the original becomes corrupted or lost. The backup supports data recovery, compliance audits, and risk reduction by ensuring an accurate snapshot of posting data is available for restoration.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- No posting file found – the program reports that there is nothing to process.  
- Problem reading the posting file – a record cannot be read and the backup stops.  
- Write error on the backup file – the sequential file cannot accept a record and the process terminates.  
- Program arguments incorrect – the program was called with invalid parameters.  
- Environment variables not yet set up – the necessary runtime configuration is missing, so the program aborts.  

**User Flow Summary**  
The user starts the program, typically from a command line or a scheduled job. The program attempts to open the existing posting file; if it is missing, a message is logged and the program ends. If the file is present, each record is read sequentially and written to a new backup file. The program tracks how many records were read and written, logs these counts, and writes all log messages to the system display log. Upon completion, the program returns control with a success status.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins by retrieving command line arguments, initializing logging, and opening the indexed Posting-File and sequential output file. [Seen in: aa000-Main-Start.]  
It then enters a loop that reads each record from Posting-File, writes it to irsposting-File-Seq, and counts input and output records while monitoring status codes. [Seen in: aa010-Read-Recs.]  
Upon reaching end‑of‑file or encountering an error, the program closes both files, logs a summary of records processed, and exits gracefully. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line parameters and sets logging identifiers before opening files. [Seen in: aa000-Main-Start.]  
It opens Posting-File for input, verifies FS-Reply, opens irsposting-File-Seq for output, and initializes record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read-Records-Loop  
Trigger: Each successful read of Posting-File next record until end‑of‑file or error.  
Key steps: Read next record, check FS-Reply, write record to irsposting-File-Seq, update input and output counters, handle write errors by logging and aborting loop.  
I/O: Posting-File, irsposting-File-Seq.  
Outcomes: Incremented counters, potential error messages logged, loop termination on error or EOF. [Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: End‑of‑file reached or error encountered during read/write.  
Key steps: Close irsposting-File-Seq and Posting-File, construct summary message with record counts, log the summary, set Return-Code to zero, goback to terminate. [Seen in: aa020-Finish-Off.]

5.4 Termination  
The program ensures both input and output files are closed, a final status message is logged, and the Return-Code is set to zero before exiting. [Seen in: aa020-Finish-Off.]  
Execution ends with a GOBACK statement, returning control to the operating environment. [Seen in: aa020-Finish-Off.]

---
## irsubp
*[115/267]*

### Business/Functional Perspective
### Sorted Posting File Handler  

**Program Purpose**  
This routine manages the sorted posting file that stores financial transaction records. It opens the file, reads records in the order they were sorted, and supplies each record back to the calling process. By handling file status checks and error reporting, it guarantees that only valid, correctly ordered data is used in downstream accounting operations. The program helps maintain accurate financial reporting and audit trails, supporting compliance with internal control standards.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **File Open Error** – If the file cannot be opened or its status is bad, the routine stops and signals a general error.  
- **Read Failure** – If a read operation is requested but cannot be completed, the routine reports a read failure.  
- **End of File** – When the file contains no more records, the routine returns an end‑of‑file indicator.  
Successful execution results in no error signal.  

**User Flow Summary**  
When the accounting system needs to process the sorted posting file, it invokes this handler. The routine opens the file (or verifies that it is already open), reads the next record in sequence, and passes that record back to the caller. If the file is empty or no more records remain, the routine indicates the end of data so that the calling process can stop reading. Errors such as a missing file or a read problem are reported back, allowing the system to abort or retry as needed. The user does not interact directly with this routine; it operates behind the scenes to provide reliable, ordered posting data.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the Main paragraph, initializing error status and determining the requested file operation. [Seen in: Main.]  
Depending on the linkage flags, it performs an open, close, or read operation on the Sorted‑Posting‑File and then exits. [Seen in: Main.]  
If a read is requested, the Read‑1 paragraph retrieves the next record, handles end‑of‑file, and transfers the data to the posting record before exiting. [Seen in: Read‑1.]

5.2 Initialization  
The Main paragraph sets we‑error to zero and checks the fn‑open flag to decide whether to proceed with file operations. [Seen in: Main.]  
It opens the Sorted‑Posting‑File for input or output based on fn‑input or fn‑output, then verifies the file status (fs‑reply) and sets we‑error to 99 on failure. [Seen in: Main.]

5.3 Core Processing  
Path: Open  
Trigger: fn‑open flag is true.  
Key steps: open Sorted‑Posting‑File for input if fn‑input, for output if fn‑output, check fs‑reply, set we‑error to 99 if non‑zero, then exit.  
I/O: Sorted‑Posting‑File.  
Outcomes: we‑error set to 99 on error; program terminates.  
[Seen in: Main.]

Path: Close  
Trigger: fn‑close flag is true.  
Key steps: close Sorted‑Posting‑File, then exit.  
I/O: Sorted‑Posting‑File.  
Outcomes: file closed; program terminates.  
[Seen in: Close‑1.]

Path: Read  
Trigger: fn‑read‑next flag is true.  
Key steps: read next record from Sorted‑Posting‑File, set we‑error to 3 on end‑of‑file, otherwise move Record‑4 to posting‑record.  
I/O: Sorted‑Posting‑File.  
Outcomes: posting‑record populated; we‑error indicates EOF or success.  
[Seen in: Read‑1.]

5.4 Termination  
The program exits via the Main‑Exit paragraph, which performs a GOBACK (exit program) after any necessary cleanup. [Seen in: Main‑Exit.]  
If a close operation was requested, the Close‑1 paragraph ensures the file is closed before exiting. [Seen in: Close‑1.]

---
## makesqltable-free
*[116/267]*

### Business/Functional Perspective
### SQL Table Script Generation  

#### Program Purpose  
The program creates a Transact‑SQL script that can be run to create a database table. It reads a table definition file supplied by the user, applies a field‑name prefix removal, and writes a fully‑formed `CREATE TABLE` statement to an output file. This automation reduces manual transcription errors, ensures consistent table definitions, and supports rapid deployment of database schemas.  

#### Screen Interactions  
1. **Input File Prompt** – *Enter Input File Name*  
   *Input:* The user types the name of the file containing the table definition.  
   *Output:* The program opens the file and proceeds.  
2. **Prefix Prompt** – *Enter Field Name Prefix to Remove*  
   *Input:* The user provides the string to strip from the start of each column name.  
   *Output:* The program uses this prefix when generating column identifiers.  
3. **Output File Prompt** – *Enter Output File Name*  
   *Input:* The user supplies the file path where the SQL script will be written.  
   *Output:* The program opens the file for writing.  
4. **Database Name Prompt** – *Enter Database Name*  
   *Input:* The user enters the target database name used in the `USE` statement.  
   *Output:* The program records this name for script generation.  
5. **Help Screen** – Displayed when the user supplies `-HELP` or `--HELP` as the input file name.  
   *Output:* A brief list of required parameters is shown, then the program exits.  

#### Messages and Errors  
- **File Access Errors** – If the input or output file cannot be opened, the program informs the user and stops.  
- **Missing Definition** – If no table definition line (starting with `01`) is found in the input file, an error message is shown.  
- **Duplicate Definitions** – Encountering more than one `01` line during processing results in an error.  
- **Format Issues** – Lines that do not start with a numeric code or contain an invalid PIC clause trigger an error message.  
- **Success** – When processing completes without problems, the program writes the SQL script and reports normal completion.  

#### User Flow Summary  
A user runs the program, optionally passing four command‑line arguments: the input definition file, the prefix to remove, the output script file, and the database name. If any argument is omitted, the program prompts for it. Once all parameters are supplied, the program attempts to open the input file. It reads the first line that begins with `01` to determine the table name, then iterates through subsequent lines to capture each column definition, stripping the specified prefix and translating the COBOL picture clause into an appropriate SQL data type. As it processes each column, the program writes corresponding SQL statements to the output file. After all columns are handled, it appends the primary key declaration, closes the table definition, and writes the storage engine declaration. If any problem arises during reading or writing, the user receives a clear message describing the issue; otherwise the user sees a normal completion notice.  

#### Program Linkages  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **0000-main section**, performing initialization, main processing, and termination in sequence. [Seen in: 0000-main section.]  
Initialization reads command‑line parameters or prompts the user, opens input and output files, and prepares the database name. [Seen in: 1000-initialization.]  
Main processing reads the first table definition record, writes the CREATE TABLE header, then iterates over subsequent column definition records to generate column definitions, and finally writes the table footer before closing files. [Seen in: 2000-process, 2010-read, 2100-read-columns, 2900-eof.]

5.2 Initialization  
The program displays a start banner and checks for a help request, prompting for missing parameters if not supplied via command line. [Seen in: 1000-initialization.]  
It opens the input file and verifies the status, then opens the output file, handling any errors by closing both files and exiting. [Seen in: 1000-initialization.]  
The database name is read from the remaining input area, hyphens replaced with underscores, and converted to upper case for use in SQL statements. [Seen in: 1000-initialization.]

5.3 Core Processing  
Path: Table Definition (01 entry)  
Trigger: First record read that starts with “01” after skipping non‑matching records. [Seen in: 2010-read.]  
Key steps: Trim record, extract table name after period, write USE statement, DROP TABLE IF EXISTS, CREATE TABLE header, add key column. [Seen in: 2010-read.]  
I/O: Reads input‑file, writes output‑file. [Seen in: 2010-read.]  
Outcomes: Table name stored in WS‑Table‑Name, output file contains initial SQL statements, program proceeds to column reading. [Seen in: 2010-read.]

Path: Column Definition Loop  
Trigger: Subsequent records after the 01 entry until end‑of‑file or a new 01 record. [Seen in: 2100-read-columns.]  
Key steps: Skip comment lines starting with “*”, detect errors for duplicate 01 or non‑numeric prefixes, strip prefix, trim to get column name, replace hyphens, write column definition header, parse PIC clause to determine character length, call character or varchar handling. [Seen in: 2100-read-columns, 2110-prefix-loop, 2200-characters, 2250-varchar.]  
I/O: Reads input‑file, writes output‑file. [Seen in: 2100-read-columns.]  
Outcomes: Column definitions appended to output file, loop continues until EOF. [Seen in: 2100-read-columns.]

Path: Character PIC Handling (2200-characters)  
Trigger: PIC clause starts with “X” indicating a character string. [Seen in: 2200-characters.]  
Key steps: Count consecutive X’s or handle repetitions, determine total characters, decide between CHAR or VARCHAR based on length, write appropriate column definition with NOT NULL DEFAULT ’ ’. [Seen in: 2200-characters, 2210-character-loop, 2240-got-count.]  
I/O: Writes to output‑file. [Seen in: 2200-characters, 2240-got-count.]  
Outcomes: Column definition line added to output file; control returns to column loop. [Seen in: 2200-characters.]

Path: Varchar Handling (2250-varchar)  
Trigger: Character count exceeds 255. [Seen in: 2250-varchar.]  
Key steps: Write VARCHAR definition with length, NOT NULL DEFAULT ’ ’, append to output file. [Seen in: 2250-varchar.]  
I/O: Writes to output‑file. [Seen in: 2250-varchar.]  
Outcomes: Column definition line added; loop continues. [Seen in: 2250-varchar.]

Path: End‑of‑File Finalization (2900-eof)  
Trigger: End of input file reached during column loop. [Seen in: 2900-eof.]  
Key steps: Write PRIMARY KEY clause, closing parenthesis, ENGINE clause, and final semicolon. [Seen in: 2900-eof.]  
I/O: Writes to output‑file. [Seen in: 2900-eof.]  
Outcomes: Table definition complete in output file; program proceeds to close files. [Seen in: 2900-eof.]

Path: Close Files (7980-close)  
Trigger: Error or normal completion after EOF. [Seen in: 7980-close.]  
Key steps: Close input‑file and output‑file. [Seen in: 7980-close.]  
I/O: Close statements. [Seen in: 7980-close.]  
Outcomes: Files released; control returns to exit. [Seen in: 7980-close.]

5.4 Termination  
After files are closed, the program displays a completion banner and performs a GOBACK to return control to the caller. [Seen in: 9000-end-of-program.]  
The final exit is handled by the 9990‑exit paragraph, which simply exits the program. [Seen in: 9990-exit.]

---
## makesqltable-original
*[117/267]*

### Business/Functional Perspective
### Generate SQL Table Script

**Program Purpose**  
The program creates a Transact‑SQL script that defines a database table from a simple definition file. By letting the user specify the source file, output file, and database name, it automates the generation of `DROP TABLE`, `CREATE TABLE`, and column definition statements. This reduces manual SQL coding, ensures consistent table structure, and lowers the risk of syntax or naming errors in database deployments.

**Screen Interactions**  
1. **Prompt for input file name** – the user enters the path to the table definition file.  
2. **Prompt for field‑name prefix to remove** – the user supplies a prefix that should be stripped from column names.  
3. **Prompt for output file name** – the user enters where the generated TSQL script will be written.  
4. **Prompt for database name** – the user supplies the target database; dashes are replaced with underscores and converted to lower case.

**Messages and Errors**  
- File access errors: “cannot open input/output file.”  
- Definition file errors: “no 01 entry found,” “cannot have more than one 01 definition,” or “invalid record format.”  
- Completion message: “program completed normally.”  
No detailed error codes are displayed; only the nature of the failure is reported.

**User Flow Summary**  
The user starts the program, then sequentially provides the names of the input file, a prefix to strip from column names, the desired output file, and the target database. The program reads the input file line by line, extracts the table name from the first `01` record, removes the specified prefix from column names, and writes a ready‑to‑run TSQL script to the output file. After processing all column definitions, it finalizes the script with a primary‑key clause and database engine specification, then signals normal completion.

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins at 0000-MAIN SECTION, performing initialization, main processing, and termination sequentially. [Seen in: 0000-MAIN SECTION.]  
Initialization (1000-INITIALIZATION) prompts for input and output file names, opens the files, and prepares the database name. [Seen in: 1000-INITIALIZATION.]  
Main processing (2000-PROCESS) reads the input file, extracts the table name, writes the initial CREATE TABLE statements, then iterates through column definitions to generate column SQL, and finally writes the closing syntax. [Seen in: 2000-PROCESS.]  
After processing, the program closes the files and exits normally. [Seen in: 9000-END-OF-PROGRAM.]

5.2 Initialization  
The program displays a start message and accepts the input file name, opening INPUT-FILE and validating the status. [Seen in: 1000-INITIALIZATION.]  
It then accepts the prefix to remove, the output file name, opens OUTPUT-FILE, and reads the database name, converting hyphens to underscores and lower‑casing it for later use. [Seen in: 1000-INITIALIZATION.]

5.3 Core Processing  
Path: Read First 01 Entry  
Trigger: First record beginning with “01” in the input file.  
Key steps: Read record, trim, extract table name from the part after the dot, write USE, DROP TABLE IF EXISTS, and CREATE TABLE header statements.  
I/O: INPUT-FILE, OUTPUT-FILE.  
Outcomes: Table name stored in WS-TABLE-NAME; initial SQL written to OUTPUT-FILE.  
[Seen in: 2010-READ.]

Path: Read Columns Loop  
Trigger: After the table header, subsequent records until EOF or a new “01” record.  
Key steps: Read record, skip comment lines, validate numeric prefix, remove specified prefix, extract column name, determine PIC clause, and generate column definition.  
I/O: INPUT-FILE, OUTPUT-FILE.  
Outcomes: Column definitions written to OUTPUT-FILE; loop continues until EOF.  
[Seen in: 2100-READ-COLUMNS.]

Path: Character Definition Handling  
Trigger: PIC clause starts with “X” indicating a character string.  
Key steps: Count the number of X’s or repetitions, decide between CHAR or VARCHAR based on length, and write the appropriate column definition with NOT NULL DEFAULT ' '.  
I/O: None (uses current record data).  
Outcomes: Column definition written to OUTPUT-FILE.  
[Seen in: 2200-CHARACTERS.]

Path: End‑of‑File Finalization  
Trigger: End of column definitions (EOF reached).  
Key steps: Write PRIMARY KEY clause, closing parenthesis, and ENGINE specification.  
I/O: OUTPUT-FILE.  
Outcomes: Final SQL script completed.  
[Seen in: 2900-EOF.]

Path: Error/Close Path  
Trigger: Encountered an error (e.g., invalid PIC) or normal job end.  
Key steps: Close INPUT-FILE and OUTPUT-FILE.  
I/O: INPUT-FILE, OUTPUT-FILE.  
Outcomes: Files closed; program proceeds to termination.  
[Seen in: 7980-CLOSE.]

5.4 Termination  
The program displays a completion message with the current date and stops execution. [Seen in: 9000-END-OF-PROGRAM.]  
All files are closed and the program exits normally. [Seen in: 9000-END-OF-PROGRAM.]

---
## maps01
*[118/267]*

### Business/Functional Perspective
### Password and Name Encoder  

**Program Purpose**  
This program transforms a user’s plain‑text password and/or name into a simple encoded form. The encoded values can be stored or used elsewhere in the system to obscure sensitive data. By providing a consistent encoding routine, the program supports data protection requirements and helps ensure that user credentials are not stored in clear text.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
The program does not display any user‑facing messages or error notifications. It simply produces the encoded password or name and returns control to the calling context.  

**User Flow Summary**  
1. The user supplies a 4‑character password (optional) and a 32‑character name.  
2. The program checks whether a password was provided. If a password exists, it is encoded; otherwise the name is encoded.  
3. For each character in the input, the program applies a predefined substitution logic to generate the encoded output.  
4. The resulting encoded password or name replaces the original input in the caller’s data structure.  
5. Control returns to the calling process, which can then use the encoded values for storage, display, or further processing.  

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by evaluating the PASS flag; if false it jumps to the name‑encoding routine, otherwise it proceeds to password encoding. [Seen in: Procedure Division]  
The password‑encoding routine iterates over each of the four characters, mapping them through a custom alphabet and performing arithmetic to generate a transformed output. [Seen in: encode-pass]  
The name‑encoding routine processes each of the thirty‑two characters, applying a different arithmetic mapping to produce the encoded name. [Seen in: encode-name]  

5.2 Initialization  
The only startup check is the evaluation of the PASS flag, which determines whether the password or name encoding path is taken. [Seen in: Procedure Division]  
All working‑storage variables are initialized by their declarative values, and no external files or databases are accessed during startup. [Seen in: Working-Storage Section]  

5.3 Core Processing  
Path: Encode Pass  
Trigger: PASS flag true (i.e., not not pass). [Seen in: Procedure Division]  
Key steps: move pass‑word to pass‑word‑input; set y = 1; loop while y < 5: search alpha or alower for ar2(y); compute base = y² + 3; compute z = a + base – 26; adjust z if < 1; compute q = 5 – y; if z ≠ 0 move ar1(z) to ar3(q) else space; increment y; loop; move pass‑word‑output to pass‑word; exit. [Seen in: encode-pass, loop, test‑lower, set‑base, return‑to‑loop]  
I/O: pass‑word, pass‑word‑output, ar1, ar1‑l, ar2, ar3. [Seen in: encode-pass, loop, test‑lower, set‑base]  
Outcomes: pass‑word updated with encoded value; pass‑word‑output holds intermediate results; q, z, base used for mapping. [Seen in: encode-pass]  

Path: Encode Name  
Trigger: PASS flag false (i.e., go to encode‑name). [Seen in: Procedure Division]  
Key steps: move pass‑name to pass‑name‑input; set y = 1; loop while y < 32: search alpha or alower for ar4(y); compute base = (y + 51)/y rounded; adjust base if > 25; set z = a + base – 27; adjust z if < 1 or > 26; if z ≠ 0 move ar1(z) to ar5(y) else space; increment y; loop; move pass‑name‑output to pass‑name; exit. [Seen in: encode-name, loop‑n, test‑lower‑n, set‑base‑n, return‑to‑loop‑n]  
I/O: pass‑name, pass‑name‑output, ar1, ar1‑l, ar4, ar5. [Seen in: encode-name, loop‑n, test‑lower‑n, set‑base‑n]  
Outcomes: pass‑name updated with encoded value; pass‑name‑output holds intermediate results; z, base used for mapping. [Seen in: encode-name]  

5.4 Termination  
After encoding, the program transfers the output buffers back to the linkage variables and terminates via the main‑exit paragraph. [Seen in: main-exit]  
No additional cleanup or resource deallocation is performed before exit. [Seen in: main-exit]

---
## maps04
*[119/267]*

### Business/Functional Perspective
### Date Validation & Conversion  

**Program Purpose**  
The program checks that a user‑supplied date is valid and converts it into a compact binary format suitable for storage. If a valid date is entered, the binary value is returned; if the date is invalid, the program signals this by returning a zero value. The conversion also allows the program to reverse the process, turning a stored binary date back into a readable string. This helps maintain accurate, consistent dates across the system and prevents erroneous data from being recorded.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the date format is incorrect (wrong number of separators or non‑numeric components), the result is set to zero.  
- If the numeric parts fall outside acceptable ranges (day < 1 or > 31, month < 1 or > 12) the result is zero.  
- If the date is logically invalid (e.g., February 30 or a non‑leap‑year February 29) the result is zero.  
- On a successful conversion, the binary date value is returned.  
- If the input already contains a binary date, it is unpacked into a string and returned.  

**User Flow Summary**  
A user or calling program supplies a date string in the format *dd/mm/ccyy* (or *dd/mm/yy*). The program validates the format and the logical validity of the date, then converts the value to a binary long format. This binary value can be stored or transmitted efficiently. If the program receives an already‑converted binary date, it expands the value back into the *dd/mm/ccyy* string for display or further processing. In either case, the user receives either a valid binary representation, a formatted date string, or an indication of an error through a zero value.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **MAIN**, where it determines whether the incoming binary date (a-bin) is non‑zero and, if so, proceeds to unpack it into a human‑readable format. [Seen in: main.]  
If a-bin is zero, the program cleans the input date string, normalises separators, counts slashes, and performs basic validation of day, month, and year components. [Seen in: main.]  
Upon successful validation, the program converts the validated date into a binary long integer and then exits; if validation fails, it exits with a-bin set to zero. [Seen in: main.]

5.2 Initialization  
The program checks if a-bin > zero and immediately jumps to the **WS-UNPACK** paragraph if true. [Seen in: main.]  
When a-bin is zero, it zeroes the counter z, normalises the a-date string by replacing '.', ',', and '-' with '/', and tallies the number of '/' characters to ensure proper format. [Seen in: main.]

5.3 Core Processing  
Path: Binary Unpack  
Trigger: a-bin > zero  
Key steps: move "00/00/0000" to a-date; call FUNCTION DATE-OF-INTEGER to convert a-bin to test-date; copy components from test-date to a-ccyy, a-month, a-days.  
I/O: a-bin, a-date.  
Outcomes: a-date populated with a human‑readable date, a-bin unchanged.  
[Seen in: ws-unpack.]

Path: Date Validation & Conversion  
Trigger: a-bin = zero and input date passes basic format checks  
Key steps: validate numeric components and ranges; call FUNCTION TEST-DATE-YMDMMDD on test-date9; if passes, call FUNCTION INTEGER-OF-DATE to set a-bin.  
I/O: a-date, a-bin.  
Outcomes: a-bin set to binary representation of date; if validation fails, a-bin remains zero.  
[Seen in: main.]

5.4 Termination  
The program exits by performing EXIT PROGRAM at paragraph **MAIN-EXIT**, returning control to the caller. [Seen in: main-exit.]  
No additional cleanup is performed beyond the exit statement. [Seen in: main-exit.]

---
## maps09
*[120/267]*

### Business/Functional Perspective
### Check Digit Calculation

**Program Purpose**  
This program verifies or generates a check digit for a customer identifier using the Mod 11 algorithm. It ensures that customer numbers are entered correctly and can be validated against an existing check digit, reducing data entry errors and supporting compliance with internal audit standards. The routine provides a simple yes/no result and, when requested, returns the calculated check digit for use elsewhere in the system.

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Success** – When the routine successfully calculates a check digit or confirms that the supplied check digit matches the computed value, the program returns a status of “Y” (yes).  
- **Invalid input** – If any character in the customer number is not a digit, letter, or the allowed hyphen, or if the customer number is otherwise malformed, the program returns a status of “N” (no).  
- **Calculation failure** – If the algorithm encounters a problem that causes the sum to be zero, the program likewise returns “N”.  

No explicit error messages are displayed to the user; only the Y/N status is returned.

**User Flow Summary**  
A user supplies a six‑character customer number and specifies whether they want a check digit to be calculated (“C”) or whether they want to validate an existing check digit (“V”). The routine processes the number, applying the Mod 11 weighting scheme to each character. If the request was to calculate, the program returns the new check digit and a “Y” status. If the request was to validate, the program compares the supplied check digit to the one it calculates; a match results in a “Y” status, while a mismatch or any input error results in an “N” status.

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins execution in the **main** paragraph, moving `customer-nos` into `work-array` and initializing `suma` to zero. [Seen in: main.]  
It then performs the **addition-loop** for each of the six characters, accumulating a weighted sum in `suma`. [Seen in: main, addition-loop.]  
After the loop, the program evaluates `suma`; if zero, it sets `maps09-reply` to "N" and exits, otherwise it calculates the Mod‑11 check digit, updates reply to "Y" if appropriate, and exits. [Seen in: main.]

5.2 Initialization  
The **main** paragraph initializes `work-array` with `customer-nos` and sets `suma` to zero. [Seen in: main.]  
No external files are opened; all data are in working‑storage or linkage. [Seen in: main.]

5.3 Core Processing  
Path: Sum Calculation Loop  
Trigger: Execution of the perform loop in **main** for `a` = 1 to 6.  
Key steps: For each `a`, search `ar1` for the character `array(a)`; if found, compute weighted contribution `z = y*(8-a)` and add to `suma`; if not found, set `suma` to zero and `a` to 7 to terminate loop.  
I/O: `work-array`, `ar1`, `array`, `suma`.  
Outcomes: `suma` holds weighted sum of matched characters; if no match, `suma` set to zero and loop ends early.  
[Seen in: main, addition-loop, addition-error, addition-do, addition-end.]

Path: Zero Sum Handling  
Trigger: After loop, if `suma` = zero.  
Key steps: Set `maps09-reply` to "N" and go to **main-exit**.  
I/O: `maps09-reply`.  
Outcomes: Reply indicates invalid or no check digit; program exits.  
[Seen in: main.]

Path: Check Digit Calculation  
Trigger: After loop, if `suma` > zero.  
Key steps: Divide `suma` by 11 to get quotient `z`; compute `a = 11 - (suma - 11*z)`; if `maps09-reply` = "C", set `check-digit` to `a` and reply to "Y"; if `maps09-reply` = "V" and `a` equals `check-digit`, set reply to "Y".  
I/O: `suma`, `z`, `a`, `check-digit`, `maps09-reply`.  
Outcomes: `maps09-reply` set to "Y" if calculation or verification succeeds; program exits.  
[Seen in: main.]

5.4 Termination  
The program exits via the **main-exit** paragraph, which performs an `exit program` statement. [Seen in: main-exit.]  
No additional cleanup is performed beyond exiting. [Seen in: main-exit.]

---
## nominalLD
*[121/267]*

### Business/Functional Perspective
### Nominal Table Load

**Program Purpose**  
The program reads the IRS nominal file and loads its contents into the MySQL nominal table. It ensures that each entry is written correctly, handles duplicate records by rewriting, and logs the results for audit and compliance purposes. The process guarantees that the accounting system has an up‑to‑date nominal reference, which is essential for accurate transaction posting and reporting.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Configuration errors** – if the system file or the required database parameters are missing or unreadable, the program stops and reports the missing configuration.  
- **File errors** – if the nominal file cannot be opened or read, the program halts with a message indicating the file problem.  
- **Duplicate records** – when a duplicate key is encountered, the program rewrites the existing record instead of inserting a new one and notes the rewrite count.  
- **Database errors** – any other database write failure (e.g., connection loss, SQL error) is reported with a brief description and the program exits.  
- **Summary** – at completion, the program outputs the total number of records read, written, and rewritten, plus the number of log entries generated.

**User Flow Summary**  
The user launches the program (optionally supplying up to two command‑line arguments). The program first reads system parameters to obtain database connection details. It then attempts to open the IRS nominal file. For each record, the program writes the data to the MySQL nominal table; if a duplicate key is detected, it updates the existing row instead. Throughout processing, the program logs progress and any errors to the system output. When the file is exhausted or an unrecoverable error occurs, the program prints a final summary of records processed and terminates.

**Program Linkages**  
- acas005  
- acas-get-params  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by parsing command‑line arguments, initializing logging, and opening the system parameter file. [Seen in: aa000-main-start.]  
It then reads the system record, loads RDBMS configuration (or retrieves it via acas‑get‑params), and opens the nominal file for input and the RDB table for output. [Seen in: aa010-Proc-Override.]  
The core processing loop reads each nominal record, writes it to the RDB table, handles duplicate keys by rewriting or skipping, and logs any errors, terminating when the end of the nominal file is reached. [Seen in: aa010-Read.]  
Finally, the program logs summary counts, closes all files, and exits. [Seen in: aa999-Finish.]

5.2 Initialization  
The program performs zz020‑Get‑Program‑Args, sets up logging identifiers, and opens the system file for reading. [Seen in: aa000-main-start.]  
It reads the first system record, validates FS‑Reply, and either loads RDBMS parameters directly or calls acas‑get‑params to obtain them, aborting if the parameters are missing or invalid. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: after opening the system file and reading the first record.  
Key steps: read system-file record, check FS‑Reply, load RDBMS settings or invoke acas‑get‑params, set RDBMS‑Host, User, Passwd, DB‑Name, Port, Socket.  
I/O: System-File.  
Outcomes: RDBMS configuration populated or program aborts.  
[Seen in: aa000-main-start.]

Path: Nominal File Open  
Trigger: after system parameter load.  
Key steps: perform acas005‑Open‑Input, check FS‑Reply for file existence (35 = not found).  
I/O: System-File, Nominal file via acas005.  
Outcomes: abort with message if file missing; otherwise proceed to RDB open.  
[Seen in: aa010-Proc-Override.]

Path: RDB Open  
Trigger: after nominal file open.  
Key steps: perform acas005‑Open‑Output, check FS‑Reply for errors.  
I/O: System-File, RDB via acas005.  
Outcomes: abort with message if error; otherwise proceed to read loop.  
[Seen in: aa010-Proc-Override.]

Path: Read/Write Loop  
Trigger: aa010‑Read.  
Key steps: read next nominal record, increment input counter, write to RDB, handle duplicate key (SQL‑State 23000 or FS‑Reply 22/99), rewrite duplicates, increment rewrite counter, log errors, loop until EOF.  
I/O: Nominal file, RDB.  
Outcomes: counters updated, duplicates rewritten, errors logged, loop continues until EOF.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: any FS‑Reply not zero or SQL error during write.  
Key steps: call aa100‑Check‑4‑Errors, log detailed error information, set return‑code, abort processing.  
I/O: System-File, RDB.  
Outcomes: program terminates with error status.  
[Seen in: aa100-Check‑4‑Errors.]

Path: Finish  
Trigger: aa999‑Finish.  
Key steps: log record counts and log‑file records written, close RDB via acas005‑Close, close system file, close nominal file, output final EOJ message, goback.  
I/O: System-File, RDB, Nominal file.  
Outcomes: program exits cleanly.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program logs final record counts, closes the RDB and nominal files, and outputs an “EOJ – Load Nominal Table” message before exiting. [Seen in: aa999-Finish.]  
It then performs a GOBACK to terminate the program. [Seen in: aa999-Finish.]

---
## nominalMT
*[122/267]*

### Business/Functional Perspective
### GL Ledger File Operations  

**Program Purpose**  
This program manages General Ledger records stored in a relational database. It supplies the standard file operations—open, close, start, read‑next, read‑indexed, write, delete, and rewrite—required by the accounting modules. By validating keys, handling duplicates, and reporting database errors, it helps maintain data integrity and supports reliable audit trails for ledger transactions.  

**Screen Interactions**  
No direct screens. This program is invoked by other modules after data entry and returns results back to that context.  

**Messages and Errors**  
- **Success** – Operation completes without problems.  
- **End of Data** – No more records available for the current query.  
- **Record Not Found** – A requested key does not exist in the ledger.  
- **Duplicate Key** – An attempt to insert a record with a key that already exists.  
- **Invalid Function or Parameters** – Wrong function code or bad parameters supplied.  
- **Database Errors** – Connection failures, query syntax errors, table locks, or other RDBMS‑specific problems that prevent the requested action.  

**User Flow Summary**  
A user or an accounting module begins by calling the program with an *open* request to establish a connection to the GL ledger table. The module then may *start* a query using a comparison operator (equal, less‑than, greater‑than, etc.) and a key value, after which it can fetch subsequent records with *read‑next* or retrieve a specific record with *read‑indexed*. To add a new ledger entry the module issues a *write* request, providing all required fields; the program will reject the request if the key already exists. Existing records can be updated with *rewrite* or removed with *delete*. Finally, the module sends a *close* request to terminate the connection. Throughout the process the program returns status codes and, where applicable, the requested record data, allowing the caller to present success, error, or end‑of‑data messages to the user.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program enters **ba-ACAS-DAL-Process**, performs environment setup and dispatch based on **File-Function**. [Seen in: ba-ACAS-DAL-Process.]  
The selected path (Open, Close, Read‑Next, Read‑Indexed, Start, Write, Delete, Rewrite) executes database operations and sets status fields. [Seen in: ba020-Process-Open, ba030-Process-Close, ba040-Process-Read-Next, ba050-Process-Read-Indexed, ba060-Process-Start, ba070-Process-Write, ba080-Process-Delete, ba090-Process-Rewrite.]  
After processing, cleanup and logging are performed before exiting via **ba999-end**. [Seen in: ba999-end.]

5.2 Initialization  
Accepts screen line count and configures screen exception handling. [Seen in: ba-ACAS-DAL-Process.]  
Clears error and status fields, and prepares MySQL command buffer. [Seen in: ba010-Initialise.]

5.3 Core Processing  

Path: **Open**  
Trigger: **File-Function = 1**  
Key steps: Build MySQL connection parameters, perform **MYSQL-1000-OPEN**, set cursor inactive, set file‑key message.  
I/O: MySQL connection.  
Outcomes: **fs-reply** set if error, **WE-Error**, **WS-File-Key** set to "OPEN GL LEDGER (RDB)".  
[Seen in: ba020-Process-Open.]

Path: **Read‑Next**  
Trigger: **File-Function = 3**  
Key steps: If cursor inactive, build SELECT with key > "00000000", execute, store result, set cursor active; otherwise fetch next record.  
I/O: MySQL SELECT, FETCH.  
Outcomes: **fs-reply** = 10 on EOF, **WE-Error**, **WS-File-Key** set to key or EOF.  
[Seen in: ba040-Process-Read-Next, ba041-Reread.]

Path: **Start**  
Trigger: **File-Function = 9**  
Key steps: Validate access‑type, clear cursor, build SELECT with comparison operator, execute, set cursor active if rows found.  
I/O: MySQL SELECT.  
Outcomes: **fs-reply** = 21 on not found, **WE-Error**, **WS-File-Key** set to key or count.  
[Seen in: ba060-Process-Start.]

Path: **Write**  
Trigger: **File-Function = 5**  
Key steps: Load HV fields from record, build INSERT command, execute, check row count, handle duplicate key.  
I/O: MySQL INSERT.  
Outcomes: **fs-reply** = 22 on duplicate, **WE-Error**, **WS-File-Key** set to key.  
[Seen in: ba070-Process-Write, bb200-Insert.]

Path: **Delete**  
Trigger: **File-Function = 8**  
Key steps: Build DELETE WHERE key = value, execute, check row count.  
I/O: MySQL DELETE.  
Outcomes: **fs-reply** = 99 on error, **WE-Error** = 995, **WS-File-Key** set to key.  
[Seen in: ba080-Process-Delete.]

Path: **Rewrite**  
Trigger: **File-Function = 7**  
Key steps: Load HV fields, build UPDATE command with WHERE key = value, execute, check row count.  
I/O: MySQL UPDATE.  
Outcomes: **fs-reply** = 99 on error, **WE-Error** = 994, **WS-File-Key** set to key.  
[Seen in: ba090-Process-Rewrite, bb300-Update.]

5.4 Termination  
If testing flag set, logs are written via **Ca-Process-Logs**. [Seen in: ba999-end.]  
Program exits by performing **exit program**. [Seen in: ba999-exit.]

---
## nominalRES
*[123/267]*

### Business/Functional Perspective
### Nominal Restore From Seq File

**Program Purpose**  
The program copies a sequential ledger file (`ledger.seq`) into the system’s ISAM ledger file, serving as a restoration routine. It ensures that a backup of the ledger is available and allows the system to recover data if the primary file is missing or corrupted. The routine logs progress and any issues, providing audit visibility and reducing the risk of data loss.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- Indicates when the input ledger file cannot be found.  
- Reports errors opening either the input or output file.  
- Flags read errors from the sequential file.  
- Flags write errors when copying to the ISAM file.  
- Notifies if program arguments are incorrect or required environment variables are missing.  
In each case the program writes a clear message to the log and stops processing.

**User Flow Summary**  
The user runs the program (typically from the command line or as part of a batch job). The routine logs a start message, attempts to open the sequential ledger file, and, if successful, reads each record and writes it to the target ISAM ledger file. While doing so it records any read or write problems. After all records are processed it logs the total number of records copied, closes the files, and exits with a success status. The user reviews the log to confirm that the ledger was restored or to diagnose any errors that occurred.

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-Main-Start, obtains command line arguments, logs an initial message, and opens the input sequential ledger file. [Seen in: aa000-Main-Start.]  
It then enters aa010-Read-Recs, looping to read each record from the input file, writing it to an output file while counting records and handling any read/write errors. [Seen in: aa010-Read-Recs.]  
Upon reaching end of file or an error, aa020-Finish-Off closes both files, logs the record counts, sets the return code to zero, and exits the program. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and sets logging parameters before printing a start message via Call‑Sysout. [Seen in: aa000-Main-Start.]  
It initializes record counters to zero and opens the input ledger file; if the file cannot be opened, it logs an error and aborts. [Seen in: aa000-Main-Start.]  
It then opens the output ledger file, checking for errors and aborting if necessary. [Seen in: aa000-Main-Start.]

5.3 Core Processing  

Path: Input File Open Error  
Trigger: FS‑Reply not equal to zeros after attempting to open ledger‑File‑Seq.  
Key steps: Log “No GL Ledger file to process”, close ledger‑File, log “CLOSE”, and goback.  
I/O: ledger‑File‑Seq.  
Outcomes: Program terminates immediately with an error message.  
[Seen in: aa000-Main-Start.]

Path: Output File Open Error  
Trigger: FS‑Reply not equal to zeros after attempting to open ledger‑File.  
Key steps: Log “Failed on open – GL Ledger file = ” plus FS‑Reply, log “CLOSE”, and goback.  
I/O: ledger‑File.  
Outcomes: Program terminates immediately with an error message.  
[Seen in: aa000-Main-Start.]

Path: Read Error  
Trigger: FS‑Reply not equal to zeros after a read of ledger‑File‑Seq.  
Key steps: Log SY003 with FS‑Reply, call Call‑Sysout, and go to aa020‑Finish‑Off.  
I/O: ledger‑File‑Seq.  
Outcomes: Processing stops, files are closed, counts logged, and program exits.  
[Seen in: aa010-Read-Recs.]

Path: Write Error  
Trigger: FS‑Reply not equal to zero after writing to ledger‑File.  
Key steps: Log SY006, call Call‑Sysout, and go to aa020‑Finish‑Off.  
I/O: ledger‑File.  
Outcomes: Processing stops, files are closed, counts logged, and program exits.  
[Seen in: aa010-Read-Recs.]

Path: End‑of‑File Normal Finish  
Trigger: Read at end of ledger‑File‑Seq.  
Key steps: Go to aa020‑Finish‑Off.  
I/O: ledger‑File‑Seq.  
Outcomes: Files closed, record counts logged, Return‑Code set to zero, and program exits.  
[Seen in: aa010-Read-Recs.]

5.4 Termination  
The program closes both the input and output ledger files, logs the total records processed, sets Return‑Code to zero, and exits via goback. [Seen in: aa020-Finish-Off.]  
Any earlier errors cause an immediate goback after logging the error message. [Seen in: aa000-Main-Start.]

---
## nominalUNL
*[124/267]*

### Business/Functional Perspective
### Ledger File Backup  

**Program Purpose**  
The program creates a sequential backup copy of the main ledger database. It reads every record from the primary ISAM ledger file and writes them to a new file named *ledger.seq*. The backup preserves data integrity, supports recovery, and provides an audit trail. It logs progress and any errors to a system log so that administrators can verify the operation.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the ledger file does not exist or cannot be opened, the user is informed that “No ledger file to process.”  
- When a read error occurs while accessing the source file, the message “Problem reading ledger file = …” is displayed, showing the error code.  
- If a write error happens while creating *ledger.seq*, the user sees “Write error on .seq file.”  
- After finishing, the program reports the total number of records read and written.  
- If the program is invoked with incorrect arguments, a brief “Program arguments incorrect” notice is shown.  
- If required environment variables are missing, a “Environment variables not yet set up” notice is issued.  
- A note message prompts the user to press return, ensuring the message is seen.  

**User Flow Summary**  
The user starts the program (optionally providing command‑line arguments). The program checks that the ledger file is available and that the environment is correctly configured. It then reads each record from the primary ledger file, writes it to the backup *ledger.seq* file, and keeps a running count of records processed. If any read or write error occurs, the user is notified immediately and the operation stops. When all records are processed, the program reports how many records were read and written, closes both files, and terminates, leaving the backup file ready for use in recovery or audit.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments, setting logging parameters, and writing an initial status message to the system log. [Seen in: aa000-Main-Start.]  
It then opens the source ledger file for input, verifies its existence, and opens a sequential output file for writing. [Seen in: aa000-Main-Start.]  
The main loop reads each record from the source file, writes it to the sequential file while counting records, and handles any read or write errors by logging and aborting. [Seen in: aa010-Read-Recs.]  
After all records are processed or an error occurs, the program closes both files, logs a summary of records processed, sets the return code to zero, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to parse command line arguments and initializes logging system identifiers. [Seen in: aa000-Main-Start.]  
It sets the working‑storage variables WS-Log-System and WS-Log-File-no, clears the SO-Print buffer, and writes a startup message to the system log via Call‑Sysout. [Seen in: aa000-Main-Start.]  
The source ledger file is opened for input; if the file cannot be opened, an error message is logged and the program exits. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Record Transfer  
Trigger: Successful open of source ledger file and entry into aa010‑Read‑Recs loop.  
Key steps: Read each record, increment WS‑Rec‑Cnt‑In, write to ledger‑File‑Seq, increment WS‑Rec‑Cnt‑Out, handle read/write errors by logging and aborting to aa020‑Finish‑Off.  
I/O: ledger‑File (input), ledger‑File‑Seq (output).  
Outcomes: WS‑Rec‑Cnt‑In and WS‑Rec‑Cnt‑Out updated; on error, logs and aborts.  
[Seen in: aa010-Read-Recs.]

Path: Source File Missing  
Trigger: FS‑Reply not zero after opening ledger‑File.  
Key steps: Log “No ledger file to process”, close file, exit.  
I/O: ledger‑File.  
Outcomes: Program exits before processing.  
[Seen in: aa000-Main-Start.]

Path: Read Error  
Trigger: FS‑Reply not zero during read of ledger‑File.  
Key steps: Log SY003 with FS‑Reply, abort to aa020‑Finish‑Off.  
I/O: ledger‑File.  
Outcomes: Program exits after closing files, summary logged.  
[Seen in: aa010-Read-Recs.]

Path: Write Error  
Trigger: FS‑Reply not zero after write to ledger‑File‑Seq.  
Key steps: Log SY006, abort to aa020‑Finish‑Off.  
I/O: ledger‑File‑Seq.  
Outcomes: Program exits after closing files, summary logged.  
[Seen in: aa010-Read-Recs.]

Path: Finish‑Off  
Trigger: End of file or error path leads to aa020‑Finish‑Off.  
Key steps: Close both files, log record counts, set Return‑Code to zero, goback.  
I/O: ledger‑File‑Seq, ledger‑File.  
Outcomes: Program terminates cleanly.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both the input and output ledger files, logs the total number of records processed, sets the Return‑Code to zero, and exits with a GOBACK. [Seen in: aa020-Finish-Off.]  
No additional cleanup is performed beyond file closure and logging. [Seen in: aa020-Finish-Off.]

---
## otm3LD
*[125/267]*

### Business/Functional Perspective
### OTM3 Table Load  

**Program Purpose**  
The program moves data from an SL OTM3 flat‑file into a MySQL RDBMS table used by the ACAS system. It reads the system configuration, verifies database settings, and then imports each record, handling duplicate keys and logging all actions. The result is a consistent, auditable transfer of transaction data that keeps the database current and ready for reporting and further processing.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
* System configuration errors – missing or unreadable system parameter file.  
* Database configuration errors – missing or invalid MySQL connection details.  
* File access errors – problems opening or reading the SL OTM3 file.  
* Duplicate key handling – records that already exist are rewritten or skipped.  
* Write failures – errors inserting or updating the database, including SQL errors.  
* Summary – total records read, records written, records rewritten, and log entries written.  

**User Flow Summary**  
A user launches the program (optionally passing up to two command‑line arguments). The program loads system parameters and checks the MySQL connection settings. It then opens the SL OTM3 file for reading and the target table for writing. Each record is processed: the program attempts to insert it into the database, handles duplicates by rewriting if possible, and logs any errors. Counters keep track of how many records were read, written, and rewritten. Once all records are processed, a final summary is printed, the files are closed, and the program exits.  

**Program Linkages**  
- acas-get-params  
- acas019  
- ACAS-Sysout  
- MySQL_rollback  
- MySQL_commit

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **aa000-main-start**, performing argument parsing, system parameter file read, and RDB configuration. [Seen in: aa000-main-start.]  
After parameters are loaded, **aa010-Proc-Override** opens the Cobol OTM3 input file and the MySQL output table, preparing for record transfer. [Seen in: aa010-Proc-Override.]  
The main loop in **aa010-Read** reads each OTM3 record, writes it to the database, handles duplicates, and continues until EOF or an error, finally ending in **aa999-Finish**. [Seen in: aa010-Read.]

5.2 Initialization  
The program parses up to two command line arguments via **zz020-Get-Program-Args**, sets logging identifiers, and opens the system parameter file, checking for read errors. [Seen in: aa000-main-start.]  
If the system file indicates that only Cobol files are in use, it invokes **acas-get-params** to load RDB settings; otherwise it validates the existing RDBMS-DB-Name and aborts if missing. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: program start (aa000-main-start).  
Key steps: open system file, read record, load RDBMS fields, call **acas-get-params** if needed.  
I/O: System-File.  
Outcomes: RDBMS-Host, User, etc set; return-code 128 on error.  
[Seen in: aa000-main-start.]

Path: File and RDB Open  
Trigger: successful system parameter load (aa010-Proc-Override).  
Key steps: call **acas019-Open-Input** to open Cobol file, then **acas019-Open-Output** to open MySQL table, checking FS-Reply after each.  
I/O: acas019 (Cobol file, RDB).  
Outcomes: File-System-Used flags set, FS-Reply checked, program may abort on error.  
[Seen in: aa010-Proc-Override.]

Path: Record Transfer Loop  
Trigger: after files opened (aa010-Read).  
Key steps: read next record, write to RDB, handle duplicate key (SQL-State 23000, FS-Reply 22 or 99, SQL-Err 1062/1022) by rewriting or counting, increment counters, loop until EOF.  
I/O: acas019-Read-Next, acas019-Write, acas019-Rewrite.  
Outcomes: ws-Rec-Cnt-In, ws-Rec-Cnt-Out, ws-Rec-Cnt-R-Out updated; FS-Reply and SQL-State may trigger error path.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: any FS-Reply not zero after an acas019 call (aa100-Check-4-Errors).  
Key steps: log error details, optionally rollback, set return-code, go to finish.  
I/O: none directly.  
Outcomes: program exits with error status.  
[Seen in: aa100-Check-4-Errors.]

Path: Finish and Cleanup  
Trigger: EOF or error (aa999-Finish).  
Key steps: output record counts, close RDB and Cobol files, close system file, log end message, goback.  
I/O: acas019-Close, System-File.  
Outcomes: program terminates cleanly.  
[Seen in: aa999-Finish.]

5.4 Termination  
Upon completion, **aa999-Finish** logs totals, closes the RDB and Cobol files, closes the system file, and issues a GOBACK to return control. [Seen in: aa999-Finish.]  
The program exits with the return-code set during error handling or zero if successful. [Seen in: aa999-Finish.]

---
## otm3MT
*[126/267]*

### Business/Functional Perspective
### Open Item File Handler

**Program Purpose**  
This program manages sales open‑item records in a relational database. It lets other parts of the system create, read, update, delete, and search these records while guaranteeing that keys are unique and that data remains consistent. By handling database access centrally, it supports accurate reporting, compliance, and reduces the risk of duplicate or lost data.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
* Successful operation – the requested action completes and the record (if any) is returned.  
* End of data – no further records are available.  
* Record not found – the requested key does not exist.  
* Duplicate key – an attempt was made to insert a record with a key that already exists.  
* Database error – connection or SQL problems prevent the operation.  
* Invalid request – the calling program used an unsupported function or bad parameters.  
* General error – any other failure during processing.

**User Flow Summary**  
1. A calling module supplies a record structure and a function code (open, close, read next, read by key, start, write, rewrite, or delete).  
2. The program connects to the database (if not already open) and performs the requested action.  
3. For read operations it returns the matching record and a status code indicating success, end of data, or record‑not‑found.  
4. For write, rewrite, or delete operations it returns a status code showing success, duplicate‑key, or database failure.  
5. After completion, the program logs the action (when enabled) and returns control to the caller, providing any error details in the record fields.

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- MySQL-1000-OPEN  
- MySQL-1980-CLOSE  
- MySQL-1210-COMMAND  
- MySQL-1220-STORE-RESULT  
- MySQL-1239-EXIT  
- fhlogger  
- Ca-Process-Logs

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program entry performs environment setup and initialises variables. [Seen in: ba-ACAS-DAL-Process.]  
It evaluates the File-Function parameter to dispatch to the appropriate processing paragraph (Open, Close, Read-Next, Read-Indexed, Write, Rewrite, Delete, Start, or sorted reads). [Seen in: ba-ACAS-DAL-Process.]  
Each processing paragraph performs the requested database operation and then jumps to the common termination paragraph ba999-end. [Seen in: ba999-end.]

5.2 Initialization  
The program accepts environment line count, sets screen exception flags, and adjusts line counters. [Seen in: ba-ACAS-DAL-Process.]  
It clears SQL state, error messages, and logging fields before processing. [Seen in: ba010-Initialise.]  
No file or database opens occur at initialization; database connection is established only when the Open function is invoked. [Seen in: ba020-Process-Open.]

5.3 Core Processing  
Path: Open  
Trigger: File‑Function = 1 (Open).  
Key steps: build database connection strings, perform MYSQL‑1000‑OPEN, set cursor inactive, set WS‑File‑Key to “OPEN SL OTM3”.  
I/O: SAITM3‑REC table (database connection).  
Outcomes: FS‑Reply 0, WE‑Error 0, SQL‑State 0, cursor inactive.  
[Seen in: ba020-Process-Open.]

Path: Read‑Next  
Trigger: File‑Function = 3 (Read‑Next).  
Key steps: if cursor not active, build WHERE clause for lowest key, perform SELECT, store result, set cursor active; if cursor active, perform FETCH, handle EOF, unload HVs to record.  
I/O: SAITM3‑REC table, cursor.  
Outcomes: FS‑Reply 0 on data, 10 on EOF or no data, WE‑Error 0 or 10, WS‑File‑Key indicates status.  
[Seen in: ba040-Process-Read-Next, ba041-Reread.]

Path: Read‑Indexed  
Trigger: File‑Function = 4 (Read‑Indexed).  
Key steps: build WHERE clause with key, perform SELECT, if zero rows set FS‑Reply 23, free cursor; else fetch, handle errors, unload HVs.  
I/O: SAITM3‑REC table.  
Outcomes: FS‑Reply 0 on success, 23 on key not found, WE‑Error 0 or error codes.  
[Seen in: ba050-Process-Read-Indexed.]

Path: Write  
Trigger: File‑Function = 5 (Write).  
Key steps: load HVs from record, perform INSERT via bb200‑Insert, check row count, handle duplicate key error (SQL‑Err 1062/1022 or SQL‑State 23000) set FS‑Reply 22.  
I/O: SAITM3‑REC table.  
Outcomes: FS‑Reply 0 on success, 22 on duplicate key, WE‑Error 0 or 99, SQL‑Err and SQL‑Msg set.  
[Seen in: ba070-Process-Write.]

Path: Delete  
Trigger: File‑Function = 8 (Delete).  
Key steps: build WHERE clause, perform DELETE, if row count not 1 handle error, set FS‑Reply 99, WE‑Error 995.  
I/O: SAITM3‑REC table.  
Outcomes: FS‑Reply 0 on success, 99 on failure, WE‑Error 995.  
[Seen in: ba080-Process-Delete.]

Path: Start  
Trigger: File‑Function = 9 (Start).  
Key steps: validate access‑type, clear active cursors, set relation operator based on Access‑Type, build WHERE clause, perform SELECT, set cursor active if rows.  
I/O: SAITM3‑REC table.  
Outcomes: FS‑Reply 0 on success, 21 on key not found, WE‑Error 0.  
[Seen in: ba060-Process-Start.]

5.4 Termination  
The program performs any required logging if Testing‑1 is set and then exits via ba999‑exit. [Seen in: ba999-end, ba999-exit.]  
All processing paragraphs conclude by jumping to ba999‑end, ensuring a consistent exit point. [Seen in: ba999-end.]

---
## otm3RES
*[127/267]*

### Business/Functional Perspective
### OTM3 Backup Restore  

**Program Purpose**  
The program recreates the OTM3 ISAM data file from a sequential backup file. It reads each record from the backup, writes it into the live OTM3 file, and logs the progress and any errors. This operation ensures that the accounting system can recover from corruption or loss of the original ISAM file. By verifying the integrity of the restored data, the program supports audit readiness and reduces the risk of data loss.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the backup file is missing or unreadable, the program logs “No OTM3 file to process.”  
- If a record cannot be read, it logs a message indicating a read error.  
- If a record cannot be written, it logs a write‑error message.  
- Upon successful completion it logs the total number of records read and written.  
- Any unexpected file status is reported with a descriptive message.

**User Flow Summary**  
1. The user runs the restore program, typically from a command line or batch job.  
2. The program looks for the backup file `openitm3.seq`.  
3. If the file is not found, a message is logged and the program exits.  
4. If the file is found, it is opened for reading.  
5. Each record is read from the sequential file and written into the OTM3 ISAM file.  
6. The program keeps a count of records processed and logs that count when finished.  
7. If any read or write error occurs, the program logs the issue and stops further processing.  
8. When all records have been handled, the program closes the files, logs closing messages, and exits.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by retrieving command line arguments and initializing logging parameters. [Seen in: aa000-Main-Start.]  
It opens the source sequential file “openitm3.seq” for input and the target ISAM file for output, aborting if either open fails. [Seen in: aa000-Main-Start.]  
It then reads each record from the source file, writes it to the target file, counts input and output records, and handles any read/write errors before closing both files and exiting. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and sets logging system and file numbers. [Seen in: aa000-Main-Start.]  
It initializes record counters to zero and prepares a message string for logging. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read-Loop  
Trigger: Entry into aa010-Read-Recs.  
Key steps: read record, check FS-Reply, write record, increment counters, loop until end.  
I/O: OTM3-File-Seq, Open-Item-File-3.  
Outcomes: record counts, error flag leads to finish.  
[Seen in: aa010-Read-Recs.]

Path: Error-Open-Input  
Trigger: FS-Reply after opening OTM3-File-Seq.  
Key steps: log error message, close Open-Item-File-3, goback.  
I/O: OTM3-File-Seq, Open-Item-File-3.  
Outcomes: program exits early.  
[Seen in: aa000-Main-Start.]

Path: Error-Open-Output  
Trigger: FS-Reply after opening Open-Item-File-3.  
Key steps: log error, goback.  
I/O: Open-Item-File-3.  
Outcomes: program exits early.  
[Seen in: aa000-Main-Start.]

Path: Error-Read  
Trigger: FS-Reply not zero during read.  
Key steps: log error, go to finish.  
I/O: OTM3-File-Seq.  
Outcomes: exit loop, close files.  
[Seen in: aa010-Read-Recs.]

Path: Error-Write  
Trigger: FS-Reply not zero during write.  
Key steps: log error, go to finish.  
I/O: Open-Item-File-3.  
Outcomes: exit loop, close files.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: End of file or error.  
Key steps: close files, log totals, set Return-Code to zero, goback.  
I/O: OTM3-File-Seq, Open-Item-File-3.  
Outcomes: program terminates successfully.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
After closing both files, the program logs the total records processed and a final “CLOSE” message before setting Return-Code to zero. [Seen in: aa020-Finish-Off.]  
The program then performs a GOBACK to terminate execution. [Seen in: aa020-Finish-Off.]

---
## otm3UNL
*[128/267]*

### Business/Functional Perspective
### OTM3 File Backup  

**Program Purpose**  
The program creates a backup copy of the current OTM3 data file by exporting all records to a sequential file named *openitm3.seq*. This provides a reliable restore point for the accounting system and ensures data integrity when the primary ISAM library becomes incompatible or corrupted. By logging the operation details and any issues, it helps maintain audit trails and reduces the risk of data loss.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the OTM3 file is missing, the user is notified that there is “No otm3 file to process”.  
- If a record cannot be read, the program reports a problem reading the file and stops.  
- If a record cannot be written to the sequential file, a write‑error message is issued and the process terminates.  
- If the command‑line arguments are incorrect, the user receives a message indicating incorrect arguments.  
- If required environment variables are not set, the program aborts with an environment‑setup error.  

**User Flow Summary**  
A user runs the program, optionally supplying arguments that control logging and file handling. The program opens the current OTM3 data file and creates a new sequential file. As it reads each record, it writes the record to the sequential file and counts the records processed. Once all records are handled, it closes both files, logs the total number of records read and written, and then exits. If any issue arises—such as a missing file, read or write error, or configuration problem—the program logs a clear message, stops the operation, and closes any open resources.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa000-Main-Start, retrieving command‑line arguments, initializing logging, and opening the source otm3 file. [Seen in: aa000-Main-Start.]  
It then opens a sequential output file and enters a loop in aa010-Read-Recs that reads each record from the source file, writes it to the output file, and tracks record counts. [Seen in: aa010-Read-Recs.]  
Upon reaching end‑of‑file or encountering an error, aa020-Finish-Off closes both files, reports the record totals, and exits the program. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command‑line parameters and sets up logging parameters (WS-Log-System, WS-Log-File-no). [Seen in: aa000-Main-Start.]  
It opens the input otm3 file (Open-Item-File-3) and, if the file is missing, writes a message and aborts; otherwise it opens the output sequential file (OTM3-File-Seq) and initializes record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read-Records  
Trigger: Loop in aa010-Read-Recs that continues until the input file reaches end‑of‑file or an error occurs.  
Key steps: read next record from Open-Item-File-3; if FS‑Reply indicates error, log message and exit loop; otherwise write the record to OTM3-File-Seq, check write status, and increment input and output counters.  
I/O: Open-Item-File-3, OTM3-File-Seq.  
Outcomes: Updated ws-Rec-Cnt-In and ws-Rec-Cnt-Out; possible error messages logged; control passes to aa020-Finish-Off on error or EOF.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: Execution reaches aa020-Finish-Off either after normal EOF or after an error during reading/writing.  
Key steps: close OTM3-File-Seq and Open-Item-File-3; compose a summary string with record counts; log the summary; set Return-Code to zero; goback to terminate.  
I/O: None beyond file closures; uses Call-Sysout to output summary.  
Outcomes: Files closed, summary logged, program exits with Return-Code zero.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both the input and output files, logs a final summary of records processed, sets Return-Code to zero, and performs a GOBACK to terminate. [Seen in: aa020-Finish-Off.]

---
## otm5LD
*[129/267]*

### Business/Functional Perspective
### OTM5 Table Load

**Program Purpose**  
This program transfers transaction data from a PL OTM5 file into a MySQL database table. It reads system parameters, validates database connectivity, opens the source file, writes each record to the target table, and records duplicate entries without stopping the load. The process provides audit‑ready record counts and logs any issues, ensuring data consistency and minimizing manual intervention.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- Failure to read the system parameter file.  
- Missing or invalid database connection details.  
- OTM5 file not found or unable to open.  
- Errors reading a record from the OTM5 file.  
- Duplicate records detected (handled by re‑writing).  
- Errors writing to the database table.  
- Problems committing or rolling back changes.  
- Summary of processed records, rewritten records, and log entries upon completion.

**User Flow Summary**  
The user initiates the program (typically via a script or scheduler). The program loads configuration settings, verifies database credentials, and checks that the OTM5 source file exists. It then opens the file and the database table, looping through each record: each is written to the database, with duplicate entries noted and rewritten. Any write errors are reported, and the process can be stopped or continued depending on severity. After all records are processed, the program outputs the total number of records read, written, rewritten, and the count of log records written, then cleanly closes the files and exits.

**Program Linkages**  
- acas029  
- acas-get-params  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **aa000-main-start**, parsing command line arguments and initializing logging parameters. [Seen in: aa000-main-start.]  
It opens the system parameter file, reads the first record, and loads RDB connection details, optionally invoking **acas-get-params** if needed. [Seen in: aa000-main-start.]  
After establishing database connectivity, the program opens the OTM5 COBOL file for input and the target MySQL table for output, then enters a loop that reads each OTM5 record and writes it to the database until EOF or an error occurs, finally closing all files and exiting. [Seen in: aa000-main-start, aa010-Read, aa999-Finish.]

5.2 Initialization  
The initialization phase sets logging system and file numbers, parses program arguments via **zz020-Get-Program-Args**, and prepares the SO-Print buffer. [Seen in: aa000-main-start.]  
It opens the system file, reads the first record, and verifies that RDBMS parameters are present, performing a fallback to **acas-get-params** if the parameters are missing or cobol files are in use. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: Opening and reading System-File at program start.  
Key steps: open input System-File, read record, check FS-Reply, load RDBMS-DB-Name, User, Passwd, DB-Name, Port, Socket; if missing, call **acas-get-params**.  
I/O: System-File.  
Outcomes: RDBMS settings loaded into RDBMS-Host, User, Passwd, DB-Name, Port, Socket; error handling if FS-Reply non‑zero.  
[Seen in: aa000-main-start.]

Path: OTM5 File Open  
Trigger: **acas029-Open-Input** performed after RDBMS settings.  
Key steps: set fn-open, fn-input, call **acas029**, check FS-Reply for errors.  
I/O: OTM5 file.  
Outcomes: OTM5 file opened or error handled.  
[Seen in: acas029-Open-Input.]

Path: RDB Table Open  
Trigger: **acas029-Open-Output** performed after OTM5 file open.  
Key steps: set fn-open, fn-output, call **acas029**, check FS-Reply.  
I/O: RDB table.  
Outcomes: RDB table opened or error handled.  
[Seen in: acas029-Open-Output.]

Path: Record Load Loop  
Trigger: **aa010-Read** loop.  
Key steps: read next record via **acas029-Read-Next**, if EOF go to finish; else write record via **acas029-Write**, handle duplicate keys and errors, increment counters.  
I/O: OTM5 file, RDB table.  
Outcomes: records processed, counters updated, errors reported.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: FS-Reply non‑zero in any operation.  
Key steps: display error messages, optionally rollback, set return-code, exit.  
I/O: none.  
Outcomes: program terminates with error status.  
[Seen in: aa010-Read, aa100-Check-4-Errors.]

Path: Finish  
Trigger: **aa999-Finish**.  
Key steps: output summary, close RDB and OTM5 files, close system file, goback.  
I/O: close System-File, **acas029-Close** for RDB and OTM5.  
Outcomes: program ends.  
[Seen in: aa999-Finish.]

5.4 Termination  
The termination phase outputs record counts and log statistics, closes the system file, the RDB table, and the OTM5 file, and then returns control to the caller. [Seen in: aa999-Finish.]  
The program exits with a GOBACK, leaving the return-code set according to any errors encountered during processing. [Seen in: aa999-Finish.]

---
## otm5MT
*[130/267]*

### Business/Functional Perspective
### Open-Item File Database Access  

**Program Purpose**  
The program provides a single point of access to the Sales Open‑Item File 5 database table. It handles all file operations—open, close, read, write, delete, and rewrite—ensuring that each transaction is performed against a consistent, up‑to‑date relational data source. By validating keys, detecting duplicates, and reporting database errors, it protects the integrity of open‑item records and supports audit trails and compliance requirements for the accounting system.  

**Screen Interactions**  
No direct screens. This program is invoked from a separate data‑entry context and returns results back to that calling module.  

**Messages and Errors**  
- **Success** – All requested operations complete without error.  
- **No Data** – A read operation returns no rows (end‑of‑file).  
- **Duplicate Key** – Attempting to insert a record with an existing key is rejected.  
- **Key Not Found** – A requested key does not exist when reading or deleting.  
- **Invalid Function** – The operation code supplied is not supported.  
- **Database Error** – Any SQL error (e.g., connectivity, constraint violation) is reported with a descriptive message.  

**User Flow Summary**  
When a caller needs to interact with the Open‑Item table, it passes a data record and a function code (open, close, read next, read indexed, write, delete, rewrite, or start). The program opens the database connection if required, performs the requested action, and loads any retrieved data back into the caller’s record area. Upon completion, it returns a status code that indicates success, end‑of‑data, key problems, or database errors, allowing the calling module to decide how to inform the user or retry the operation.  

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the `ba-ACAS-DAL-Process` paragraph, where it accepts environment lines, sets screen exceptions, and initializes key variables. It then evaluates the `File-Function` linkage field to dispatch to one of several processing paragraphs (`ba020-Process-Open`, `ba030-Process-Close`, `ba040-Process-Read-Next`, `ba050-Process-Read-Indexed`, `ba070-Process-Write`, `ba080-Process-Delete`, etc.). After the chosen path completes, control returns to `ba999-end` where any final logging is performed before the program exits. [Seen in: ba-ACAS-DAL-Process.]

5.2 Initialization  
The `ba010-Initialise` paragraph clears the SQL state and resets all error and status fields to zero or spaces. It also sets up the environment for screen handling and prepares the `WS-File-Key` and other working-storage items for subsequent operations. [Seen in: ba010-Initialise.]

5.3 Core Processing  
Path: Process-Open  
Trigger: `File-Function = 1`  
Key steps: Builds MySQL connection strings, performs `MYSQL-1000-OPEN`, and sets cursor inactive.  
I/O: None (only connection).  
Outcomes: `FS-Reply` set to 0 on success; `WS-File-Key` set to "OPEN PL OTM5".  
[Seen in: ba020-Process-Open.]

Path: Process-Close  
Trigger: `File-Function = 2`  
Key steps: Frees any active cursor (`ba998-Free`), performs `MYSQL-1980-CLOSE`.  
I/O: None (only connection).  
Outcomes: `WS-File-Key` set to "CLOSE PL OTM5".  
[Seen in: ba030-Process-Close.]

Path: Process-Read-Next (normal)  
Trigger: `File-Function = 3`  
Key steps: If cursor inactive, builds a SELECT with key >= '000000000000000', executes it, stores result, and fetches first row. If cursor active, performs a FETCH.  
I/O: Table `PUITM5-REC`.  
Outcomes: `FS-Reply` 10 on EOF, `WE-Error` 0 on success, `WS-File-Key` holds key of current record.  
[Seen in: ba040-Process-Read-Next, ba041-Reread.]

Path: Process-Read-Indexed  
Trigger: `File-Function = 4`  
Key steps: Builds a SELECT with key = value from `WS-OTM5-Record`, executes, fetches first row.  
I/O: Table `PUITM5-REC`.  
Outcomes: `FS-Reply` 23 if not found, `WE-Error` 0 on success, `WS-File-Key` holds key.  
[Seen in: ba050-Process-Read-Indexed, ba051-UnloadHVs.]

Path: Process-Write  
Trigger: `File-Function = 5`  
Key steps: Loads host variables (`bb000-HV-Load`), builds an INSERT statement, executes it, checks row count.  
I/O: Table `PUITM5-REC`.  
Outcomes: `FS-Reply` 99 on error, `WE-Error` 22 on duplicate key, `WS-File-Key` set to key.  
[Seen in: ba070-Process-Write, bb200-Insert.]

Path: Process-Delete  
Trigger: `File-Function = 8`  
Key steps: Builds a DELETE WHERE key = value, executes, verifies one row deleted.  
I/O: Table `PUITM5-REC`.  
Outcomes: `FS-Reply` 99 on error, `WE-Error` 995 on delete failure, `WS-File-Key` set to key.  
[Seen in: ba080-Process-Delete, bb200-Delete.]

5.4 Termination  
The `ba999-end` paragraph performs optional logging (`Ca-Process-Logs`) if testing is enabled, then exits the program via `ba999-exit`.  
Any final status fields (`FS-Reply`, `WE-Error`, `SQL-State`, `SQL-Err`, `SQL-Msg`) are left in the linkage area for the caller.  
[Seen in: ba999-end, ba999-exit.]

---
## otm5RES
*[131/267]*

### Business/Functional Perspective
### OTM5 File Restore  

**Program Purpose**  
The program restores an OT‑M5 data file by copying records from a sequential backup file into the live ISAM file. It enables quick recovery when the original file becomes corrupted or missing, ensuring continuity of accounting operations and reducing system downtime.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and writes its results to the system log file (`SYS‑DISPLAY.log`).  

**Messages and Errors**  
- If the backup file does not exist, a message “No OTM5 file to process” is written.  
- Errors that occur while opening, reading from, or writing to files generate messages indicating a read or write failure.  
- At completion a summary line lists the number of records read and written.  

**User Flow Summary**  
1. The user starts the program (typically from the command line).  
2. The program attempts to open the sequential backup file. If it cannot be opened, it records a “no file” message and exits.  
3. If the source file opens successfully, the program opens the destination ISAM file.  
4. It then reads each record from the source and writes it to the destination, keeping a count of records processed. Any read or write error stops the operation and logs the issue.  
5. When all records have been handled or an error occurs, the program logs a final line showing the total records read and written, closes the files, and exits.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and configuring logging before opening the source sequential file and the target ISAM file. [Seen in: aa000-Main-Start.]  
It then enters a loop that reads each record from the source file, writes it to the target file, and updates record counters, handling any read or write errors by logging and aborting the loop. [Seen in: aa010-Read-Recs.]  
After the loop terminates, the program closes both files, logs the total records processed, sets a zero return code, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs `zz020-Get-Program-Args` to capture command‑line parameters, sets logging system and file numbers, and outputs a header message via `Call-Sysout`. [Seen in: aa000-Main-Start.]  
It then opens the input sequential file `otm5-File-Seq`; if the open fails, it logs an error and aborts. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: File Open Success  
Trigger: Successful `open input otm5-File-Seq` and `open output Open-Item-File-5`.  
Key steps: set record counters to zero, begin read loop.  
I/O: otm5-File-Seq, Open-Item-File-5.  
Outcomes: counters initialized, ready for record processing.  
[Seen in: aa000-Main-Start.]

Path: Read‑Write Loop  
Trigger: Each successful `read otm5-File-Seq`.  
Key steps: increment input counter, write record to Open-Item-File-5, increment output counter, handle read/write errors by logging and exiting loop.  
I/O: otm5-File-Seq, Open-Item-File-5.  
Outcomes: records transferred, counters updated, error status propagated to finish.  
[Seen in: aa010-Read-Recs.]

Path: Finish Off  
Trigger: End of file or error during read/write.  
Key steps: close both files, log total records in/out, set Return-Code to zero, goback.  
I/O: otm5-File-Seq, Open-Item-File-5.  
Outcomes: files closed, exit status set, program terminates.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes the input and output files, logs a final message indicating the number of records processed, sets the return code to zero, and exits with `goback`. [Seen in: aa020-Finish-Off.]

---
## otm5UNL
*[132/267]*

### Business/Functional Perspective
### OTM5 File Backup Export  

**Program Purpose**  
This program creates a backup copy of the OTM5 data file for the Applewood Accounting System. It reads each record from the live OTM5 source file and writes the same records to a new sequential file named *openitm5.seq*. The resulting backup supports data recovery, audit trails, and compliance with record‑keeping policies.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Missing source file** – “No OTM5 file to process.”  
- **Read error** – “Problem reading OTM5 file.”  
- **Write error** – “Write error on .seq file.”  
- **Argument error** – “Program arguments incorrect.”  
- **Environment error** – “Environment variables not yet set up.”  

**User Flow Summary**  
A user initiates the program (typically via a batch job or command line). The program opens the live OTM5 file. For each record read, it writes the same record to the backup file *openitm5.seq* and counts the records processed. If any file operation fails, a descriptive error message is logged and the program stops. Upon completion, the program logs the total number of records read and written and then terminates.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by performing argument retrieval and logging initialization, then attempts to open the source otm5 file for reading. [Seen in: aa000-Main-Start.]  
If the source file is available, it opens a sequential output file and enters a loop that reads each record, writes it to the output file, and updates record counters until the end of the source file or an error occurs. [Seen in: aa010-Read-Recs.]  
Upon completion or error, the program closes both files, logs the total records processed, sets the return code to zero, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command‑line arguments, then sets logging parameters (WS-Log-System and WS-Log-File-no) and logs a header message via Call‑Sysout. [Seen in: aa000-Main-Start.]  
It opens the input otm5 file (Open-Item-File-5); if the file cannot be opened, it logs a message and terminates early. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read‑and‑Write Records  
Trigger: Loop in aa010-Read-Recs until end of file or error.  
Key steps: Read next record from Open-Item-File-5, check FS-Reply for read errors, write the record to otm5-File-Seq, check FS-Reply for write errors, increment input and output record counters.  
I/O: Open-Item-File-5, otm5-File-Seq.  
Outcomes: Updated ws-Rec-Cnt-In and ws-Rec-Cnt-Out, error messages logged via Call‑Sysout on read/write failures, eventual transition to aa020‑Finish‑Off on end of file or error.  
[Seen in: aa010-Read-Recs.]

Path: Finish‑Off  
Trigger: End of input file or any read/write error detected in aa010-Read-Recs.  
Key steps: Close otm5-File-Seq and Open-Item-File-5, log total records processed, set Return-Code to zero, and perform goback to terminate.  
I/O: otm5-File-Seq, Open-Item-File-5.  
Outcomes: Files closed, final status message logged, program exits cleanly.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs a final message indicating the number of records processed, sets the return code to zero, and exits via goback. [Seen in: aa020-Finish-Off.]

---
## paymentsLD
*[133/267]*

### Business/Functional Perspective
### Payments Table Load

**Program Purpose**  
The program transfers payment records from a flat payments file into the company’s MySQL payment ledger. It validates each record, ensures no duplicate entries are inserted, and records progress and any issues. By automating this load, the system keeps the ledger current, supports audit trails, and reduces the risk of manual entry errors.

**Screen Interactions**  
No direct screens. This program runs from the command line, displays status and error messages through the system output stream, and terminates with a summary of records processed.

**Messages and Errors**  
- **System file errors** – problems opening or reading the configuration file.  
- **Missing payments file** – the source payments file is absent or empty.  
- **Database connection issues** – unable to open or write to the MySQL payment table.  
- **Duplicate key handling** – a payment already exists; the record is skipped or rewritten.  
- **Write failures** – other database write errors such as constraint violations or unexpected SQL errors.  
- **Commit/rollback failures** – issues finalizing the transaction when the database is not in a transactional mode.  
- **General failures** – any other unexpected error causes the program to stop and report the condition.

**User Flow Summary**  
The user starts the program, optionally passing command‑line arguments for the payment file. The program reads system parameters, verifies MySQL connectivity, and opens the payments file. It then reads each payment record, attempts to insert it into the ledger, and handles duplicates by ignoring or updating the existing entry. As each record is processed, status messages are printed. Once all records have been handled, the program commits the transaction, prints a summary showing how many records were read, inserted, and rewritten, and then exits.

**Program Linkages**  
- acas032  
- acas-get-params  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-main-start, performing argument parsing, logging initialization, and opening the system parameter file. [Seen in: aa000-main-start.]  
After loading system parameters and RDB configuration, the program opens the Cobol payments file and the MySQL payments table via acas032 routines, then enters the main read‑write loop at aa010-Read. [Seen in: aa010-Proc-Override.]  
The loop reads each payment record, writes it to the database, handles duplicate key errors by rewriting or counting, and terminates when EOF is reached, proceeding to aa999-Finish for cleanup and reporting. [Seen in: aa010-Read.]

5.2 Initialization  
The program begins by performing zz020-Get-Program-Args, initializing logging parameters, and opening the system file to read the system record. [Seen in: aa000-main-start.]  
It then loads RDB configuration either from the system record or by calling acas-get-params if Cobol files are in use, and sets up file and duplicate flags before opening the Cobol payments file and the MySQL payments table. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: System Setup  
Trigger: After reading system record and loading RDB settings.  
Key steps: Set file and duplicate flags to zero, open Cobol payments file via acas032-Open-Input, handle missing file, open MySQL payments table via acas032-Open, set Access-Type to zero, go to aa010-Read.  
I/O: System-File, Cobol Payments File, MySQL Payments Table.  
Outcomes: File-System-Used flags set, RDB opened, ready for record processing.  
[Seen in: aa010-Proc-Override.]  

Path: Record Load Loop  
Trigger: Entry to aa010-Read after successful file opens.  
Key steps: Read next payment record, check EOF, write record to MySQL via acas032-Write, handle duplicate key errors, increment counters, loop back.  
I/O: Cobol Payments File, MySQL Payments Table.  
Outcomes: ws-Rec-Cnt-In, ws-Rec-Cnt-Out, ws-Rec-Cnt-R-Out counters updated; duplicate records counted; errors logged.  
[Seen in: aa010-Read.]  

Path: Duplicate Key Handling  
Trigger: When acas032-Write returns Sql-State "23000" or fs-reply 22 or 99 or SQL-Err 1062/1022.  
Key steps: Reset FS-Reply and WE-Error, perform acas032-Rewrite, if rewrite fails log duplicate key message, else increment rewrite counter, continue loop.  
I/O: Cobol Payments File, MySQL Payments Table.  
Outcomes: Duplicate records rewritten or counted; processing continues.  
[Seen in: aa010-Read.]  

Path: Finish  
Trigger: EOF reached in aa010-Read or error causes exit.  
Key steps: Print summary counts, close MySQL table, close system file, close Cobol payments file, print EOJ message, goback.  
I/O: System-File, Cobol Payments File, MySQL Payments Table.  
Outcomes: Program terminates with return-code, resources released.  
[Seen in: aa999-Finish.]  

Path: Error Handling  
Trigger: Any fs-reply not zero in aa100-Check-4-Errors or aa010-Read.  
Key steps: Log error messages, perform rollback, go to aa999-Finish.  
I/O: None (logging only).  
Outcomes: Program aborts, rollback attempted.  
[Seen in: aa100-Check-4-Errors.]

5.4 Termination  
Upon completion or error, aa999-Finish prints record counts, closes the MySQL payments table, closes the system file, closes the Cobol payments file, outputs an EOJ message, and performs GOBACK. [Seen in: aa999-Finish.]  
The program ensures all file handles are released and any pending transactions are committed or rolled back before exiting. [Seen in: aa020-Rollback, aa999-Finish.]

---
## paymentsMT
*[134/267]*

### Business/Functional Perspective
### Sales Payments Table Handler  

**Program Purpose**  
The program manages the sales‑payments data stored in a relational database. It opens and closes the payments table, retrieves the next record or a record identified by key, writes new payments, updates existing ones, deletes single records, or purges the entire table. By enforcing key integrity and handling database errors, it ensures that payment records remain accurate and consistent for downstream accounting processes.  

**Screen Interactions**  
No direct screens. This program is invoked by other application modules that supply a payment record and a requested action; it returns status information and, for reads, the requested payment data.  

**Messages and Errors**  
- **Success** – The requested operation completes, and the program returns a zero status code.  
- **No Data / End of File** – When a read finds no more records, the program reports “EOF” and a 10 status code.  
- **Duplicate Key** – Attempts to insert a payment that already exists are reported with a “duplicate key” error.  
- **Invalid Key or Missing Record** – If a key supplied for a read, update, or delete does not exist, the program signals “record not found”.  
- **Database Errors** – Any SQL error (e.g., connection loss, syntax error, or other RDBMS problem) is reported with a descriptive message and the corresponding SQL state.  
- **Other Internal Errors** – If the program encounters an unexpected condition, it signals a generic error with code 99.  

**User Flow Summary**  
A calling module supplies a payment record and a function code. The function code may request one of the following actions: open the payments table, close it, read the next payment record, read a specific record by key, write a new record, update an existing record, delete a specific record, or delete all records.  

When the program receives a request, it first validates the function and key. For read operations it retrieves the requested payment data and places it in the shared record area, returning a success status or an appropriate error code. For write, update, and delete operations it executes the corresponding SQL statements, checks for duplicate or missing keys, and reports any database errors. After completing the requested action the program returns control to the caller, providing the resulting status, any error details, and, for reads, the payment record.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- MySQL_query  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry occurs in **ba-ACAS-DAL-Process** which performs initial environment setup and then evaluates *File-Function* to dispatch to the appropriate processing paragraph. [Seen in: ba-ACAS-DAL-Process.]  
Each dispatched paragraph performs its specific database operation, optionally handling RG (repeat group) data, and then performs cleanup before exiting via **ba999-end** or **ba999-exit**. [Seen in: ba999-end.]  
The program terminates by returning control to the caller with *FS-Reply*, *WE-Error*, *SQL-State*, and *SQL-Msg* set to indicate success or failure. [Seen in: ba999-exit.]

5.2 Initialization  
**ba010-Initialise** clears *SQL-State*, error message fields, and sets environment screen exceptions before any operation. [Seen in: ba010-Initialise.]  
The procedure also initializes environment line counts and prepares the linkage areas for the calling module. [Seen in: ba010-Initialise.]

5.3 Core Processing  

Path: **Open**  
Trigger: *File-Function* = 1 (OPEN).  
Key steps: perform **MYSQL-1000-OPEN** to establish a database connection, set *Cursor-Not-Active*, and log the operation.  
I/O: **MYSQL-1000-OPEN**, **MYSQL-1090-EXIT**.  
Outcomes: *fs-reply* set to 0 on success; on error, *fs-reply* non‑zero and *WE-Error* set.  
[Seen in: ba020-Process-Open.]

Path: **Read-Next**  
Trigger: *File-Function* = 3 (READ-NE next).  
Key steps: if cursor inactive, build WHERE clause for lowest key, execute SELECT, store result, fetch first record, load HVs, then process RG rows via **bc050-Process-Read-Indexed**.  
I/O: **MYSQL-1210-COMMAND**, **MYSQL-1220-STORE-RESULT**, **MYSQL-1239-EXIT**, **MYSQL-fetch-record**, **bc050-Process-Read-Indexed**.  
Outcomes: *fs-reply* 10 on EOF, *WE-Error* 0 on success, *WS-File-Key* set to key value.  
[Seen in: ba040-Process-Read-Next.]

Path: **Start**  
Trigger: *File-Function* = 9 (START).  
Key steps: validate *access-type*, build WHERE clause with comparison operator, execute SELECT, set cursor active if rows found, otherwise set *fs-reply* 21.  
I/O: **MYSQL-1210-COMMAND**, **MYSQL-1220-STORE-RESULT**, **MYSQL-1239-EXIT**.  
Outcomes: cursor active flag, *fs-reply* 0 on success, *WE-Error* 0, *WS-File-Key* set to key.  
[Seen in: ba060-Process-Start.]

Path: **Write**  
Trigger: *File-Function* = 5 (WRITE).  
Key steps: load HVs from record, perform INSERT via **bb200-Insert**, handle duplicate key errors, then process RG rows via **bc070-Process-Write**.  
I/O: **bb200-Insert**, **bc070-Process-Write**, **MYSQL-1210-COMMAND**.  
Outcomes: *fs-reply* 0 on success, *WE-Error* 22 on duplicate key, *WS-File-Key* set to key.  
[Seen in: ba070-Process-Write.]

Path: **Delete**  
Trigger: *File-Function* = 8 (DELETE).  
Key steps: build WHERE clause, execute DELETE, process RG rows via **bc080-Process-Delete**.  
I/O: **MYSQL-1210-COMMAND**, **bc080-Process-Delete**.  
Outcomes: *fs-reply* 0 on success, *WE-Error* 995 on delete error, *WS-File-Key* set to key.  
[Seen in: ba080-Process-Delete.]

Path: **Delete-All**  
Trigger: *File-Function* = 6 (DELETE-ALL).  
Key steps: execute DELETE FROM PLPAY-REC, then delete all RG rows via **bc085-Process-Delete-ALL**.  
I/O: **MYSQL-1210-COMMAND**, **bc085-Process-Delete-ALL**.  
Outcomes: *fs-reply* 0 on success, *WE-Error* 995 on error, *WS-File-Key* set to key.  
[Seen in: ba085-Process-Delete-All.]

5.4 Termination  
**ba999-end** performs optional logging via **Ca-Process-Logs** if *Testing-1* is set, then proceeds to **ba999-exit**. [Seen in: ba999-end.]  
**ba999-exit** exits the program, returning control to the caller with all status fields populated. [Seen in: ba999-exit.]

---
## paymentsRES
*[135/267]*

### Business/Functional Perspective
### Payments File Restore

**Program Purpose**  
The Payments File Restore utility rebuilds the ACAS payments data file from a sequential backup copy. It reads every record from the backup file, writes it to the live payments file, and logs the outcome. This ensures that the payments ledger can be recovered quickly after corruption or accidental deletion, supporting compliance and audit readiness while minimizing downtime.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- *No payments file found* – the program reports that there is nothing to process and stops.  
- *Unable to open payments file* – indicates a problem accessing the source file and halts the restore.  
- *Unable to open target file* – signals a write‑access issue and stops the process.  
- *Read error on a record* – an input record could not be read; the restore ends and the error is logged.  
- *Write error on a record* – a record could not be written to the target file; the restore ends and the error is logged.  
- *Normal completion* – the program reports the number of records read and written successfully.

**User Flow Summary**  
The user starts the program (typically from a batch or command line). The utility opens the sequential backup file containing payment records. It then reads each record one by one, writes it to the live payments file, and tracks how many records are processed. If any file access or data error occurs, a descriptive message is written to the log and the operation stops. When all records are handled, the program closes the files, logs the final counts, and exits cleanly.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command line arguments and initializing logging parameters in aa000-Main-Start. [Seen in: aa000-Main-Start.]  
It opens the source sequential payments file for input and, if successful, opens the destination ISAM file for output, handling any errors by logging and exiting. [Seen in: aa000-Main-Start.]  
It then enters a loop in aa010-Read-Recs that reads each record, writes it to the destination file, and counts records, terminating when end‑of‑file or an error occurs. [Seen in: aa010-Read-Recs.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to parse command line arguments and sets logging system and file numbers. [Seen in: aa000-Main-Start.]  
Logging is initialized by moving program name and file usage string to SO-Print and calling Call‑Sysout. [Seen in: aa000-Main-Start.]  
Input file payments‑File‑Seq is opened for reading; if the file does not exist or cannot be opened, an error message is logged and the program exits. [Seen in: aa000-Main-Start.]  
Output file Pay‑File is opened for writing; failure results in an error message and exit. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Read‑Write  
Trigger: Successful read of a record from Payments‑File‑Seq.  
Key steps: Increment ws‑Rec‑Cnt‑In, write WS‑Pay‑Record to Pay‑File, increment ws‑Rec‑Cnt‑Out.  
I/O: Payments‑File‑Seq, Pay‑File.  
Outcomes: Updated record counts; processing continues until EOF or error.  
[Seen in: aa010-Read‑Recs.]  

Path: Read Error  
Trigger: FS‑Reply not zero after a read attempt.  
Key steps: Log error message with SY003, call Sysout, go to aa020‑Finish‑Off.  
I/O: Payments‑File‑Seq.  
Outcomes: Program exits after finish.  
[Seen in: aa010-Read‑Recs.]  

Path: Write Error  
Trigger: FS‑Reply not zero after a write attempt.  
Key steps: Log SY006, call Sysout, go to aa020‑Finish‑Off.  
I/O: Pay‑File.  
Outcomes: Program exits after finish.  
[Seen in: aa010-Read‑Recs.]  

Path: End‑of‑File  
Trigger: End of file reached during read.  
Key steps: Go to aa020‑Finish‑Off.  
I/O: Payments‑File‑Seq.  
Outcomes: Files closed, counts logged, program exits.  
[Seen in: aa020‑Finish‑Off.]

5.4 Termination  
The aa020‑Finish‑Off paragraph closes both input and output files, logs the total record counts, sets Return‑Code to zero, and performs a GOBACK to terminate the program. [Seen in: aa020‑Finish‑Off.]

---
## paymentsUNL
*[136/267]*

### Business/Functional Perspective
### Payments File Backup  

**Program Purpose**  
The program creates a backup of the payments data by copying every record from the active payments file to a new sequential file named `pay.seq`. It logs the process, including the number of records read and written, to a system log for audit and recovery purposes. This backup ensures that accounting records remain available in case of file corruption or system failure. It supports compliance and data integrity by providing a reliable, recoverable copy of the payments data.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Missing or inaccessible payments file** – The user is notified that there is “No payments file to process”.  
- **Read error** – A message indicating “Problem reading payments file = …” is logged, and the program stops.  
- **Write error** – If the backup file cannot be written, a “Write error on .seq file” message is logged and the program stops.  
- **Completion summary** – After processing, a message displays the number of records read and the number written.  

**User Flow Summary**  
A user runs the program from the command line. It first checks for the existence of the payments file. If the file is present, the program reads each record, writes it to the backup sequential file, and counts how many records were processed. When all records have been handled, it logs a summary showing the total records read and written, then exits. The log file can be reviewed to confirm the backup operation succeeded.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments, configuring logging, and opening the input payments file. [Seen in: aa000-Main-Start.]  
It then opens the output sequential file and enters a loop that reads each record from the input file, writes it to the output file, and updates counters. [Seen in: aa010-Read-Recs.]  
Upon reaching end‑of‑file or encountering an error, the program closes both files, logs the record counts, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to parse command‑line parameters and sets logging system and file numbers. [Seen in: aa000-Main-Start.]  
It prepares a start‑up message, calls Call‑Sysout to log it, opens the input Pay‑File, checks FS‑Reply for existence, and opens the output payments‑File‑Seq while initializing record counters. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Input File Missing  
Trigger: FS‑Reply not zero after opening Pay‑File  
Key steps: log “No payments file to process”, close Pay‑File, goback  
I/O: Pay‑File  
Outcomes: program exits immediately with error status  
[Seen in: aa000-Main-Start.]

Path: Normal Read/Write Loop  
Trigger: successful read of Pay‑File  
Key steps: increment ws‑Rec‑Cnt‑In, write WS‑Pay‑Record to payments‑File‑Seq, increment ws‑Rec‑Cnt‑Out, loop until end‑of‑file  
I/O: Pay‑File, payments‑File‑Seq  
Outcomes: all records copied, counters reflect totals  
[Seen in: aa010-Read-Recs.]

Path: Read Error  
Trigger: FS‑Reply not zero during read  
Key steps: construct error message with SY003, call Call‑Sysout, go to aa020‑Finish‑Off  
I/O: Pay‑File  
Outcomes: program terminates with error status  
[Seen in: aa010-Read-Recs.]

Path: Write Error  
Trigger: FS‑Reply not zero after write  
Key steps: set SO‑Print to SY006, call Call‑Sysout, go to aa020‑Finish‑Off  
I/O: payments‑File‑Seq  
Outcomes: program terminates with error status  
[Seen in: aa010-Read-Recs.]

Path: Finish Off  
Trigger: end‑of‑file or error leads to aa020‑Finish‑Off  
Key steps: close payments‑File‑Seq and Pay‑File, log record counts, set Return‑Code to zero, goback  
I/O: payments‑File‑Seq, Pay‑File  
Outcomes: program exits successfully with counts logged  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
After processing, the program closes both input and output files, logs the total records processed, sets Return‑Code to zero, and exits via goback. [Seen in: aa020-Finish-Off.]  
The final Call‑Sysout invocation logs the closing status before termination. [Seen in: aa020-Finish-Off.]

---
## pl000
*[137/267]*

### Business/Functional Perspective
### Purchase Ledger Start Of Day

**Program Purpose**  
This program collects the current date (and optional time) at the start of a business day. It verifies that the entered date is valid, displays the date on the screen, and then hands control to the next step in the ledger processing. By ensuring a correct start‑of‑day date, the system maintains accurate accounting periods, supports audit trails, and reduces the risk of mis‑posted transactions.

**Screen Interactions**  
1. **Purchase Ledger Start Of Day screen**  
   *Header* – shows the client identifier, user name, program title, and the current time (if entered).  
   *Prompt* – “Enter todays date as dd/mm/yyyy – [          ]” (or mm/dd/yyyy / yyyy/mm/dd, depending on the system setting).  
   *Input* – user types today’s date into the field and submits.  
   *Result* – the entered date is displayed in the field; if it is invalid, an error message appears and the prompt re‑appears for correction.

**Messages and Errors**  
- **Invalid Date** – If the user enters a date that cannot be parsed or fails validation, the program shows the message “Invalid Date” and asks the user to re‑enter the date.  
- **Successful Entry** – No message is displayed; the error field is cleared, and the program proceeds to the next step.

**User Flow Summary**  
When the user runs the program, a screen appears with header information and a prompt for today’s date. The user types the date in the required format and submits it. The program checks that the date is correctly formatted and valid; if not, it informs the user with “Invalid Date” and repeats the prompt. Once a valid date is entered, the screen clears any error message, sets internal control values for the day, and the program exits, ready for the subsequent ledger processing steps.

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins in the main paragraph, initializing screen exception handling, moving the supplied to-day value into the internal date field, and displaying the header information. [Seen in: main.]  
It accepts the current date and time, displays them, and transfers control to the date-entry paragraph for user input and validation of the date format. [Seen in: main.]  
After successful date entry and validation, the program calls the maps04 routine, then proceeds to the chain-menu paragraph where it sets run-date and terminates by exiting the program. [Seen in: main, chain-menu.]

5.2 Initialization  
The main paragraph sets environment variables for screen exceptions and escape key detection, and moves the incoming to-day value into the internal date field. [Seen in: main.]  
It accepts the current date and time from the system, displays the header and user information, and initializes the working storage date and time fields. [Seen in: main.]

5.3 Core Processing  

Path: Date Entry  
Trigger: User accepts a date via the accept statement in the date-entry paragraph.  
Key steps: Display prompt based on date format, accept u-date, convert to standard UK format, set u-date.  
I/O: Accepts date input, displays prompts.  
Outcomes: u-date set; control returns to main after date-entry.  
[Seen in: date-entry.]

Path: Validation via maps04  
Trigger: After date entry, main calls maps04.  
Key steps: move zero to u-bin, call maps04, check u-bin; if zero display error and go to date-entry.  
I/O: Calls maps04 routine.  
Outcomes: u-bin set; if zero, error displayed and loop back; otherwise proceed to chain-menu.  
[Seen in: main.]

Path: Chain Menu  
Trigger: After successful maps04 call.  
Key steps: move u-bin to run-date, move u-date to to-day, set ws-term-code zero.  
I/O: none (internal).  
Outcomes: run-date set; program exits.  
[Seen in: chain-menu.]

Path: Main Exit  
Trigger: After chain-menu.  
Key steps: exit program.  
I/O: none.  
Outcomes: program terminates.  
[Seen in: main-exit.]

5.4 Termination  
The chain-menu paragraph sets run-date and terminates by executing the exit program statement in the main-exit paragraph. [Seen in: chain-menu, main-exit.]  
No additional cleanup is performed; the program simply exits. [Seen in: main-exit.]

---
## pl010
*[138/267]*

### Business/Functional Perspective
### Supplier Ledger Maintenance

**Program Purpose**  
The program allows users to create, modify, delete, display, and print supplier records that are stored in the purchase ledger. It validates entered data, ensures address and note integrity, and manages linked delivery records. By controlling supplier status and credit information, the program helps maintain accurate supplier accounting and supports audit compliance.

**Screen Interactions**  
1. **Main Menu** – Shows options 1‑5 for record creation, amendment, deletion, printing, and display, plus option 9 to return to the system menu.  
2. **Supplier Record Screen (display‑02)** – Prompts for supplier number, name, address, bank details, notes, telephone, fax, email, credit period, credit limit, and discount. Includes navigation keys: *Back (B)*, *Save (S)*, *Quit (Q)*.  
3. **Report Criteria Screen (display‑03)** – Allows entry of supplier number, status, credit period, invoice activity, average value, overdue days, and entry date, along with operators (L, G, E) for each numeric field. It also displays the current date and has options for *Back (B)*, *Quit (Q)*.

**Messages and Errors**  
- “Supplier Record Not Found” – when a supplied key does not exist.  
- “Supplier Record Already Exists” – when attempting to create a duplicate record.  
- “Can not Delete currently active account” – if the supplier has outstanding balances.  
- “Addr Err” – indicates an address that does not meet length or delimiter requirements.  
- “Invalid Date” – when a supplied date format cannot be parsed.  
- “Note error and hit return” – when a note fails validation.  
- “Hit return” – generic pause after an error or informational message.  
- “Purchase Ledger files have not been set up yet” – when the ledger files are missing.  
- Prompt to create missing files: “Do you wish to create them (Y/N) ?”.  
- Confirmation of file creation: “Creating Purchase & Delivery Files”.

**User Flow Summary**  
A user starts at the main menu and selects an action. For creation or amendment, the program opens the supplier screen, validates the address and any notes, then writes or updates the purchase record and, if notes exist, updates the linked delivery record. The user can navigate back, save, or quit at any time. Deletion requires confirmation that the supplier has no open balances; otherwise, a message prevents removal. The display option lists suppliers in a formatted report, optionally filtering by status, credit period, activity, average value, overdue days, or entry date. Report generation prints the list and, if chosen, sends it to the system printer.

**Program Linkages**  
- maps04  
- maps09  
- SYSTEM (for print spooling)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by executing the init01 section which sets up the environment, screen exceptions, and checks for the existence of the purchase ledger files, calling plcreate if necessary. [Seen in: init01.]  
The user is presented with a menu; selecting an option dispatches to one of the supplier maintenance or reporting sections (setup, amend, delete, report, display). [Seen in: menu-input.]  
After completing the chosen operation, control returns to the menu or exits to the system menu, terminating the program. [Seen in: menu-exit.]

5.2 Initialization  
The init01 section initializes screen exception flags, moves the program name and current date to the screen, and sets the print spool name. [Seen in: init01.]  
It checks whether the purchase ledger files exist; if not, it performs the plcreate section to create them. [Seen in: plcreate.]  
The file key number is initialized to 1 and the environment line count is set for screen handling. [Seen in: init01.]

5.3 Core Processing  

Path: Setup Suppliers  
Trigger: menu-reply = 1 (Setup Supplier records)  
Key steps: open purchase and delivery files, accept supplier number, validate address, collect supplier details, write purchase and delivery records, handle notes.  
I/O: purchase-file, delivery-file.  
Outcomes: new supplier record created; notes written if present.  
[Seen in: setup-suppliers, customer-accept, main-output.]

Path: Amend Supplier  
Trigger: menu-reply = 2 (Amend Supplier records)  
Key steps: open files, accept key, read existing record, display current data, edit details, rewrite purchase and delivery records, update or delete notes as needed.  
I/O: purchase-file, delivery-file.  
Outcomes: supplier record updated; notes updated or removed.  
[Seen in: amend-supplier, accept-key, main-output.]

Path: Delete Supplier  
Trigger: menu-reply = 3 (Delete Supplier records)  
Key steps: open files, accept key, display record, confirm deletion, rewrite status to dormant or delete record, delete associated delivery record if notes exist.  
I/O: purchase-file, delivery-file.  
Outcomes: supplier record marked dormant or removed; notes deleted.  
[Seen in: delete-supplier, accept-key, main-output.]

Path: Report Supplier  
Trigger: menu-reply = 4 (Print Supplier records)  
Key steps: open files, accept report criteria, iterate through purchase records applying filters, generate report lines, write to print file, invoke print spool if requested.  
I/O: purchase-file, delivery-file, print-file.  
Outcomes: report produced and spooled.  
[Seen in: report-supplier, report-selection, produce-report.]

Path: Display Supplier  
Trigger: menu-reply = 5 (Display Supplier records)  
Key steps: open files, accept key, read and display supplier details, allow user to view notes.  
I/O: purchase-file, delivery-file.  
Outcomes: supplier information displayed on screen.  
[Seen in: display-suppliers, accept-key, customer-display.]

Path: System Setup (plcreate)  
Trigger: program start when purchase ledger files are missing.  
Key steps: prompt user to create files, open output purchase and delivery files, close them, set purchase-ledger flag.  
I/O: purchase-file, delivery-file.  
Outcomes: files created and program ready for use.  
[Seen in: plcreate.]

5.4 Termination  
The main-end section closes the purchase and delivery files and, if a report was generated, calls the print spool. [Seen in: main-end.]  
The menu-exit section exits the program to the system menu. [Seen in: menu-exit.]

---
## pl015
*[139/267]*

### Business/Functional Perspective
### Purchase Ledger Enquiry  

**Program Purpose**  
This program allows users to view the current status of a supplier’s purchase ledger.  It displays the supplier’s account balance, year‑to‑date spend, unapplied invoices, credit limits, and a detailed list of open items (invoices, payments, and credit notes).  The information supports timely financial decision‑making, audit compliance, and risk management by giving users an up‑to‑date picture of supplier exposures and unpaid balances.  

**Screen Interactions**  
1. **Title & Prompt** – The screen starts with the heading “Purchase Ledger Enquiry” followed by a prompt field “Supplier:”.  
2. **Supplier Details** – Once a supplier code is entered, the screen shows:  
   * Supplier name and address lines.  
   * Account number, current balance, year‑to‑date spend, unapplied amount, credit limit, and unposted amount.  
3. **Open Items List** – A scrollable table lists each invoice or credit note with columns for:  
   * Number, date, description, invoiced amount, paid amount, and remaining balance.  
4. **Totals** – At the bottom of the list, totals are shown for outstanding balances and for ageing buckets (Current, 30, 60, 90+ days).  
5. **Command Prompt** – The screen offers options:  
   * `P` – Print the ledger report.  
   * `N` – Start a new enquiry for another supplier.  
   * `T` – Toggle the hold flag on a selected open item.  
   * `M` – View more items if the list is long.  
   * `E` – Exit the program.  
   The prompt also indicates whether the list is truncated and may show a “More” option when additional items exist.  

**Messages and Errors**  
- **File Access Issues** – If a required data file cannot be opened or written to, the user sees a clear message such as “Cannot open file” or “Error on writing work file.”  
- **Record Not Found** – When a supplier or open‑item record is missing, the user is informed that the record was not found.  
- **Data Integrity Problems** – Errors during record rewrite or when an unsupported transaction type is toggled trigger messages like “Only invoices can be toggled” or “Error on rewrite.”  
- **Operation Status** – Informational notices such as “Work file created” or “No work file created. No data” are displayed to indicate the outcome of background processing.  

**User Flow Summary**  
1. The user starts the program and sees the “Purchase Ledger Enquiry” screen.  
2. The user types a supplier account number (or presses ESC to exit).  
3. The program looks up the supplier and displays all relevant account information and a list of open items.  
4. The user reviews balances and aging totals.  
5. The user can press:  
   * `P` to generate a printable ledger report;  
   * `N` to perform another enquiry;  
   * `T` to toggle the hold status of a selected open item (prompted for the invoice number);  
   * `M` to scroll further through the list if it is long;  
   * `E` to exit the program.  
6. After each action, the screen updates to reflect any changes (e.g., updated hold flag, new totals, or a new supplier).  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- maps04  
- SYSTEM   *(used for printing the report)*

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry triggers init01 section which sets up environment and screen parameters. [Seen in: init01 section.]  
After initialization, set-up-work-file builds a temporary work file of unapplied invoices and credit notes, then files are opened for purchase, open-item, and enquiry processing. [Seen in: set-up-work-file section.]  
The enquiry section drives the main menu loop, displaying supplier information, reading open-item records, and handling user actions such as print, next enquiry, toggle flag, or exit, before returning to menu-exit and exiting the program. [Seen in: enquiry section.]

5.2 Initialization  
init01 performs environment variable acceptance, screen line calculations, date conversion, and sets screen exception flags. [Seen in: init01 section.]  
It verifies the existence of the ITM5 file, displays an error if missing, and then calls set-up-work-file to populate the work file. [Seen in: init01 section.]  
File handles for work-file, purchase-file, and open-item-file-5 are opened, and the enquiry routine is invoked before closing files and re‑opening work-file for cleanup. [Seen in: init01 section.]

5.3 Core Processing  
Path: set-up-work-file  
Trigger: called from init01 section during program start.  
Key steps: open work-file for output, open invoice-file, read invoice headers, filter by type, calculate amounts, write to work-file, handle errors, close files, set work-file-data flag.  
I/O: work-file, invoice-file.  
Outcomes: work-file populated with unapplied invoices/credit notes; work-file-data set to "Y" if data exists; error messages displayed on failure. [Seen in: set-up-work-file section.]

Path: enquiry  
Trigger: user enters supplier code or presses ESC.  
Key steps: display headers, accept supplier, start purchase and open-item files, read purchase records, display supplier details, read open-item records, calculate balances and ageing, display totals, prompt for actions.  
I/O: purchase-file, open-item-file-5, work-file (via get-unposted), print-file (when printing).  
Outcomes: screen shows supplier ledger, totals updated, user action determines next step (print, next enquiry, toggle, exit). [Seen in: enquiry section.]

Path: get-unposted  
Trigger: called within enquiry after purchase data is displayed.  
Key steps: read work-file sequentially, sum amounts for matching supplier, set l4-unposted.  
I/O: work-file.  
Outcomes: l4-unposted updated with total unapplied amount for supplier. [Seen in: get-unposted section.]

Path: set-query-flag  
Trigger: user selects 'T' in enquiry prompt.  
Key steps: prompt for invoice number, close and reopen open-item-file-5, toggle hold flag on matching record, rewrite record, handle errors.  
I/O: open-item-file-5.  
Outcomes: hold flag toggled for specified invoice; user notified of success or error. [Seen in: set-query-flag section.]

Path: print-screen  
Trigger: user selects 'P' in enquiry prompt.  
Key steps: open print-file, write header lines, loop through l7-group to write item lines, write totals, close print-file, invoke system print command.  
I/O: print-file.  
Outcomes: printed ledger page, screen remains unchanged. [Seen in: print-screen section.]

5.4 Termination  
menu-exit performs GOBACK to exit the program after closing all files. [Seen in: menu-exit.]  
The program ensures work-file, purchase-file, and open-item-file-5 are closed before exiting. [Seen in: menu-exit.]

---
## pl020
*[140/267]*

### Business/Functional Perspective
### Purchase Order Data Entry  

**Program Purpose**  
PL020 allows users to create and maintain purchase orders for suppliers.  It records the order date, supplier, reference numbers and line‑item details, applies VAT and any additional charges, and writes the completed invoice record.  The program ensures that data entered is valid, that invoices are uniquely numbered, and that credit notes reference existing invoices, thereby supporting accurate accounting and reducing risk of duplicate or incorrect entries.  

**Screen Interactions**  

1. **Order Data Entry Screen**  
   *Title:* “Order Data Entry” displayed at the top.  
   *Inputs:* Date, supplier code (or new‑supplier key), order reference, invoice reference, and type selection (1 = Receipt, 2 = Account, 3 = Credit Note).  
   *Outputs:* Supplier name and address are shown after a valid supplier is entered.  
   *Options:* F1 key opens the new‑supplier entry form; ESC exits to the previous menu.  

2. **Level 1 Item Entry Screen**  
   *Title:* “Level 1” with numbered line prompts.  
   *Inputs per line:* Item description, net amount, VAT code (S, R, Z), VAT amount, gross amount, and optional prompt‑payment discount or additional charges.  
   *Outputs:* Running totals of net, VAT, and gross amounts are updated after each line.  
   *Options:* User can add as many lines as needed; ESC aborts the current order.  

3. **Totals Confirmation Screen**  
   *Title:* “Itemised Totals” and “Sub‑Totals”.  
   *Inputs:* Prompt‑payment discount, shipping & handling, and any extra adjustments.  
   *Outputs:* Final totals for net, VAT, and gross amounts, along with the number of days for payment terms.  
   *Options:* Press Y to confirm and store the order, N to cancel, or re‑enter any field.  

4. **Credit Note Screen** (accessed when type = 3)  
   *Title:* “Folio # to Credit”.  
   *Inputs:* Folio number of the invoice to be credited.  
   *Outputs:* Validation messages if the folio does not exist, is already paid, or belongs to a different supplier.  
   *Options:* ESC aborts; valid entries proceed to the normal item entry process.  

**Messages and Errors**  
- **Supplier Errors:** If a supplier code is not found, the program displays “No such Supplier” and prompts for a new entry.  
- **File/Record Errors:** Problems writing the invoice record (e.g., duplicate folio number) trigger a message indicating a write failure and allow the user to retry or cancel.  
- **Credit Note Validation:** The program notifies the user if the requested credit folio is missing, already paid, or has a query flag set, and prevents the credit unless the issue is resolved.  
- **General Prompt:** After any error, the program pauses and waits for the user to press Return before continuing.  

**User Flow Summary**  
A user starts PL020 to create a new purchase order.  The order data screen requests the date, supplier code, order reference, invoice reference, and the type of transaction.  If the supplier is new, the user can press F1 to enter supplier details.  Once a valid supplier is selected, the program displays the item entry screen where the user enters one or more line items, specifying each item’s description, net amount, and VAT code; the program calculates VAT and gross amounts automatically.  After entering all items, the user is taken to the totals screen to review the overall net, VAT, and gross amounts and to enter any additional discounts or shipping costs.  The user confirms the order, and the program writes the purchase order to the invoice file, handling any duplicate folio numbers by incrementing the next available number.  Finally, the user can choose to enter another order or exit the program.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- pl070  
- pl025  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by performing the init01 section, which sets environment variables, converts the current date, and calls program-start to open files and initialize state. [Seen in: init01]  
Control then proceeds to the main paragraph, which displays the purchase order header, gathers supplier and order details, and routes to type-specific processing. [Seen in: main]  
Depending on the selected type, the program may invoke the CR-Note section for credit notes, the new-supplier routine for supplier creation, or the standard invoice entry path that collects line items via inv-level-1 and Get-Data-1. [Seen in: type-input, CR-Note, inv-level-1]  
After line items are entered, the End-Totals section confirms storage, writes the invoice record, and optionally deletes any used deleted-invoice numbers. [Seen in: End-Totals]  
Finally, the program returns to menu-exit, closing all files and performing a GOBACK to terminate. [Seen in: menu-exit]

5.2 Initialization  
init01 performs environment setup: accepts line count, sets screen exception flags, converts the current date, and initializes the File-Key-No. [Seen in: init01]  
program-start is called to verify required files, open the Purch, Analysis, and Invoice files, and create the Invoice file if missing. [Seen in: Program-Start]  
The main paragraph then initializes the invoice header and body, zeroes totals, and performs inv-level-1 to display the line item entry screen. [Seen in: main]

5.3 Core Processing  
Path: Program-Start (System Setup)  
Trigger: Called from init01.  
Key steps: verify files, open files, create invoice file if missing.  
I/O: Analysis file, Invoice file, System file.  
Outcomes: Files opened, parameters set.  
[Seen in: Program-Start]  

Path: Invoice-Entry (Main)  
Trigger: main paragraph after init.  
Key steps: display header, accept supplier, order, type, route to type-input.  
I/O: none.  
Outcomes: sets up invoice header.  
[Seen in: main]  

Path: Type-Processing (type-input)  
Trigger: after type input.  
Key steps: if type=3, call CR-Note; else proceed to inv-level-1.  
I/O: none.  
Outcomes: sets type, may call CR-Note.  
[Seen in: type-input]  

Path: Line-Item Entry (inv-level-1 & Get-Data-1)  
Trigger: after type input for types 1 or 2.  
Key steps: display line item screen, loop through lines, get code, net, vat, etc., accumulate totals.  
I/O: none.  
Outcomes: populates line items, totals.  
[Seen in: inv-level-1, Get-Data-1]  

Path: End-Totals (End-Totals section)  
Trigger: after line items entered and user confirms.  
Key steps: display totals, confirm storage, write invoice header, write line items, delete del-inv-nos.  
I/O: PInvoice file, DelInvNos file.  
Outcomes: invoice record stored, del-inv-nos deleted.  
[Seen in: End-Totals]  

Path: CR-Note (CR-Note section)  
Trigger: when type=3 and CR-Note called.  
Key steps: accept folio to credit, validate against OTM5, check status, display errors, loop.  
I/O: OTM5 file.  
Outcomes: credit note processed.  
[Seen in: CR-Note]  

5.4 Termination  
The menu-exit paragraph closes all open files and performs a GOBACK to terminate the program. [Seen in: menu-exit]  
The program may also exit from various points via Main-Exit sections that perform cleanup before returning to the caller. [Seen in: Main-Exit]

---
## pl025
*[141/267]*

### Business/Functional Perspective
### Supplier Ledger Creation  

#### Program Purpose  
This program creates or updates a supplier’s ledger record in the purchase‑order system. It validates the supplier number, checks for duplicate records, gathers bank and contact details, and records any supplier notes. The process ensures that each supplier has a unique ledger entry, maintains accurate credit limits, and logs supplier information for future invoices and payments.  

#### Screen Interactions  
1. **Supplier Entry Screen**  
   * **Title / Prompts** – “Supplier Nos : [ … ]”, “Supplier Name: [ … ]”, “Addr: [ … ]”, “Suppliers Bank Details”, “Telephone : [ … ]”, “Fax : [ … ]”, “Email Sales : [ … ]”, “Credit Period: [ … ]”, “Credit limit : [ … ]”, “Discount : [ … ]”, “Unapplied Bal: { … }”, “Current Bal  : { … }”, “Last invoice : { … }”, “Last payment : { … }”.  
   * **Inputs** – Supplier number, name, address lines, bank sort code, bank account number, notes, telephone, extension, fax, email, credit period, credit limit, discount.  
   * **Options** – Press **B** to return to the supplier number prompt, **S** to save the record, or **Q** to quit.  
   * **Display Areas** – Current balance, unapplied balance, last invoice, last payment.  

#### Messages and Errors  
* **Duplicate Supplier** – If the supplier number already exists, the screen shows “Supplier Record Already Exists”.  
* **Address Validation** – If the entered address does not meet formatting rules (too many or too few delimiters, or exceeds 30 characters), an “Addr Err” message is displayed.  
* **Save Confirmation** – After successful entry or update, the screen clears and returns to the supplier number prompt.  

#### User Flow Summary  
1. The user is prompted to enter a supplier number.  
2. The system checks whether the number is already in use.  
   * If it exists, the user is informed and prompted to re‑enter or quit.  
   * If it does not exist, the screen displays a blank form for supplier details.  
3. The user fills in the supplier name, address, bank information, contact details, and any notes.  
4. The user may press **B** to edit the supplier number again, **S** to save the new ledger record, or **Q** to exit without saving.  
5. If **S** is chosen, the program validates the address and, if valid, writes the new ledger record. It also records any notes as a delivery record.  
6. After saving, the program returns to the supplier number prompt for the next entry.  

#### Program Linkages  
- `maps09`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** section, setting screen exception flags, determining terminal size, and displaying the program name before opening the purchase and delivery files. It then calls **setup-suppliers** to initialize screen fields and enters the main supplier entry loop. After processing suppliers, the program closes the files and exits. [Seen in: init01, setup-suppliers, menu-end.]

5.2 Initialization  
The **init01** section sets environment variables for screen exceptions, accepts the number of lines, and calculates the usable line count. It displays the program name, performs **Purch-Open** and **Delivery-Open** calls, and clears a screen line before invoking **setup-suppliers**. [Seen in: init01, Purch-Open, Delivery-Open, setup-suppliers.]

5.3 Core Processing  

Path: Supplier Entry  
Trigger: User enters a customer number in **supplier-accept**.  
Key steps: Accept customer number, convert to upper case, display it, call **maps09** to validate the key, read the purchase file with **Purch-Read-Indexed**, and either proceed to supplier details or display an error if the record exists.  
I/O: purchase file (read), maps09 routine.  
Outcomes: Sets **WS-Purch-Key**, **maps09-reply**, and **fs-reply**; may loop back to entry or advance to details.  
[Seen in: supplier-accept, maps09, Purch-Read-Indexed.]

Path: Supplier Details  
Trigger: Successful read of a non‑existent purchase record (fs-reply 21 or 23).  
Key steps: Initialize purchase and delivery records, set create date, status, key, and credit limit, then call **supplier-data** to gather address and notes, set escape code to “S”, and invoke **test-escape**.  
I/O: purchase file (write), delivery file (write if notes present).  
Outcomes: Populates **WS-Purch-Record**, **WS-Delivery-Record**, and may write a delivery record if notes are supplied.  
[Seen in: supplier-details, supplier-data, test-escape.]

Path: Escape Handling  
Trigger: User enters an escape code at the prompt (B, S, or Q).  
Key steps: Accept escape code, convert to upper case, loop until a valid code is entered, then return to **main-output** to decide next action.  
I/O: screen input at 2076.  
Outcomes: Sets **escape-code** to a valid value, influencing whether to re‑edit details, save and exit, or quit.  
[Seen in: test-escape, get-escape.]

Path: Address Validation  
Trigger: During **supplier-data** after the user enters address fields.  
Key steps: Move the address to **test-address**, count delimiters and characters before the first delimiter, and set **truth** accordingly; if invalid, display an error and loop back to re‑enter address.  
I/O: none (screen only).  
Outcomes: Determines whether the address is accepted or rejected, affecting continuation of data entry.  
[Seen in: validate-address, supplier-data.]

Path: Delivery Write  
Trigger: After a successful purchase record write when **Purch-Notes-Tag** is non‑zero.  
Key steps: Set delivery key type to “D”, populate delivery key, name, and address fields, and perform **Delivery-Write**.  
I/O: delivery file (write).  
Outcomes: Creates a delivery record linked to the purchase record.  
[Seen in: main-output, Delivery-Write.]

5.4 Termination  
The program exits the main loop via **main-exit**, closing the purchase and delivery files and returning control to the caller with a GOBACK.  
[Seen in: main-exit, menu-end.]

---
## pl030
*[142/267]*

### Business/Functional Perspective
### Purchase Order Maintenance  

**Program Purpose**  
The program lets users amend purchase orders and related documents such as receipts, accounts, and credit notes. It validates dates, supplier information, and invoice numbers, and it calculates line‑item totals, VAT, discounts, shipping and handling, and carriage charges. By ensuring all data is accurate before the order is stored, the program reduces accounting errors, maintains audit‑ready records, and supports compliance with invoicing policies.  

**Screen Interactions**  
1. **Purchase Order Amend Screen** – Shows the program name, current date, and prompts for:  
   * Date of the order  
   * Supplier code (displaying name and address if found)  
   * Order number  
   * Reference number  
   * Type: 1 = Receipt, 2 = Account, 3 = Credit Note  

2. **Invoice Entry Screen** – Asks for the invoice number and retrieves the existing record. If the invoice is missing or already applied, a message is shown.  

3. **Date Input Screen** – Allows the user to enter or confirm the invoice date.  

4. **Supplier Information Screen** – Displays the supplier’s name and up to five address lines; the user can confirm or correct the supplier code.  

5. **Order and Reference Screen** – Prompts for the order number and reference number.  

6. **Type Selection Screen** – Lets the user choose the type of document (Receipt, Account, or Credit Note). Choosing “Credit Note” moves to the credit‑note flow.  

7. **Credit Note Input Screen** – Prompts for the invoice to credit. The program checks that the invoice exists, is of the correct type (invoice, not a receipt or credit note), is not already paid or closed, and that the supplier matches.  

8. **Line Item Entry Screen** – For each line of the purchase order the user enters:  
   * PA code (accounting code)  
   * Net amount (pounds and pence)  
   * VAT code (Standard, Reduced, Zero) – automatically converted to a rate  
   * VAT amount and gross total  
   * Number of days, if applicable  
   Navigation allows paging through up to 40 lines.  

9. **Totals and Confirmation Screen** – Shows net, VAT, gross, and day totals. The user can add prompt‑payment discount, shipping/handling, and carriage amounts, each with associated VAT.  

10. **Final Confirmation Prompt** – After all totals are displayed, the screen asks “Order ok to store? (Y/N)”. A “Y” stores the amended order; a “N” aborts the changes and returns to the amend loop.  

**Messages and Errors**  
- **Missing or invalid data** – If an invoice, supplier, or PA code cannot be found, a clear message is shown (e.g., “Folio Not Found”, “Supplier Does Not Exist”).  
- **Duplicate or applied records** – If the invoice has already been applied to the purchase ledger or is paid, the user is notified that the record cannot be edited.  
- **Incorrect document type** – Credit‑note entries are only accepted for invoices; attempting to credit a receipt or a credit note triggers a message.  
- **Supplier mismatch** – The program requires the supplier on the credit note to match the supplier of the original invoice.  
- **File or write errors** – General “write failed” or “record not written” messages are displayed if a file operation fails.  
- **Validation prompts** – Messages such as “Hit Return to Continue” or “Note Details & Hit Return to continue” allow the user to acknowledge information and proceed.  

**User Flow Summary**  
1. The user starts the program and is presented with the purchase‑order amend screen.  
2. After entering the date, supplier, order, reference, and type, the program reads the existing invoice.  
3. The user confirms or edits invoice details line by line, entering PA codes, amounts, VAT codes, and any additional charges.  
4. Running totals are updated after each line; the user can review and adjust discounts, shipping, and carriage.  
5. Once all lines are entered, the totals screen is displayed. The user confirms the order is ready to be stored.  
6. On confirmation, the program writes the amended order to the data store, closes the current invoice, and returns to the amend screen to allow the user to edit another invoice or exit.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- sl070

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by performing initialization, opening required files, and displaying the main screen. [Seen in: Program-Start.]  
The user enters or selects a purchase order, after which the program reads and displays the order details, then enters a loop to amend invoice lines. [Seen in: invoice-enter, date-input, supplier-input, order-input, ref-input, type-input, main.]  
After amendments, the program calculates totals, writes updated invoice records, and optionally processes credit notes before exiting. [Seen in: End-Totals, Total-Screen, write-details, cr-note.]

5.2 Initialization  
The init01 section reads environment line count, sets screen exception flags, converts the current date, and initializes the file key. [Seen in: init01.]  
Program-Start opens purchase, analysis, and invoice files, checks for required files, and displays error messages if missing. [Seen in: Program-Start.]

5.3 Core Processing  
Path: Invoice Entry Path  
Trigger: User enters an invoice number in the invoice-enter paragraph.  
Key steps: Read invoice header, validate existence, display supplier info, read invoice lines, prompt for date, supplier, order, reference, type, then loop to main.  
I/O: PInvoice-Read-Indexed, Purch-Read-Indexed, read-details.  
Outcomes: Sets ih-invoice, ih-date, supplier, order, ref, type; prepares for amendment loop.  
[Seen in: invoice-enter, date-input, supplier-input, order-input, ref-input, type-input, main.]

Path: Main Amendment Loop  
Trigger: After invoice details are loaded, main loop displays line items and allows editing via get-data-1.  
Key steps: Display outline, get PA code, net, VAT code, VAT rate, VAT amount, update line items, recalculate totals.  
I/O: PInvoice-Read-Next, PInvoice-Rewrite, PInvoice-Write.  
Outcomes: Updated invoice-line array, running totals updated, possible screen navigation.  
[Seen in: main, inv-level-1, get-data-1, accept-money6c, accept-money7c, running-totals.]

Path: End Totals and Write Details  
Trigger: User confirms to store changes after amendment loop.  
Key steps: Display totals screen, prompt for confirmation, rewrite header, write each line, handle errors.  
I/O: PInvoice-Rewrite, write-details (which calls PInvoice-Write).  
Outcomes: Invoice record updated, status set to "P", exit to menu.  
[Seen in: End-Totals, Total-Screen, write-details, PInvoice-Rewrite.]

Path: Credit Note Processing  
Trigger: User selects type 3 (credit note) in type-input.  
Key steps: Display credit note screen, read invoice to credit, validate against OTM5, check status, then allow further processing.  
I/O: OTM5-Read-Indexed, display messages.  
Outcomes: Sets ws-named, escape-code, prepares for credit note processing.  
[Seen in: type-input, cr-note, main-display, main-input.]

Path: Termination  
Trigger: User exits via escape or after processing.  
Key steps: Close files, goback.  
I/O: Purch-Close, PInvoice-Close, Analysis-Close.  
Outcomes: Program ends, resources released.  
[Seen in: menu-exit.]

5.4 Termination  
Upon exit, the program closes all open files and returns control to the caller. [Seen in: menu-exit.]  
Any pending status flags are cleared before GOBACK. [Seen in: menu-exit.]

---
## pl040
*[143/267]*

### Business/Functional Perspective
### Invoice Deletion  

**Program Purpose**  
The Invoice Deletion program allows authorized users to permanently remove an invoice record from the system. It verifies that the invoice exists and has not already been processed, displays the invoice details for confirmation, and then deletes the record. Deleted invoices are logged in a separate deletion history file to maintain an audit trail. This ensures the accuracy of financial data, supports compliance with record‑keeping requirements, and reduces the risk of duplicated or erroneous invoices.  

**Screen Interactions**  
1. **Invoice Entry Screen** –  
   * Displays the program name, the title “Order Data Deletion,” and the current date.  
   * Prompts the user to enter the folio (invoice) number.  
   * Once entered, the screen shows the invoice’s date, supplier name and address, order number, reference, and type.  
   * Presents the question “Invoice to be deleted (Y/N) – [ ]” for confirmation.  
   * Allows the user to press **Q** to exit the program at any time.  

2. **Continue‑Deletion Prompt** –  
   * After a deletion, the screen displays “Delete further invoices? (Y/N)  [Y]”.  
   * The user may choose **Y** to repeat the process or **N** to terminate the program.  

**Messages and Errors**  
- If the entered folio does not exist, the message “Folio Not Found !!” is shown.  
- If the invoice has already been processed by the purchase ledger, the message “PO Details Already Passed To Purchase Ledger !” is shown.  
- When the user chooses not to delete the displayed invoice or opts not to delete further invoices, the program exits silently.  

**User Flow Summary**  
When the user launches the program, a screen appears asking for an invoice (folio) number. The user types the number and presses Enter. If the invoice is not found, an error message appears and the user is prompted to re‑enter a number. If the invoice is found but has already been processed, a different error message is shown. For a valid, unprocessed invoice, the screen displays all relevant details and asks the user to confirm deletion with “Y/N.” Choosing **Y** causes the program to delete the invoice record, record the deletion in a history file, and then ask whether another invoice should be deleted. The user can continue this cycle or exit. When the user quits, the program closes all files and terminates.  

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by setting screen exceptions, performing program‑start to display the header and current date, and opening the invoice, purchase, and delete‑invoice files. [Seen in: init01 section.]  
The user is prompted to enter an invoice number; the program reads the invoice record, verifies its status, and if confirmed, deletes the invoice and its line items. [Seen in: invoice-enter paragraph.]  
After deletion, the program writes a record to the delete‑invoice numbers file, optionally asks for another deletion, and finally closes all files and exits. [Seen in: delete-details section, main‑exit section.]

5.2 Initialization  
The init01 section sets screen exception handling, performs program‑start to display header and current date, and opens the invoice, purchase, and delete‑invoice files. [Seen in: init01 section.]  
It initializes escape‑code to spaces and calls invoice‑details to display the header and prompt for the first invoice. [Seen in: init01 section, invoice‑details section.]

5.3 Core Processing  
Path: Invoice Entry  
Trigger: User enters a non‑zero invoice number at the ih‑invoice prompt.  
Key steps: Read invoice record indexed; if not found display PL187 and loop; if status 'z' display PL188 and loop; convert date; display supplier and invoice details; prompt for deletion confirmation; if Y, delete invoice and call delete‑details; write delete‑inv‑nos record.  
I/O: PInvoice file (read/delete), Purch file (read), DelInvNos file (write).  
Outcomes: invoice deleted, delete‑inv‑nos record written, control returns to main‑exit or loops for another invoice.  
[Seen in: invoice-enter paragraph, delete-details section, DelInvNos-Write.]

Path: Delete Details  
Trigger: After confirming deletion of an invoice, delete‑details is performed to delete all line items.  
Key steps: Loop over ih‑lines, increment j, set invoice‑nos and item‑nos, perform PInvoice‑Delete.  
I/O: PInvoice file (delete).  
Outcomes: all line items for the invoice removed.  
[Seen in: delete-details section.]

Path: Date Conversion (zz060‑Convert‑Date)  
Trigger: Called after reading an invoice to convert binary date to display format.  
Key steps: Call maps04, check date validity, set ws‑date, adjust for UK/USA/International formats.  
I/O: none (uses ws‑date).  
Outcomes: ws‑date updated for display.  
[Seen in: zz060‑Convert‑Date section.]

Path: Data Input Prompt  
Trigger: After invoice‑details, user is asked “Delete further invoices? (Y/N)”.  
Key steps: Display prompt, accept ws‑reply; if Y, go to done‑open (re‑open files); else proceed to main‑exit.  
I/O: screen only.  
Outcomes: determines whether to loop for another invoice.  
[Seen in: data-input paragraph.]

Path: Main Exit  
Trigger: Escape‑code set to “Q” or user chooses not to delete further invoices.  
Key steps: Perform Purch‑Close, DelInvNos‑Close, PInvoice‑Close, exit program.  
I/O: close files.  
Outcomes: program terminates cleanly.  
[Seen in: main‑exit section.]

5.4 Termination  
The main‑exit section closes the purchase, delete‑invoice, and invoice files and exits the program. [Seen in: main‑exit section.]  
No status flag is set beyond the file close operations; the program terminates with a STOP RUN. [Seen in: main‑exit section.]

---
## pl050
*[144/267]*

### Business/Functional Perspective
### Purchase Order Proof Report  

**Program Purpose**  
The program generates a printable report of all unapplied purchase transactions—receipts, invoices and credit notes—for a specified period. It consolidates supplier details, transaction amounts, and VAT reconciliation, allowing the user to verify that all entries have been properly recorded and to identify any missing or mismatched postings. The report supports compliance and audit processes by providing a clear, auditable snapshot of purchase activity without modifying any data files.  

**Screen Interactions**  
1. **Header Screen** – Displays the program name, “Purchase Orders Proof Report” title, and the current date.  
2. **Error Prompt** – If no transactions exist or required files are missing, shows “No Transactions to proof! …Press return for menu.” and waits for a return key (unless the caller is “xl150”).  

**Messages and Errors**  
- If transaction files cannot be located, the user is notified with a “No Transactions to proof” message and prompted to return to the menu.  
- If purchase records are missing during processing, the report includes a warning line: “Warning: Record/s missing in Purchase File”.  

**User Flow Summary**  
The user initiates the report (usually via a menu or batch call). The program checks that the purchase and invoice files are present; if not, it alerts the user and exits. It then reads each unapplied transaction record, gathering supplier information, dates, and amounts, and writes detailed lines to a print spool file. Totals for each transaction type and overall VAT reconciliation totals are computed and printed. When finished, the report is sent to the printer, and control returns to the caller.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by initializing spool and totals, converting the current date, and displaying the menu header. [Seen in: init01.]  
It then verifies the presence of the purchase file, opens the purchase, invoice, and print files, and enters a loop that reads each invoice record for processing. [Seen in: Menu-Return.]  
After all records are processed, it writes totals and VAT reconciliation, closes files, and optionally prints the report before exiting. [Seen in: main-end.]

5.2 Initialization  
init01 sets the spool name, clears totals, moves program name to header, converts the current date, and initializes the file key. [Seen in: init01.]  
Menu-Return displays the program title, date, checks for the purchase file existence, opens the purchase and invoice input files and the print output file, and writes the initial headings. [Seen in: Menu-Return.]

5.3 Core Processing  
Path: Invoice Processing Loop  
Trigger: loop (PInvoice-Read-Next)  
Key steps: read next invoice record, skip if reply non‑zero, copy record to header, skip if test flag, skip if already applied, read purchase record by key, handle missing supplier, convert dates, adjust amounts for credit notes or invoices, compute totals, write line‑5, perform analysis‑print and extra‑analysis, repeat.  
I/O: PInvoice file, Purchase file, print file.  
Outcomes: updated totals, line count, print‑out flag, potential error flag.  
[Seen in: loop.]  

Path: Analysis‑Print Path  
Trigger: analysis‑print section called within loop.  
Key steps: read next invoice line, check comment flag, adjust amounts for credit notes, accumulate VAT totals, write analysis line, manage page breaks.  
I/O: PInvoice file, print file.  
Outcomes: analysis lines printed, VAT totals updated.  
[Seen in: analysis-print.]  

Path: Total Report Path  
Trigger: main‑end after loop.  
Key steps: close input files, write final headings, write totals for each group via total‑report, write VAT reconciliation via compute‑vatcodes, close print file, optionally call SYSTEM to print.  
I/O: print file.  
Outcomes: totals printed, report printed.  
[Seen in: main-end.]  

Path: Date Conversion Path  
Trigger: zz060‑Convert‑Date or zz070‑Convert‑Date called during processing.  
Key steps: convert binary date to UK/USA/Intl format, set ws‑date.  
I/O: none.  
Outcomes: ws‑date set for display.  
[Seen in: zz060-Convert-Date.]  

Path: Map Section Path  
Trigger: maps04 called during init.  
Key steps: call maps04 to set date format and other mapping data.  
I/O: none.  
Outcomes: date format variables set.  
[Seen in: maps04.]

5.4 Termination  
main‑end performs file closes, writes final report sections, and if any data was printed, invokes the SYSTEM call to print the spool file. [Seen in: main-end.]  
The program then exits via menu‑call, returning control to the caller. [Seen in: menu-call.]

---
## pl055
*[145/267]*

### Business/Functional Perspective
### Invoice Post Extraction  

**Program Purpose**  
The program reads all posted invoices, calculates the amounts that must be moved to the open‑item register, and updates the value and analysis tables accordingly.  It also creates any missing “emergency” analysis records so that the accounting records remain complete and auditable.  By automating these postings, the system ensures accurate month‑end totals, prevents duplicate entries, and supports compliance reporting.  

**Screen Interactions**  
1. **Program title screen** – The program name “PL055 (3.02.08)” is displayed at line 01 and the text “Invoice Post Extract” at line 13.  
2. **Date display** – The current date (converted to the configured format) appears at line 17.  
3. **Error or status messages** – If a required file is missing or a write fails, a message such as “P.A. File Does Not Exist” or “Error writing to Open Item 4 File” is shown, followed by a prompt to press **Return** to continue.  
4. **Post‑processing notice** – If any emergency analysis records were created, the program displays a message informing the user that these records exist and that they should be updated. The user is then prompted to press **Return** before the program exits.  
5. No other user‑input screens are presented.  

**Messages and Errors**  
- **Missing P.A. file** – The program stops if the analysis file cannot be located after an attempt to create it.  
- **Write error** – If writing an open‑item record fails, the program displays an error message and halts.  
- **Emergency analysis creation** – When an analysis record with the description “Emergency Name – Missing” is added, the program informs the user that such records exist and advises them to update the entries.  
- **Generic prompts** – After any of the above messages the program waits for the user to press **Return** before continuing or exiting.  

**User Flow Summary**  
1. The user launches the program (e.g., via a CICS link or a command line).  
2. The screen shows the program title, “Invoice Post Extract,” and the current date.  
3. The program verifies that the P.A. (analysis) file exists; if not, it attempts to create it.  Failure to locate the file results in an error message and exit.  
4. The program opens the invoice, value, and analysis files and begins processing each invoice record.  
5. For every invoice it:  
   - Updates the value totals (current, previous, year‑to‑date) and writes or rewrites the record.  
   - Generates an open‑item register entry reflecting the invoice amount, carriage, VAT, and any deductions.  
   - If the invoice is a header, it updates analysis totals and records.  
6. After all records are processed, the program writes the special totals (VAT, VAT reverse, carriage, discount) to the value file.  
7. If any emergency analysis records were created during processing, the program displays a message and prompts the user to press **Return**.  
8. The program closes all files and exits, returning control to the calling context.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- sl070

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by initializing environment, checking for required files, and opening invoice, value, analysis, and temporary files. [Seen in: mainline section.]  
It then enters a loop reading each invoice record, distinguishing test records from header records, and processes each accordingly. [Seen in: read-loop.]  
After all records are processed, it writes any accumulated totals, closes all files, displays messages for created analysis records, and exits. [Seen in: close-files.]

5.2 Initialization  
The program accepts the terminal line count, sets screen exception flags, and ensures a minimum line count for display. [Seen in: mainline section.]  
It performs file existence checks, calls sl070 if necessary, opens the required files, and converts the current date to the appropriate format. [Seen in: mainline section.]

5.3 Core Processing  

Path: File Existence Error  
Trigger: FS-Cobol-Files-Used and file not found.  
Key steps: call CBL_CHECK_FILE_EXIST, call sl070, recheck, display PL203 and PL003, set WS-Term-Code, goback.  
I/O: File-15.  
Outcomes: program terminates with error.  
[Seen in: mainline section.]

Path: Value Record Processing for Non‑Test Invoices  
Trigger: ih-test = zero and il-analyised false.  
Key steps: set va-system and va-group, read value record, create if missing, update totals, write or rewrite value record, rewrite invoice.  
I/O: value-file, invoice-file.  
Outcomes: value record updated, invoice updated.  
[Seen in: read-loop.]

Path: Header Analysis Processing  
Trigger: ih-test = zero (header record).  
Key steps: if already analysed and applied skip; otherwise perform extract to write open-item record, compute vat/carriage/discount totals, rewrite invoice.  
I/O: open-item-file-4, invoice-file.  
Outcomes: open-item record written, totals updated.  
[Seen in: header-analysis.]

Path: Close‑Files and Finalization  
Trigger: FS-Reply not zero (end of invoice file).  
Key steps: store specials for vat totals, close invoice, value, analysis, and open-item files, display messages if analysis records were created, goback.  
I/O: value-file, analysis-file, invoice-file, open-item-file-4.  
Outcomes: files closed, totals written, program exits.  
[Seen in: close-files.]

Path: Create Analysis Record When Missing  
Trigger: Value-Read-Indexed returns 21 during value processing.  
Key steps: call create, which may write a new analysis record with emergency name, then write value record.  
I/O: analysis-file, value-file.  
Outcomes: new analysis record created, value record written.  
[Seen in: create section.]

5.4 Termination  
The program exits via GOBACK after closing all files and optionally displaying messages for created analysis records. [Seen in: menu-exit.]  
No further cleanup is performed beyond the file closures. [Seen in: menu-exit.]

---
## pl060
*[146/267]*

### Business/Functional Perspective
### Purchase Order Posting Report  

**Program Purpose**  
The program posts purchase‑order data from the Open‑Item files into the accounting system’s general ledger or IRS posting files. It verifies supplier and transaction records, updates balances, and records posting entries for receipts, invoices and credit notes. The posting process ensures that all financial movements are accurately reflected, supports audit trails, and reduces the risk of mis‑posted amounts.  

**Screen Interactions**  
No direct screens. This program runs after a separate data‑entry step, processes the posting data, and returns a printed report summarizing the posted transactions.  

**Messages and Errors**  
- **Missing or Invalid Records** – If a purchase record is not found, a warning is printed indicating “Record(s) missing in Purchase File.”  
- **File Write Failures** – Errors writing to the posting or batch files trigger a note such as “Error writing Open Item 5 Record” or “Error on Batch file write.”  
- **General Posting Issues** – If a transaction cannot be posted (e.g., zero‑value or invalid status), the program displays a brief notice and pauses for operator acknowledgment.  
- **Operational Confirmation** – Upon successful completion, the report lists totals and un‑applied credits; no error message is shown unless a problem occurs.  

**User Flow Summary**  
1. The user launches the posting routine (typically via a scheduler or a higher‑level interface).  
2. The program displays the current date and a “Posting…Please Wait” message while it scans the Open‑Item file.  
3. For each transaction, it matches the supplier, updates balances, and creates a posting record in the appropriate ledger file.  
4. A printable report is generated, showing each supplier’s transactions with amounts, old and new balances, and totals for receipts, invoices, and credit notes.  
5. If any un‑applied credits remain, a separate section lists them.  
6. The program finalizes the posting, cleans up temporary files, prints the report, and exits.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- CBL_DELETE_FILE  
- SYSTEM  
- GL-Batch-Open  
- GL-Posting-Open  
- GL-Posting-Open-Output  
- GL-Posting-Write  
- GL-Batch-Write  
- GL-Batch-Close  
- SPL-Posting-Open-Extend  
- SPL-Posting-Close  
- SPL-Posting-Write  
- maps04  
- Proc-ACAS-FH-Calls

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry initializes screen, environment, and displays header information before converting the current date. [Seen in: init01.]  
The program opens the purchase order open‑item file, the GL/IRS posting batch, and the print file, then enters the main posting loop that processes each open‑item record. [Seen in: init01, bl-open, loop.]  
For each record, the program reads the corresponding purchase record, calculates balances, writes a posting record to GL or IRS, updates totals, and prints a line to the report. [Seen in: loop, cr-swop, bl-write, headings.]  
After all open‑item records are processed, the program writes summary totals, closes posting files, prints the report, deletes temporary files if needed, and exits. [Seen in: main-end, bl-close, exit-prog.]

5.2 Initialization  
init01 sets the COBOL screen exception flags, displays program title and date, and converts the supplied to‑day value to UK format. [Seen in: init01, zz070-Convert-Date.]  
It then checks for the existence of optional Cobol files (ITM5 and ITM4) and sets flags accordingly, and if G‑L is true, opens the GL/IRS posting batch. [Seen in: init01, bl-open.]  
The purchase open‑item file and the print file are opened, and initial totals and counters are zeroed before the main loop begins. [Seen in: init01, loop.]

5.3 Core Processing  
Path: Main Posting Loop  
Trigger: read of open‑item‑file‑4.  
Key steps: read purchase record, compute balances, write posting record via bl‑write, update totals, print line.  
I/O: open‑item‑file‑4, purchase file (via Purch‑Read‑Indexed), open‑item‑file‑5 (via OTM5‑Write), print‑file.  
Outcomes: updated totals, print lines, posting records written.  
[Seen in: loop, cr-swop, bl-write, headings.]  

Path: Credit Note Swapping (cr‑swop)  
Trigger: oi‑type = 3 in main loop.  
Key steps: compute net, update status, write print record, rewrite open‑item‑file‑5 record.  
I/O: open‑item‑file‑5, print‑file.  
Outcomes: credit note status updated, print line for credit note.  
[Seen in: cr-swop.]  

Path: Un‑applied Credit Processing Loop  
Trigger: after main loop, read open‑item‑file‑5 records.  
Key steps: read next record, if type 3 perform cr‑swop, loop until end.  
I/O: open‑item‑file‑5, print‑file.  
Outcomes: un‑applied credits printed, open‑item‑file‑5 updated.  
[Seen in: end-loop, cr-swop.]  

Path: GL/IRS Posting Batch Open/Write/Close  
Trigger: G‑L flag true or during posting.  
Key steps: open batch, write posting record, close batch.  
I/O: batch file, posting file, IRS posting file.  
Outcomes: posting records written to GL or IRS, batch totals updated.  
[Seen in: bl-open, bl-write, bl-close.]  

Path: Purchase Average Calculation  
Trigger: after processing receipt, invoice or credit note.  
Key steps: update activity and average.  
I/O: none.  
Outcomes: updated purch‑average used for subsequent calculations.  
[Seen in: purch-comp, credit-comp.]  

Path: Date Conversion  
Trigger: at program start and when converting dates.  
Key steps: convert dates between formats.  
I/O: none.  
Outcomes: u‑date and ws‑date set.  
[Seen in: zz070-Convert-Date, zz060-Convert-Date, zz050-Validate-Date.]

5.4 Termination  
exit‑prog performs cleanup by closing all open files, printing the report, deleting temporary files if present, and returning control to the caller. [Seen in: exit-prog, bl-close.]  
The program ends with a GOBACK/STOP RUN after all resources are released. [Seen in: exit-prog.]

---
## pl070
*[147/267]*

### Business/Functional Perspective
### Product Analysis Maintenance  

**Program Purpose**  
PL070 allows users to manage the Product Analysis (P/A) master file. It lets you create new P/A records, amend or delete existing ones, print selected or all records, and display the list of records. The program ensures that P/A codes are unique, that group codes exist before use, and that mandatory fields are supplied, reducing data entry errors and keeping the accounting system consistent.  

**Screen Interactions**  
1. **Menu Screen** – *Product Analysis File Set‑Up & Maintenance*  
   *Input:* Menu selection (1‑5 or 9).  
   *Output:* Displays the menu title, the function menu, and the exit option.  
   *Options:*  
   - 1: Set‑Up P/A Records  
   - 2: Amend/Delete P/A Records  
   - 3: Print P/A Records  
   - 4: Print All P/A Records  
   - 5: Display P/A Records  
   - 9: Return to system menu  

2. **Edit Screen** – *Set‑Up or Amend P/A Record*  
   *Input:*  
   - Group code (e.g., “va”, “za”)  
   - GL number (numeric, optional)  
   - Description (text)  
   - Print flag (text, optional)  
   - Escape code (B, S, Q, K) entered at the bottom of the screen.  
   *Output:* Current record values are shown in the line fields.  
   *Options:*  
   - **B** – Return to the previous screen.  
   - **S** – Save the current record.  
   - **Q** – Quit the edit mode (discard changes).  
   - **K** – Delete the current record.  

3. **Display Screen** – *View P/A Records*  
   *Input:*  
   - Press **Enter** to advance to the next record.  
   - Press **X** to exit the display.  
   *Output:* Shows each record’s group, GL number, description, print flag, and type (Group or Detail).  
   *Options:* None beyond the exit key.  

**Messages and Errors**  
- “P.A. Code Already Exists” – the entered code is already in use.  
- “P.A. Group Code Does Not Exist” – the selected group code is not defined.  
- “P.A. Group Code Used As Analysis Code” – a group code has been used as an analysis code.  
- “P.A. Code Does Not Exist” – the specified code cannot be found.  
- “Error on analMT processing” – an error occurred while reading or writing analysis records.  
- “Error on valueMT processing” – an error occurred while handling value records.  
- “Hit return for Menu” – the menu was exited by pressing return.  
- General warning when a record contains a zero value for the IRS / GL number.  

**User Flow Summary**  
The user launches PL070 and is presented with the menu screen. Selecting option 1 initiates the set‑up process: the user enters a group code; if the code is new, the program prompts for a GL number, a description, and an optional print flag. Escape codes allow the user to save, delete, or exit. Option 2 opens the same screen for an existing record, permitting edits or deletion. Option 3 prints a report of the selected P/A records (or all records if option 4 is chosen). Option 5 displays the records one by one, letting the user review each entry and exit when finished. After any operation, the program returns to the menu, where the user may start another task or exit back to the system menu.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- SYSTEM  

---

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins with init01 section which sets environment, checks file existence and may invoke p‑a‑setup. [Seen in: init01 section.]  
After initialization, menu‑return displays heading and menu‑input collects user choice. [Seen in: menu-return, menu-input.]  
Based on menu reply, the program dispatches to create, amend, report1, or show sections, then loops back to the menu until the user selects exit. [Seen in: menu-input, create, amend, report1, show.]

5.2 Initialization  
init01 accepts environment lines, sets screen exception flags, assigns spool name and file key, and checks if analysis file exists, calling p‑a‑setup if missing. [Seen in: init01 section.]  
If the program is called by Stock (ws‑Process‑Func = 1), init01 bypasses the menu and goes directly to Menu‑Exit. [Seen in: init01 section.]

5.3 Core Processing  
Path: Auto‑run Trigger – p‑a‑setup  
Trigger: File not found during init01 when FS‑Cobol‑Files‑Used is true.  
Key steps: perform Value‑Open, Analysis‑Open‑Output, create default value and analysis records for sales and purchase groups, then close files.  
I/O: value‑file, analysis‑file.  
Outcomes: Default P/A records are created and stored; program proceeds to main‑exit.  
[Seen in: init01 section., p‑a‑setup section., create‑value section.]  

Path: General Menu Dispatch – create  
Trigger: User selects menu reply 1.  
Key steps: perform Analysis‑Open, loop through user input of P/A groups, read existing records, prompt for details, write new analysis records.  
I/O: analysis‑file.  
Outcomes: New P/A records are written; loop continues until blank group entered.  
[Seen in: menu-input, create section.]  

Path: General Menu Dispatch – amend  
Trigger: User selects menu reply 2.  
Key steps: perform Analysis‑Open, loop through existing P/A groups, allow editing or deletion, rewrite or delete records accordingly.  
I/O: analysis‑file.  
Outcomes: Records are updated or removed; loop continues until blank group entered.  
[Seen in: menu-input, amend section.]  

Path: General Menu Dispatch – report1  
Trigger: User selects menu reply 3 or 4.  
Key steps: perform Analysis‑Open‑Input, open print‑file, read all analysis records, format and write to print‑file, close files, call SYSTEM to print.  
I/O: analysis‑file, print‑file.  
Outcomes: Printed report of P/A records; Print‑Mode may be set to all.  
[Seen in: menu-input, report1 section.]  

Path: General Menu Dispatch – show  
Trigger: User selects menu reply 5.  
Key steps: perform Analysis‑Open‑Input, display each analysis record on screen, allow user to exit or continue.  
I/O: analysis‑file.  
Outcomes: Records displayed to user; loop until exit.  
[Seen in: menu-input, show section.]

5.4 Termination  
Each core section ends by performing Analysis‑Close and then returns to menu or exits via Menu‑Exit. [Seen in: create, amend, report1, show, Menu‑Exit.]  
Menu‑Exit performs GOBACK to terminate the program. [Seen in: Menu‑Exit.]

---
## pl080
*[148/267]*

### Business/Functional Perspective
### Payment Data Entry  

**Program Purpose**  
The program allows staff to record a payment for a customer’s account.  It validates the payment date, checks that the account exists, shows the current and unapplied balances, and allocates the payment amount to the appropriate open invoices.  The process guarantees that payments are applied correctly, that late or over‑payments are flagged, and that the accounting records remain consistent.  This helps maintain accurate financial records, supports audit trails, and reduces the risk of mis‑applied funds.  

**Screen Interactions**  
1. **Header** – “Payment Data Entry” with the current date displayed.  
2. **Main input area** –  
   - **Date** field (format: `dd/mm/yyyy`).  
   - **Account number** field.  
   - **Value** field (payment amount).  
   - **Batch number** field.  
3. **Balance display** – shows the account’s current balance and, if present, an unapplied balance.  
4. **Unapplied balance prompt** – asks whether to allocate the unapplied balance to the account (`[Y]`).  
5. **Further payments prompt** – “Enter further payments? (Y/N) [Y]”.  
6. **Open‑item table** – lists each invoice being paid with columns for folio number, date, amount, deduction, paid amount, and status messages such as “Fully Paid” or “No change”.  

The screen updates in real time as the user enters or modifies values.  

**Messages and Errors**  
- **Invalid date or input** – the system rejects incorrect dates or empty fields.  
- **Account not found** – prompts the user to re‑enter a valid account number.  
- **Batch closed** – prevents new payments if the batch is already finalized.  
- **Purchase or invoice not posted** – blocks payment entry until the relevant records are posted.  
- **Payment too high** – warns the user that the entered amount exceeds the outstanding balance.  
- **Fully paid / No change** – confirms when an invoice is completely settled or when no additional amount is required.  

**User Flow Summary**  
The user launches the payment entry screen and is asked to type the payment date. After confirming the date, the user enters the customer account number. The program checks the account; if it exists, the screen shows the current and unapplied balances. The user may choose to apply any unapplied balance and then enters the payment amount. The system calculates the effect of the payment on each open invoice, updating the table with deduction, paid amounts, and status messages. If more payments are needed, the user can continue entering additional payments; otherwise, the user selects “N” and the program finalises the transaction, updates the relevant records, and exits back to the calling context.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry performs init01 section to set environment and check prerequisites. [Seen in: init01 section.]  
It displays program header and current date via display-heads and then proceeds to file opening and payment entry via dh-exit. [Seen in: display-heads, dh-exit.]  
After payment entry, files are closed, batch number incremented, and program exits via main-exit. [Seen in: dh-exit, menu-exit, main-exit.]

5.2 Initialization  
init01 section accepts environment line count, sets defaults, and forces screen exception handling. [Seen in: init01 section.]  
It checks P-Flag-I to display error and exit if set, and verifies existence of ITM5 file when FS-Cobol-Files-Used is true. [Seen in: init01 section.]

5.3 Core Processing  
Path: New-Payment-Main  
Trigger: dh-exit performs new-payment which calls New-Payment-Main.  
Key steps: display prompts, accept date, customer, value, batch, and update counters.  
I/O: purchase file (read), open-item file 5 (read/write).  
Outcomes: sets pay-date, pay-customer, pay-value, batch-value, updates bl-next-batch, k.  
[Seen in: dh-exit, new-payment section, New-Payment-Main.]

Path: Accept-Money  
Trigger: user enters amount via accept-money or accept-money2.  
Key steps: capture pounds and pence, compute amt-ok, display amount.  
I/O: none.  
Outcomes: amt-ok updated, used for payment amount.  
[Seen in: Accept-Money, Accept-Money2.]

Path: Payment-Appropriate  
Trigger: after value-input, perform Payment-Appropriate.  
Key steps: iterate over open-item records, apply payments, update records, handle unapplied balance, and rewrite records.  
I/O: open-item file 5 (read/write).  
Outcomes: oi-paid, oi-status, oi-date-cleared, oi-b-nos, oi-b-item updated; approp-amount, deduct-taken updated.  
[Seen in: Payment-Appropriate, Pay-Loop, Pay-Details, end-line.]

Path: Main-Exit  
Trigger: go to main-exit from various points.  
Key steps: close files, increment batch, set oi-5-flag, exit.  
I/O: none.  
Outcomes: program terminates, batch number incremented.  
[Seen in: main-exit, menu-exit, dh-exit.]

5.4 Termination  
The program exits via main-exit, closing files and returning control to caller. [Seen in: main-exit.]  
Before exiting, it increments the next batch number and sets oi-5-flag to Y. [Seen in: menu-exit.]

---
## pl085
*[149/267]*

### Business/Functional Perspective
### Payment Data Amend  

**Program Purpose**  
This program allows users to review and correct existing payment entries. It retrieves the relevant transaction, displays the customer and invoice details, and permits adjustments to the payment amount, appropriations, and deduction amounts. By validating dates and enforcing accounting rules, it ensures the ledger remains accurate and compliant with audit requirements. The result is a reliable, up‑to‑date financial record that can be posted or further amended as needed.  

**Screen Interactions**  
1. **Header screen** – Shows the program name, the title “Payment Data Amend”, and the current date.  
2. **Transaction entry screen** – Prompts for:  
   * Supplier code (A/C No.) – entered at position 0572.  
   * Account number – entered at 0770.  
   * Item number – entered at 0776.  
   The screen also displays the selected supplier, invoice, current balance, and the current payment amount.  
3. **Payment amount screen** – Allows the user to enter a new payment value, with a dollar sign and decimal separator.  
4. **Deduction entry screen** – If a deduction is required, the program displays the available amount and prompts for the deduction to apply.  
5. **Confirmation prompts** –  
   * “Confirm No action? i.e. Request cancelled (Y/N)..[ ]” – asks whether to cancel a change when the amount is unchanged.  
   * “Make further corrections? (Y/N)  [Y]” – offers to return to the main screen for additional edits.  
   * “No payments to correct” – shown when no matching records exist.  

**Messages and Errors**  
* “No payments to correct” – Indicates that the entered supplier/account/invoice combination has no payment records to amend.  
* “Not Yet Supporting Corrections” – Alerts the user that the requested type of correction is not yet implemented.  
* “Amount Approp Or Deduct Amt Not Zero” – Shown if, after attempting a change, the remaining appropriation or deduction amounts are still non‑zero, signalling an incomplete update.  
* “Warning Unapplied Balance Journal” – Informs the user that the transaction is an unapplied balance journal, which may affect subsequent processing.  
* General “Hit Return To Continue” prompts that pause the screen until the user acknowledges.  

**User Flow Summary**  
The user starts the program and sees the header with the current date. They enter the supplier code, then the account number and item number. The program retrieves the transaction, displaying the customer’s name, address, and current balance. The user reviews the existing payment amount and enters a new value if desired. If the amount is unchanged, the program offers to cancel the request. If changed, the original payment record is deleted and the system adjusts appropriations and deductions as required, then writes the updated transaction. Afterward the user can choose to make further corrections or exit the program.  

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by executing the init01 section which performs environment setup, date conversion, and opens necessary files. [Seen in: init01 section.]  
User interaction and payment amendment processing occur in the new-payment section, where batch, supplier, customer, and transaction details are entered and validated. [Seen in: new-payment section.]  
After processing, the program closes files and exits via the main-exit paragraph. [Seen in: main-exit paragraph.]

5.2 Initialization  
init01 checks the P-flag-P; if zero it displays PL142, prompts for return, and exits. [Seen in: init01 section.]  
It sets screen exception environment variables, displays program headers, converts the current date, and opens the purchase and open-item files. [Seen in: init01 section.]

5.3 Core Processing  
Path: New-Payment-Main  
Trigger: User enters a supplier code at get-batch. [Seen in: get-batch paragraph.]  
Key steps: Accept supplier, batch number, customer number, item number; start open-item-file-5, loop through records to find matching transaction; display transaction details; accept new value; if value changed, delete open-item record and adjust purchase record; optionally handle unapplied balance. [Seen in: customer-input, find-trans-loop, value-input, value-input-2, OTM5-Delete, Purch-Rewrite, main-exit.]  
I/O: open-item-file-5 (OTM5), purchase-file (Purch). [Seen in: OTM5-Start, OTM5-Read-Next, OTM5-Delete, Purch-Read-Indexed, Purch-Rewrite.]  
Outcomes: Updated open-item and purchase records, possible flag oi-5-flag set to Y, and screen prompts for further corrections. [Seen in: main-exit, menu-exit.]

Path: payment-appropriate  
Trigger: After a value change, payment-appropriate is performed to reverse amounts. [Seen in: payment-appropriate section.]  
Key steps: Start open-item-file-5, loop through type 2 records matching customer and transaction, reverse amounts, handle deductions, rewrite records, and display PL141 if amounts remain. [Seen in: pay-loop, get-deduct, by-pass-deduct, main-end.]  
I/O: open-item-file-5 (OTM5). [Seen in: OTM5-Start, OTM5-Read-Next, OTM5-Rewrite.]  
Outcomes: Adjusted open-item records, potential display of PL141, and exit to main-exit. [Seen in: main-end.]

Path: init01  
Trigger: Program start. [Seen in: init01 section.]  
Key steps: Check p-flag-p, set environment, display headers, convert date, open files, call new-payment. [Seen in: init01 section.]  
I/O: None initially, then purchase and open-item files. [Seen in: Purch-Open, OTM5-Open.]  
Outcomes: Program ready for user interaction. [Seen in: init01 section.]

Path: main-exit  
Trigger: Program reaches main-exit after processing or user abort. [Seen in: main-exit paragraph.]  
Key steps: Close purchase and open-item files, set oi-5-flag to Y, display headers, and GOBACK. [Seen in: Purch-Close, OTM5-Close, menu-exit, main-exit.]  
I/O: None (file close). [Seen in: Purch-Close, OTM5-Close.]  
Outcomes: Clean termination with files closed. [Seen in: main-exit.]

5.4 Termination  
The program terminates by executing main-exit, which closes all files and performs a GOBACK. [Seen in: main-exit paragraph.]  
No additional cleanup is performed beyond file closure. [Seen in: main-exit paragraph.]

---
## pl090
*[150/267]*

### Business/Functional Perspective
### Payment Proof Sorting  

**Program Purpose**  
The program reorganises payment records to support accurate proofing and posting. It verifies that the input files are correctly formatted, filters out irrelevant entries, and sorts the remaining records by batch number, item, type, date, and invoice number. The resulting sorted list is then available for downstream posting processes, helping maintain compliance and reducing the risk of duplicate or missing payments.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *Record format mismatch*: If the payment record structure does not match the expected length, the program informs the user that the files are inconsistent and prompts them to press return before exiting.  
- *No payment data*: When no payment records are present for processing, the user is notified that there are no payments to correct, proof, or post and is prompted to press return.  
- *System error*: In the unlikely event that internal file lengths differ, a system‑level error message is displayed and the program halts.  

**User Flow Summary**  
The user invokes the program after payment data has been loaded. The program first checks that the system is configured to use COBOL files. It then verifies that the record definitions for the open‑item file and the sort file are identical; if not, the user receives an error message and the program stops. If the check passes but no payment records are found, the user is informed accordingly and the program ends. Otherwise, the program reads each payment record, discards those of types 1 or 3 and any record with zero batch number and item, and releases the rest into a temporary sort file. The sort operation arranges the remaining records by the specified keys. Once sorting completes, the program exits cleanly, leaving the sorted list available for subsequent posting or audit functions.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** section, performing environment checks and initializing key variables before deciding whether to proceed or exit.  
If the program is configured to use COBOL files, it verifies record lengths and then initiates the sorting routine via the **sorting-1** section.  
After sorting, the program performs the input-to-sort processing, reading and filtering records, and finally exits through **menu-exit**.  
[Seen in: init01 section.]  
[Seen in: sorting-1 section.]  
[Seen in: menu-exit.]

5.2 Initialization  
The **init01** section checks the FS-Cobol-Files-Used flag; if false, it returns immediately with status 4.  
It then compares the lengths of Open-Item-Record-5 and Sort-Record, displaying an error and aborting if they differ.  
If no payment data is present (P-Flag-P = 0), it displays a message and jumps to **menu-exit**.  
[Seen in: init01 section.]

5.3 Core Processing  
Path: Sorting Routine  
Trigger: Successful completion of initialization and presence of payment data.  
Key steps: Perform **sorting-1** section, which issues a SORT on sort-file with specified keys and input procedure **input-to-sort**.  
I/O: sort-file.  
Outcomes: sort-file is created and populated; control returns to **main-exit**.  
[Seen in: sorting-1 section.]

Path: Input-to-Sort Processing  
Trigger: Execution of **input-to-sort** section during the SORT operation.  
Key steps: Open input file via OTM5-Open-Input; if open fails, close input, create empty output file, and exit.  
I/O: open-item-file-5, open-item-file-s.  
Outcomes: If input file opens successfully, control proceeds to **process-input**; otherwise, sorting terminates.  
[Seen in: input-to-sort section.]

Path: Record Filtering  
Trigger: Each record read by OTM5-Read-Next in **process-input**.  
Key steps: Read next record; if end-of-file (fs-reply = 10), go to **end-of-input**.  
If oi-type is 1 or 3, or if both oi-b-nos and oi-b-item are zero, skip to next record.  
Otherwise, release the record to sort-record and loop.  
I/O: open-item-file-5, sort-record.  
Outcomes: Only records that meet criteria are released to the sort file; all others are discarded.  
[Seen in: process-input paragraph.]

Path: End of Input  
Trigger: End-of-file detected in **process-input**.  
Key steps: Close open-item-file-5 and exit to **main-exit**.  
I/O: open-item-file-5.  
Outcomes: Input file closed; sorting completes.  
[Seen in: end-of-input paragraph.]

5.4 Termination  
The program exits via the **menu-exit** paragraph, which performs a GOBACK to return control to the caller.  
No additional cleanup beyond file closure is performed; any open files are closed within their respective sections.  
[Seen in: menu-exit.]

---
## pl095
*[151/267]*

### Business/Functional Perspective
### Payment Proof Report  

**Program Purpose**  
This program generates a payment proof report that lists each supplier’s payments, invoices, and related adjustments. It pulls data from open‑item and purchase records, formats dates, and calculates totals for payments, appropriations, and deductions. The resulting printed report provides a clear audit trail and helps finance staff verify cash disbursements and reconciliations.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If any required file cannot be opened or a read fails, the program terminates without printing the report.  
- No user‑visible error messages are displayed; the program simply aborts and control is returned to the caller.  

**User Flow Summary**  
When the user runs the program, it first prints a header that includes the program name, title, current date, and user identifier. It then opens the necessary data sources and processes each open‑item record. For each payment or invoice it prints a line containing supplier information, amounts, dates, and balance details. After all records are processed, the program prints subtotal lines for payments, appropriations, unapplied cash, and deductions, followed by journal totals. The final output is a page‑formatted printed report that can be reviewed or archived.  

**Program Linkages**  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the `init01` section, performing startup checks, setting spool parameters, and displaying the header before invoking the main report routine. The `report1` section opens the necessary data files or tables, prints headings, and enters a read loop that processes payment and invoice records, accumulating totals. After all records are processed, the program writes summary totals, closes files, triggers the print system, and exits. [Seen in: init01, report1, headings, loop-end.]

5.2 Initialization  
The `init01` section checks the `P-Flag-P` flag; if zero it exits immediately, otherwise it initializes spool name, program name, and flags, displays the program title, converts the current date, and displays it. It then calls `report1` to perform the main processing. [Seen in: init01.]

5.3 Core Processing  

Path: File Open Path  
Trigger: `FS-Cobol-Files-Used` is true.  
Key steps: Open the COBOL open‑item file for input, open the purchase file for input, open the print file for output, and perform the `headings` routine.  
I/O: `open-item-file-s`, `purchase-file`, `print-file`.  
Outcomes: Files are ready for reading; page counter initialized.  
[Seen in: report1.]

Path: Table Path  
Trigger: `FS-Cobol-Files-Used` is false.  
Key steps: Call `OTM5-Open-Input` to prepare the RDB table, read the next sorted record via `OTM5-Read-Next-Sorted-By-Batch`, and loop until end of table.  
I/O: RDB table accessed through `OTM5` calls.  
Outcomes: Records are streamed directly from the table without a sort file.  
[Seen in: report1.]

Path: Process Payment Path  
Trigger: `oi-type` equals 5 or 6 and the record passes type checks.  
Key steps: Load supplier, batch, and item data into line fields; convert payment date; look up customer name via `Purch-Read-Indexed`; accumulate totals into `t-pay`, `t-approp`, `t-deducts` (for payments) or `j-pay`, `j-approp`, `j-deducts` (for journal entries); write the formatted line to the print file.  
I/O: `open-item-file-s` (or table), `purchase-file`, `print-file`.  
Outcomes: Payment lines printed; running totals updated.  
[Seen in: report1, Read-Loop-Tests, process-invoice.]

Path: Process Invoice Path  
Trigger: `oi-type` equals 2 and `oi-paid` > 0 and supplier matches `save-customer`.  
Key steps: Load invoice number, convert invoice date, determine applied amount, compute balance, write the invoice line to the print file.  
I/O: `open-item-file-s` (or table), `print-file`.  
Outcomes: Invoice lines printed; no totals updated.  
[Seen in: report1, process-invoice.]

Path: Totals Output Path  
Trigger: End of read loop (`loop-end`).  
Key steps: Write summary lines for payments, appropriations, unapplied cash, and deductions for both payments and journal entries; close the print file; close the purchase file; if COBOL files were used, reset the open‑item file to an empty output file; call the external `SYSTEM` routine to print; exit the program.  
I/O: `print-file`, `purchase-file`, `open-item-file-s`.  
Outcomes: Final totals displayed, files closed, program terminates.  
[Seen in: loop-end, main-exit.]

5.4 Termination  
The program closes the print file, the purchase file, and if COBOL files were used, resets the open‑item file to an empty output file. It then calls the external `SYSTEM` routine to send the report to the printer and exits via `main-exit`. [Seen in: loop-end, main-exit.]

---
## pl100
*[152/267]*

### Business/Functional Perspective
### Payments Posting  

**Program Purpose**  
The program posts outstanding cash payments for supplier invoices, updates purchase balances, and records the corresponding general‑ledger (or IRS) entries. It consolidates all payment, deduction, and apportioned amounts, producing a printed “Cash Posting Report” that provides an audit trail for the finance team. By ensuring balances are current and posting records are accurate, the program helps maintain compliance, reduces reconciliation risk, and supports end‑of‑month closing activities.  

**Screen Interactions**  
1. **Purchase Cash Posting Screen** – Displays the program title, the current date, and prompts the user:  
   - *Input:* “OK to post payment transactions (YES/NO) ?”  
   - *Output:* If the user answers “YES”, the program proceeds; “NO” exits the screen.  

2. **Cash Posting Report** – A printed report that lists each processed payment with batch number, supplier, transaction type, old balance, new balance, payment, deduction, and apportioned amounts, followed by totals for payments, deductions, and journal postings.  

**Messages and Errors**  
- *Payments Not Proofed* – If payments are not ready to be posted, the user sees a message indicating the issue and must acknowledge before the program terminates.  
- *Batch File Write Error* – When the program fails to write to the batch file, an error message is shown and the user must acknowledge it.  
- *General Error Notice* – For any other errors, the user is prompted to “Note error and hit return” and then the program exits.  

**User Flow Summary**  
1. The user starts the program, which shows the current date and asks whether to post payments.  
2. Upon entering “YES”, the program opens the purchase, open‑item, and posting files.  
3. It scans all open‑item records, updates purchase balances, writes GL or IRS posting entries, and prints a detailed cash posting report on the screen and to a printer spool.  
4. After all records are processed, the program outputs payment and journal totals, closes all files, updates any value‑deduction records, and prints a final report.  
5. The user then exits the program, which returns control to the surrounding application or workflow.  

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by initializing environment, converting the current date, and verifying the posting flag before presenting a prompt to the user. [Seen in: init01 section.]  
Upon confirmation, it opens necessary files, displays headers, and enters a loop that reads open‑item records, processes payments, updates purchase records, writes postings, and prints a report. [Seen in: loop, headings, bl-write.]  
After all records are processed, it closes files, writes totals, performs deduction analysis if needed, and exits the program. [Seen in: main-end.]

5.2 Initialization  
The init01 section sets screen exception flags, converts the system date, checks that P‑Flag‑P equals 2, and displays an error message if not. [Seen in: init01 section.]  
It then prompts the user for confirmation, opens purchase, OTM5, batch (if G‑L), and print files, and writes the initial report headings. [Seen in: acpt‑xrply, Purch‑Open, OTM5‑Open, BL‑Open, headings.]

5.3 Core Processing  

Path: Payment Posting Loop  
Trigger: loop entry after user confirmation.  
Key steps: read next OTM5 record, filter by type, compute payment amounts, update purchase balances, rewrite purchase and OTM5 records, write posting record, update totals, print line.  
I/O: OTM5, purchase file, print file, BL (if G‑L).  
Outcomes: updated balances, totals, posting records, print output.  
[Seen in: loop, compute‑purch‑pay, Purch‑Rewrite, OTM5‑Rewrite, bl‑write, headings.]

Path: Value Deduction Analysis  
Trigger: after main‑end when t‑deduct not zero.  
Key steps: open value file, read record for code “Pzb”, adjust totals for deductions, rewrite record.  
I/O: value file.  
Outcomes: updated value totals.  
[Seen in: analise‑deductions, Value‑Open, Value‑Read‑Indexed, Value‑Rewrite.]

Path: Batch Posting (G‑L)  
Trigger: when G‑L flag set during loop or at exit.  
Key steps: BL‑Open at start, BL‑Write for each posting, BL‑Close at end.  
I/O: batch file, posting file.  
Outcomes: batch record written, posting records written.  
[Seen in: bl‑open, bl‑write, bl‑close.]

Path: Date Conversion  
Trigger: at program start and when converting dates for records.  
Key steps: convert to UK format using zz070‑Convert‑Date or zz060‑Convert‑Date.  
I/O: none.  
Outcomes: ws‑date set for display and processing.  
[Seen in: init01 section, zz070‑Convert‑Date, zz060‑Convert‑Date.]

Path: Exit  
Trigger: menu‑exit or after main‑end.  
Key steps: close files, call SYSTEM to print, set flags, exit program.  
I/O: print file, value file, batch file.  
Outcomes: program termination, flags reset.  
[Seen in: menu‑exit, main‑end, Eval‑Status.]

5.4 Termination  
The program closes all open files, writes final totals, and calls the system print routine before exiting. [Seen in: main-end, Eval‑Status.]  
It resets the oi‑5‑flag and P‑Flag‑P before performing the GOBACK. [Seen in: main-end.]

---
## pl115
*[153/267]*

### Business/Functional Perspective
### Trial Balance Sorting  

**Program Purpose**  
The program prepares a sorted set of trial‑balance records for reporting and audit purposes. It verifies that the necessary item data file is available, then arranges the records by customer, date, invoice number, and type. This ordering supports accurate downstream processing and ensures that reports reflect the correct chronological and customer‑based sequence. By eliminating the need for a separate sorting step, the program reduces processing time and minimizes the risk of mis‑ordered data.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
* Missing or inaccessible item file – the user sees a message stating that purchase transactions were not posted and is prompted to press return.  
* General processing failure – the user may receive a notification that the program has ended prematurely.  

**User Flow Summary**  
When invoked, the program first checks whether the environment is configured to use COBOL files; if not, it exits immediately. It then examines a flag to determine whether sorting is required. If sorting is needed, it confirms that the item data file exists; if the file is missing, it displays an error message and waits for user acknowledgement before terminating. Otherwise, it reads the open‑item file record by record, writes each record into a temporary sort file, and finally closes the input file. The sorted file is left ready for the next step in the accounting process, and control is returned to the calling program.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins in the procedure division, immediately entering the **init01 section** to perform startup checks and determine whether to proceed with sorting. [Seen in: init01 section.]  
If conditions permit, **init01** performs the **sorting-1 section**, which sorts the input file using **input-to-sort** as the input procedure. [Seen in: sorting-1 section.]  
The **input-to-sort** section opens the open-item-file-5, repeatedly reads records, releases them into the sort file until **end-of-input**, after which the file is closed and the program exits. [Seen in: input-to-sort section.]

5.2 Initialization  
The **init01 section** verifies that Cobol files are used; if not, it gobacks returning 4. [Seen in: init01 section.]  
It checks **oi-5-flag**; if set to "N", it jumps to **menu-exit** to skip sorting. [Seen in: init01 section.]  
If Cobol files are used, it calls **CBL_CHECK_FILE_EXIST** to confirm the ITM5 file exists, setting **oi-5-flag** to "Y" and displaying error messages if the file is missing. [Seen in: init01 section.]  
If the file exists, it performs **sorting-1** and resets **oi-5-flag** to "N". [Seen in: init01 section.]

5.3 Core Processing  
Path: Auto‑Run Trigger  
Trigger: Entry into **init01 section**.  
Key steps: Check FS‑Cobol‑Files‑Used, oi‑5‑flag, call CBL_CHECK_FILE_EXIST, set oi‑5‑flag, possible early exit.  
I/O: File‑29 (ITM5).  
Outcomes: Determines whether to proceed with sorting or exit early.  
[Seen in: init01 section, menu-exit.]

Path: Sorting Path  
Trigger: Successful file existence check leads to **perform sorting‑1**.  
Key steps: Execute **sorting‑1 section** (sort‑file with input procedure **input‑to‑sort**), open input file, read records, release to sort‑record, loop until end‑of‑input, close file.  
I/O: sort‑file, open‑item‑file‑5.  
Outcomes: Sorted file created; program exits after sort.  
[Seen in: sorting‑1 section, input‑to‑sort section, process‑input, end‑of‑input.]

Path: End‑of‑Cycle Orchestration  
Trigger: **fs‑reply = 10** in **process‑input** loop.  
Key steps: Execute **end‑of‑input** paragraph, perform OTM5‑Close, copy Proc‑ACAS‑FH‑Calls.cob.  
I/O: open‑item‑file‑5.  
Outcomes: Input file closed; any additional processing in the copied file may occur.  
[Seen in: end‑of‑input.]

Path: Menu Exit Path  
Trigger: **oi‑5‑flag = "N"** or file not found (error path).  
Key steps: Jump to **menu‑exit**, exit program.  
I/O: None.  
Outcomes: Program terminates without performing sorting.  
[Seen in: menu‑exit.]

5.4 Termination  
The program terminates by executing the **menu‑exit** paragraph, which exits the program. [Seen in: menu‑exit.]  
If sorting completed, the **main‑exit** paragraph also exits the program after the sort operation. [Seen in: main‑exit.]

---
## pl120
*[154/267]*

### Business/Functional Perspective
### Aged Creditors Report  

#### Program Purpose  
The program generates an aged creditors statement that lists each supplier’s outstanding invoices and payments, grouped into current, 30‑, 60‑, 90‑day and over‑age buckets. It aggregates totals, calculates average outstanding balances, and includes reconciliation information such as payments posted, unapplied cash, and credit balances. The report supports business compliance by providing a clear view of supplier exposure and payment performance, helping to reduce credit risk and improve cash‑flow management.  

#### Screen Interactions  
1. **Entry Screen** – Displays a heading with the program name, date prompt, account‑number prompt, and value prompt.  
   * **Date field** – User enters the reporting date.  
   * **Account field** – User can enter a specific supplier account number or leave blank to include all suppliers.  
   * **Value field** – User enters a minimum outstanding amount to include in the report.  
   * **Notes** – On-screen instructions:  
     - Press *F1* to sort the report alphabetically by supplier name.  
     - The date field accepts dates in UK, USA, or international formats.  
2. **Report Output** – The aged creditors report is printed to a spool device; it is not displayed as an interactive screen.  

#### Messages and Errors  
- **Missing Data** – If the program cannot find the required purchase or open‑item records, it informs the user that no relevant records are present.  
- **File Issues** – When necessary files are not available, a message is shown indicating the missing data set.  
- **Invalid Date** – If the entered date is not a valid calendar date, the program prompts the user to re‑enter a correct date.  
- **Processing Alerts** – General prompts such as “Hit Return To Continue” are displayed after error messages to pause until the user acknowledges.  

#### User Flow Summary  
1. The user launches the program and sees the entry screen.  
2. The user enters the report date, optionally a specific supplier account number, and a minimum value threshold; pressing *F1* switches the sort order to supplier name.  
3. After confirming the inputs, the program reads purchase and open‑item data, calculates aging buckets for each supplier, and totals the balances and payments.  
4. The report is generated, printed to the default print device, and includes detailed per‑supplier lines, aging breakdowns, totals, and reconciliation data.  
5. Upon completion, the program returns control to the caller, ready for the next operation.  

#### Program Linkages  
- CBL_CHECK_FILE_EXIST  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry begins in **init01**, which displays the header, sets screen exceptions, checks for required files, and prepares the print spool. [Seen in: init01.]  
The user is prompted for a date, optional customer name, and a minimum value; these inputs are validated and may set the Sorted-Report flag if F1 is pressed. [Seen in: date-input.]  
After opening the output file and, if requested, the sorted sales file, the program enters the main processing loop, reading sales records and dispatching each to purchase or open‑item processing. [Seen in: read-sales.]  
Each purchase record is evaluated in **Purch-Rec-Wanted**, updating totals, printing supplier details, and handling unapplied cash. [Seen in: Purch-Rec-Wanted.]  
Open‑item records are processed in **roi-1**, where invoices, payments, and credit notes are aged, balances are calculated, and line items are written to the report. [Seen in: roi-1.]  
Once all records are processed, **report-analysis** generates summary statistics and reconciliation data before the program closes the print file and exits. [Seen in: report-analysis.]

5.2 Initialization  
**init01** displays a blank line, sets screen exception flags, and moves the print spool name to the PSN variable. [Seen in: init01.]  
It checks for the existence of the ITM5 file and displays an error if missing, then displays the program name and prompts for the report date. [Seen in: init01.]  
The program calls **zz070-Convert-Date** to format the date, then performs **trail-balance** to show header information and **report-analysis** to pre‑populate totals. [Seen in: init01.]  
After value input, the program opens the output print file, sets the page counter, and opens the purchase and open‑item files, optionally opening the sorted sales file if Sorted-Report is set. [Seen in: value-input.]

5.3 Core Processing  
Path: System Setup  
Trigger: Program start (init01)  
Key steps: Display header, set environment, check ITM5 file, display program name, convert date, perform trail-balance, perform report-analysis, close print-file, call SYSTEM, goback.  
I/O: None (only file existence check)  
Outcomes: Sets up screen, initializes variables, prepares print spool, exits if error.  
[Seen in: init01.]  

Path: User Input  
Trigger: User presses keys during date-input, customer-input, value-input  
Key steps: Accept date, validate, accept customer name, accept minimum value, set Sorted-Report flag if F1 pressed.  
I/O: Accepts user input from screen.  
Outcomes: Populates ws-date, customer-in, pay-value, sets report-type flag.  
[Seen in: date-input.]  

Path: Sorted-Report  
Trigger: Sorted-Report flag set to true (by F1 or earlier)  
Key steps: Open input sales-sort file, set l1-sorted, perform headings, open purchase and open-item files.  
I/O: sales-sort (input), print-file (output), purchase-file (input), open-item-file-s (input) or OTM5.  
Outcomes: Prepares sorted sales data for processing.  
[Seen in: read-sales.]  

Path: Process Purchase Record  
Trigger: read-sales reads a purchase record (not sorted or sorted) and passes to Purch-Rec-Wanted  
Key steps: Update totals, calculate balances, print supplier details, handle unapplied cash, write to report.  
I/O: purchase-file (input), print-file (output)  
Outcomes: Updates totals (tot-acct-live, tot-sales-bal, etc.), writes supplier line to report.  
[Seen in: Purch-Rec-Wanted.]  

Path: Process Open-Item Record  
Trigger: read-open-item processes an open-item record for current purchase key  
Key steps: Determine type (invoice, payment, credit note), calculate aging, update balances, write line items, handle late payments.  
I/O: open-item-file-s (input), print-file (output)  
Outcomes: Updates balances (bal-0, bal-30, bal-60, bal-90, bal-pay), writes invoice/payment lines, updates totals.  
[Seen in: roi-1.]  

Path: End-of-Cycle  
Trigger: After all records processed, report-analysis section runs  
Key steps: Generate summary statistics, write totals, write reconciliation data, compute variances.  
I/O: print-file (output)  
Outcomes: Final report content, sets totals for exit.  
[Seen in: report-analysis.]  

5.4 Termination  
main-end closes the open-item file (or OTM5), closes the purchase file, closes the sales-sort file if used, and calls SYSTEM to print the report. [Seen in: main-end.]  
The program then performs a GOBACK to return control to the caller. [Seen in: menu-ent.]

---
## pl130
*[155/267]*

### Business/Functional Perspective
### Purchase Analysis Report  

#### Program Purpose  
This program produces a printed analysis of purchase transactions. It reads the system’s purchase‑value file, filters for purchase‑only records, and calculates key metrics such as current versus previous periods and year‑to‑date amounts. The resulting report helps finance staff compare spending trends, assess performance, and support budgeting decisions. By automating the report generation, the program reduces manual effort and ensures consistent, up‑to‑date data for decision‑making.  

#### Screen Interactions  
No direct screens. This program is invoked after data entry and returns a formatted printed report to the user’s designated output (typically a spool or printer).  

#### Messages and Errors  
- **No Data Found** – If the purchase‑value file contains no records, the program displays a notice that there is nothing to report and exits.  
- **File Read Error** – Should an error occur while opening or reading the value file, a message indicating a reading error is shown and, if the caller is not the special batch program, the user is prompted to press return before the program stops.  
- **General Prompt** – When either of the above conditions occurs, the program displays a generic “Hit Return To Continue” prompt.  
- **Termination Code** – If an error is detected and the caller is a batch job, the program sets a termination code to indicate failure and exits.  

#### User Flow Summary  
The user or calling program starts the report routine, which first retrieves system parameters and prepares the date information. The program then opens the purchase‑value file and begins reading records. For each record that qualifies as a purchase and contains current, previous, and year‑to‑date data, it calculates percentages and totals, formats a line of the report, and writes it to the print file. When a page limit is reached, a new header is inserted automatically. After all relevant records are processed, the program closes the files, triggers the system print service to send the report to the printer, and exits cleanly.  

#### Program Linkages  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at **init01**, initializing spool name, program version, header display, and converting the current date to UK format. [Seen in: init01 section.]  
**init01** performs **Report1**, which opens the value file, reads records, filters for purchase data, and writes the report to the print file. [Seen in: Report1 section.]  
After **Report1** completes, **init01** reads and rewrites system parameters, clears the purchase analysis flag, and control falls to **menu-exit** which exits the program. [Seen in: init01 section, menu-exit paragraph.]

5.2 Initialization  
**init01** moves Print‑Spool‑Name to PSN, sets l1‑version, displays header, and converts the current date to UK format. [Seen in: init01 section.]  
**init01** performs **Report1** to generate the report, then reads and rewrites system parameters and clears the purchase analysis flag. [Seen in: init01 section.]

5.3 Core Processing  

Path: Report1 Main Loop  
Trigger: perform Report1  
Key steps: open value file (Value‑Open‑Input), open print file, loop reading value records (Value‑Read‑Next), filter for purchase records, write report lines, handle page breaks, and continue until end of file.  
I/O: value‑file, print‑file.  
Outcomes: report printed, line‑cnt updated, page breaks handled, program proceeds to end‑report.  
[Seen in: Report1 section, read-loop, headings, end-report.]

Path: Value File Open Error  
Trigger: fs‑reply not zero after Value‑Open‑Input  
Key steps: close value file, display PL161, optionally display PL003 and accept menu reply, go to main‑exit.  
I/O: value‑file.  
Outcomes: program exits with error status.  
[Seen in: Report1 section.]

Path: Value Record Read Error  
Trigger: fs‑reply not zero after Value‑Read‑Next  
Key steps: display PL160 and Eval‑Msg, optionally display PL003 and accept reply or set WS‑Term‑Code, go to end‑report.  
I/O: value‑file.  
Outcomes: program exits with error status.  
[Seen in: Report1 section.]

Path: End of Report  
Trigger: FS‑Reply = 10 (end of file)  
Key steps: close print file, close value file, call SYSTEM to print report, goback.  
I/O: print‑file, value‑file.  
Outcomes: program terminates normally.  
[Seen in: Report1 section, end-report.]

Path: Date Conversion (zz070‑Convert‑Date)  
Trigger: perform zz070‑Convert‑Date in init01  
Key steps: move to‑day to ws‑date, adjust for date form, set ws‑date.  
I/O: none.  
Outcomes: ws‑date set to UK format.  
[Seen in: zz070‑Convert‑Date section.]

Path: System Parameter Read/Rewrite  
Trigger: perform zz900‑Read‑System‑Param and zz910‑Rewrite‑System‑Param after Report1  
Key steps: read system parameters, clear P‑Flag‑A, rewrite system parameters.  
I/O: system parameter file.  
Outcomes: system parameters updated.  
[Seen in: init01 section.]

5.4 Termination  
After completing Report1 and system parameter updates, the program reaches **menu‑exit** which executes GOBACK to terminate. [Seen in: menu‑exit paragraph.]  
The **end‑report** paragraph ensures the print file and value file are closed and the SYSTEM routine is called before exiting. [Seen in: end-report paragraph.]

---
## pl140
*[156/267]*

### Business/Functional Perspective
### Purchase Ledger Day Book  

**Program Purpose**  
PL140 generates a “Day Book” report that lists all receipts, invoices, and credit notes for a specified date. The report groups entries by supplier and shows net amounts, VAT, gross totals, and any deductable amounts. It provides a concise, ready‑to‑print record of daily sales activity, aiding compliance, audit, and financial monitoring.  

**Screen Interactions**  
1. **Top of screen** – Program name (PL140), title “Day Book”, and the selected date are displayed.  
2. **Report output** – The formatted day‑book report is written to the print spool; the screen itself shows no interactive prompts.  

**Messages and Errors**  
- If the invoice or purchase file cannot be opened, or if no records are found, the program displays “No data, nothing to do - exiting” and stops.  
- When a supplier key does not match a known customer, the report line shows “!! CUSTOMER UNKNOWN”.  
- If any sales records are missing during totals calculation, a warning line “Warning Record/s Missing In Sales File - See Report” appears in the printout.  

**User Flow Summary**  
The user runs PL140 (typically with the date to report). The program opens the invoice and purchase files for that day, filters out applied or already day‑booked entries, and compiles each transaction into a line of the report. Each line lists the invoice number, date, supplier, type (Receipt, Invoice, Credit Note), net, VAT, gross, and any prompt‑pay deduction. After all lines are processed, the program prints subtotal groups and overall totals. The resulting day‑book is sent to the printer or spooler; the screen shows only the title, date, and a short status message if no data is available.  

**Program Linkages**  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** section, initializing screen titles, dates, and resetting totals before opening the invoice and purchase files. [Seen in: init01 section.]  
It then enters the **menu-return** paragraph, which displays headers and loops through invoice records, reading each, matching to purchase records, and accumulating totals. [Seen in: menu-return, loop.]  
Upon reaching the end of the invoice file, the **main-end** paragraph closes files, prints final totals, and exits the program. [Seen in: main-end.]

5.2 Initialization  
The **init01** section moves the spool name, program name, user, and current date into display fields, converts the date format, and zeroes the line counter and totals. [Seen in: init01 section.]  
It performs file opens for the invoice and purchase files, checks for errors, and opens the print file for output, aborting with a message if either input file fails to open. [Seen in: init01 section.]

5.3 Core Processing  

Path: **init01 (System Setup)**  
Trigger: Program start.  
Key steps: Set display titles, convert current date, zero totals, open invoice and purchase files, open print file.  
I/O: invoice-file (PInvoice-Open-Input), purchase-file (Purch-Open-Input), print-file (open output).  
Outcomes: Files opened, totals initialized, ready for main loop.  
[Seen in: init01, zz070-Convert-Date, zeroise-totals, PInvoice-Open-Input, Purch-Open-Input, print-file.]

Path: **menu-return (Main Processing Loop)**  
Trigger: After initialization, control goes to menu-return to display headers and start processing.  
Key steps: Display headers, perform headings, loop reading invoices, for each record read purchase record, format dates, compute totals, write line-5 to print file, increment line counter, repeat until end of invoice file.  
I/O: invoice-file (PInvoice-Read-Next), purchase-file (Purch-Read-Indexed), print-file (write line-5).  
Outcomes: Each invoice record processed, totals updated, lines written to report.  
[Seen in: menu-return, headings, loop, PInvoice-Read-Next, Purch-Read-Indexed, print-file.]

Path: **main-end (End-of-Cycle Orchestration)**  
Trigger: fs-reply = 10 (end of invoice file) in loop.  
Key steps: Close purchase and invoice files, set head-type, print final headings and totals, write totals, close print file, call SYSTEM to print report, goback.  
I/O: print-file (close), invoice-file (PInvoice-Close), purchase-file (Purch-Close).  
Outcomes: Report finalized, files closed, program exits.  
[Seen in: main-end, PInvoice-Close, Purch-Close, print-file, SYSTEM.]

Path: **headings (Header Printing)**  
Trigger: Called from menu-return before first record and when page limit exceeded.  
Key steps: Increment page counter, write header lines (line-1, line-2, line-4) to print file, reset line counter.  
I/O: print-file (write line-1, line-2, line-4).  
Outcomes: Page header printed, line counter reset.  
[Seen in: headings.]

Path: **print-totals (Printing Totals)**  
Trigger: After main-end, called four times to print totals for each group.  
Key steps: Increment group index, move totals to line-6 fields, write line-6 to print file.  
I/O: print-file (write line-6).  
Outcomes: Totals for each group printed.  
[Seen in: print-totals.]

5.4 Termination  
The program closes the print file, invokes the SYSTEM call to print the report, and then performs a GOBACK to terminate. [Seen in: main-end, print-file, SYSTEM.]  
No additional cleanup is performed beyond closing files and returning control to the caller. [Seen in: main-end.]

---
## pl160
*[157/267]*

### Business/Functional Perspective
### Supplier Alphabetical Listing

**Program Purpose**  
The program creates a printed report of suppliers arranged alphabetically. Users can filter the list by supplier number, status (live or dormant), credit period, invoice activity, average order value, overdue accounts, and the date the supplier record was entered. It validates any date input and ensures only suppliers meeting the chosen criteria appear. The resulting list includes supplier status, contact information, credit limits, and discount terms, providing a concise snapshot useful for management reviews, compliance checks, or risk assessments.

**Screen Interactions**  
The program presents a single interactive screen with the following elements (line numbers reflect the source layout):  

1. **Title** – “Supplier File” (line 1).  
2. **Current Date** – displayed at the top right (line 1).  
3. **Supplier Number** – input field (`cust-in`) for a key or prefix (line 8).  
4. **Status** – input field (`status-in`) with options: `<L>` Live, `<D>` Dormant, or blank for all (line 10).  
5. **Credit Period** – numeric input (`credit-in`) and operator (`credit-op`) with operators `<L>` less than, `<G>` greater than, `<E>` equal to (lines 12‑15).  
6. **Invoice Activity** – numeric input (`invoice-in`) and operator (`invoice-op`) (lines 17‑20).  
7. **Average Value** – numeric input (`average-in`) and operator (`average-op`) (lines 19‑22).  
8. **Overdue A/Cs** – numeric input (`overdue-in`) and operator (`overdue-op`) (lines 21‑24).  
9. **Date Entered** – date input (`enter-date-in`) and operator (`enter-date-op`) (lines 23‑26).  

After entering the desired criteria, the user presses Enter to submit. The screen loops until all entered operators are valid; an invalid date triggers an on‑screen message.

**Messages and Errors**  
- **Invalid Date** – If the entered date cannot be parsed, the user sees a brief on‑screen notification and must re‑enter the date.  
- **Record Not Found** – If a specified supplier key does not exist, a message is shown indicating the missing key, and the program continues scanning for other matching records.  
- **Successful Report Generation** – When criteria are satisfied, the program prints the report to the spool; no error message is shown.

**User Flow Summary**  
1. The user launches the report program.  
2. The screen appears with prompts for supplier number, status, credit period, invoice activity, average value, overdue accounts, and entry date.  
3. The user enters any combination of filters, leaving fields blank to include all suppliers.  
4. Upon submission, the program validates any date entry; if invalid, the user corrects it.  
5. The program processes the supplier data, applying the specified filters and sorting records alphabetically by supplier name.  
6. A formatted printout is generated, showing each supplier’s name, status, address, telephone, fax, credit limit, credit period, and discount.  
7. The report completes, and control returns to the calling context or exits, depending on how the program was invoked.

**Program Linkages**  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in the procedure division, performs **init01** to set up dates and environment, then calls **report1** to generate the report. [Seen in: init01.]  
**report1** opens the purchase file, performs **report-selection** to gather user criteria, sets up report headings, and then produces the report by reading and filtering records. [Seen in: report1.]  
After report production, **report1** closes files, calls SYSTEM to print, and exits the program. [Seen in: report1.]

5.2 Initialization  
**init01** moves the program name to the header, converts the current date to UK format, sets screen exception flags, and initializes the print spool name and file key. [Seen in: init01.]  
**init01** then performs **report1** to start report generation. [Seen in: init01.]

5.3 Core Processing  
Path: Report Selection (User Input)  
Trigger: Accepting screen input.  
Key steps: display screen, accept input, validate status, credit, invoice, average, overdue, and enter‑date operators, validate date if provided.  
I/O: screen.  
Outcomes: sets criteria variables, may exit if enter‑date‑in blank.  
[Seen in: report-selection.]

Path: Report Produce (File Read) – FS‑Cobol Files Used  
Trigger: FS‑Cobol‑Files‑Used true.  
Key steps: open sales‑sort input, read records, filter by key and criteria, list matching records.  
I/O: sales‑sort file, print‑file.  
Outcomes: prints report lines, updates page count.  
[Seen in: report-produce.]

Path: Report Produce (RDB Path) – FS‑Cobol Files Not Used  
Trigger: FS‑Cobol‑Files‑Used false.  
Key steps: perform **Purch‑Read‑Next‑Sorted‑ByName** to get next record, filter by criteria, list.  
I/O: purchase table (via RDB), print‑file.  
Outcomes: prints report lines.  
[Seen in: report-produce.]

Path: Listing  
Trigger: record passes all criteria.  
Key steps: format fields into line‑6 and line‑7, write to print‑file.  
I/O: print‑file.  
Outcomes: output record to report.  
[Seen in: listing.]

Path: Test‑Num  
Trigger: called from report‑produce when a numeric filter is present.  
Key steps: compare test‑1 and test‑2 based on operator, set truth flag.  
I/O: none.  
Outcomes: truth flag indicates whether record passes filter.  
[Seen in: test-num.]

Path: End‑Report  
Trigger: end of file or exit.  
Key steps: close files, exit.  
I/O: print‑file, sales‑sort.  
Outcomes: program termination.  
[Seen in: end-report.]

5.4 Termination  
**report1** closes print‑file, optionally closes sales‑sort if used, and calls SYSTEM to print the report. [Seen in: report1.]  
The program then exits via the **main‑exit** section. [Seen in: main-exit.]

---
## pl165
*[158/267]*

### Business/Functional Perspective
### Supplier Index Generation  

**Program Purpose**  
This program creates a sorted index of supplier keys from the purchase ledger. By arranging the keys alphabetically by supplier name, it provides a quick reference that can be used by other reporting or processing routines. The sorted index supports efficient look‑ups and helps ensure consistency in supplier‑related reports.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the purchase file is unavailable or unreadable, the program stops and reports a file‑access error.  
- If the output index file cannot be opened for writing, the program terminates with a write‑error notice.  
- On successful completion, an index file containing the sorted supplier keys is created with no further user interaction.  

**User Flow Summary**  
When invoked, the program opens the purchase ledger and reads each supplier record. It extracts the supplier key and name, then releases a temporary sort record. The built‑in sort routine arranges all records alphabetically by supplier name. Once sorting is finished, the program writes each sorted key to a new file named “suppsort.inx”. The resulting file is a simple list of supplier keys in alphabetical order, ready for use by downstream processes or reports.  

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow
The program begins in the init01 section, performing a check on FS-Cobol-Files-Used and opening the purchase input file and the sales-sort output file. [Seen in: init01 section.]  
It then initiates a sort operation on the sort-file, specifying input and output procedures for processing each record. [Seen in: init01 section.]  
The input procedure reads purchase records, moves key fields into the sort record, and releases the record to the sort file, while the output procedure writes sorted keys to the sales-sort file. [Seen in: input-to-sort section, output-from-sort section.]

5.2 Initialization
The init01 section checks the FS-Cobol-Files-Used flag; if false, it returns with status 4. [Seen in: init01 section.]  
It performs Purch-Open-Input to open the purchase file, opens the sales-sort file for output, and then calls the SORT statement to process the data. [Seen in: init01 section.]

5.3 Core Processing
Path: Early Exit  
Trigger: FS-Cobol-Files-Used false in init01.  
Key steps: goback returning 4.  
I/O: none.  
Outcomes: program terminates with status 4.  
[Seen in: init01 section.]

Path: Sort Purchase Records  
Trigger: SORT statement in init01.  
Key steps: open files, invoke SORT, read purchase records, write to sort-file, read sorted records, write to sales-sort file.  
I/O: purchase-file, sort-file, sales-sort file.  
Outcomes: sales-sort file populated; sort-file closed.  
[Seen in: init01 section, input-to-sort section, output-from-sort section.]

Path: Input-To-Sort Loop  
Trigger: Each iteration of input-to-sort section.  
Key steps: perform Purch-Read-Next, check fs-reply, move key fields, release sort-record, loop.  
I/O: purchase-file, sort-file.  
Outcomes: records added to sort-file.  
[Seen in: input-to-sort section.]

Path: Output-From-Sort Loop  
Trigger: Each iteration of output-from-sort section.  
Key steps: return sort-file at end check, move sort-key to sales-sort-key, write sales-sort-record, loop.  
I/O: sort-file, sales-sort file.  
Outcomes: sorted records written to sales-sort file.  
[Seen in: output-from-sort section.]

5.4 Termination
After the sort completes, the program closes the sales-sort file and performs Purch-Close to close the purchase file. [Seen in: init01 section.]  
Finally, the program exits via the exit program statement, returning control to the caller. [Seen in: init01 section.]

---
## pl170
*[159/267]*

### Business/Functional Perspective
### Purchase Ledger Turnover Report  

**Program Purpose**  
This program generates a supplier turnover report that helps finance and purchasing staff assess the purchasing activity and credit standing of suppliers. Users can filter the report by supplier number, status (live, dormant or all), credit period, order activity, average order value, overdue accounts, and the date the supplier record was entered. The resulting report provides key information such as account numbers, names, credit limits, current balances, quarterly turnover, and recent invoice or payment dates, enabling managers to identify high‑turnover suppliers, monitor credit risk, and support decision‑making for credit policy and supplier management.  

**Screen Interactions**  
1. **Supplier File – Report Attributes**  
   - Prompt for **Supplier Number** (wildcard positions allowed).  
   - Prompt for **Status**: <L> Live, <D> Dormant, or blank for all.  
   - Prompt for **Credit Period**: enter number of days and choose operator <L>, <G>, or <E>.  
   - Prompt for **Order Activity**: enter number of orders and choose operator <L>, <G>, or <E>.  
   - Prompt for **Average Value**: enter amount and choose operator <L>, <G>, or <E>.  
   - Prompt for **Overdue A/Cs**: enter number of days and choose operator <L>, <G>, or <E>.  
   - Prompt for **Date Entered**: enter a date and choose operator <L>, <G>, or <E>.  
   The screen accepts alphanumeric input; the user can leave any field blank to include all values for that criterion.  

**Messages and Errors**  
- If the date entered is not in a recognised format, the program displays a simple “Invalid Date” message and returns to the prompt.  
- Invalid operator entries (characters other than L, G, E, or space) cause the screen to be re‑displayed for correction.  
- If no suppliers match the supplied criteria, the program completes without printing any supplier lines, producing only the page headings.  
- Successful operation results in a printed or spool‑output report that lists all suppliers meeting the criteria.  

**User Flow Summary**  
The user launches the report program. A screen appears prompting for filter criteria: supplier number (or a wildcard), status, credit period, order activity, average value, overdue accounts, and date entered. The user enters the desired values and presses ENTER. The program validates the date format, then scans the purchase ledger applying each filter. For each matching supplier, it prints a line containing the account number, name, credit terms, credit limit, activity count, average order value, quarterly turnover figures, current balance, last invoice date, and last payment date. Page headings are inserted automatically, and the report is sent to the printer or spool. When the scan completes, the program exits back to the calling environment.  

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** section, where it initializes variables, sets screen exception handling, opens the purchase and print files, and then proceeds to the report selection phase. [Seen in: init01]  
After user input is collected in **report-selection**, the program enters the **produce-report** section, which generates the report by reading purchase records, applying filters, and writing formatted output to the print file. [Seen in: produce-report]  
Upon completion of the report generation, the program closes the files, invokes the system print routine, and exits cleanly. [Seen in: menu-exit]

5.2 Initialization  
The **init01** section moves program identifiers to header fields, converts the current date to the appropriate format, and sets environment variables for screen exceptions. [Seen in: init01]  
It then opens the purchase input file via **Purch-Open-Input**, opens the print output file, and calls **report-selection** to gather user criteria before proceeding to report production. [Seen in: init01]

5.3 Core Processing  
Path: Report Selection  
Trigger: User acceptance of screen input.  
Key steps: Display the selection screen, accept data, validate the entered date, and set selection criteria variables.  
I/O: Screen (display/accept).  
Outcomes: Populates filter variables (cust-in, status-in, credit-op, etc.) and sets ws-enter-date if a date is provided.  
[Seen in: report-selection]

Path: Produce Report  
Trigger: Completion of report-selection.  
Key steps: Initialize counters, write initial headings, and enter the main **read-loop** to process purchase records.  
I/O: Purchase file read, print file write.  
Outcomes: Generates the full report, updates page and line counters, and writes headers as needed.  
[Seen in: produce-report]

Path: Read Loop  
Trigger: Each iteration of the main loop in produce-report.  
Key steps: Read next purchase record, apply status, supplier, credit, invoice, average, overdue, and enter-date filters; call **test-num** for numeric comparisons; if all tests pass, call **listing** to output the record.  
I/O: Purchase file read, print file write.  
Outcomes: Records that satisfy all criteria are printed; loop continues until end of file.  
[Seen in: read-loop]

Path: Test-Num  
Trigger: Called from read-loop when a numeric filter is present.  
Key steps: Convert operator to upper case, evaluate the comparison between test-1 and test-2, and set the truth flag accordingly.  
I/O: None.  
Outcomes: truth flag determines whether the record is skipped or processed.  
[Seen in: test-num]

Path: Headings  
Trigger: At report start and when the page line count exceeds Page-Lines.  
Key steps: Increment page counter, write header lines (line-1 to line-4), and reset line counter.  
I/O: Print file write.  
Outcomes: Page header is printed and line counter reset.  
[Seen in: headings]

Path: Listing  
Trigger: After a record passes all filters in read-loop.  
Key steps: Format purchase data into line-5 fields, convert dates, and write the record to the print file.  
I/O: Print file write.  
Outcomes: A formatted report line is output; line counter is incremented.  
[Seen in: listing]

5.4 Termination  
The program closes the print file, calls the system print routine via **SYSTEM**, and then exits the program through **menu-exit**. [Seen in: menu-exit]  
All open files are closed and any remaining resources are released before the program terminates. [Seen in: menu-exit]

---
## pl180
*[160/267]*

### Business/Functional Perspective
### Transaction Sub‑System Menu  

**Program Purpose**  
The program gives users a simple menu for managing transaction data.  It allows the user to update fixed transaction details or to launch the recurring transaction processor.  The system makes sure the transaction reference (folio) and, when required, the VAT account are supplied correctly and confirms the entry before it is recorded.  By enforcing these steps the accounting data remains accurate, compliant, and ready for reporting.  

**Screen Interactions**  

1. **Transaction Sub‑System Menu** – Shows the program name, the current date, and the options:  
   - (1) Amend Transactions Fixed Data  
   - (9) Recurring Transaction Processing  
   - (X) Return to System Menu.  
   The user enters a choice in the input field at the bottom of the screen.  

2. **Transaction Fixed Data Screen** – Displays the program name, the current date, and prompts:  
   - “Next Folio” – the user types the next transaction number.  
   - If the system requires it, “Vat Account” – the user types the VAT account number.  
   - “Details ok to file (Y/N)” – the user confirms the entry.  
   A warning message informs the user that the VAT account is not automatically verified against the chart of accounts.  

**Messages and Errors**  

- If the user enters a folio number of zero, the screen repeats the folio prompt.  
- If the user selects “N” at the confirmation prompt, the data entry screen is shown again so the information can be corrected.  
- If the confirmation input is not “Y”, the user is asked again until a valid “Y” is supplied.  
- A warning is displayed when a VAT account is requested but not checked against the accounting plan.  

**User Flow Summary**  
A user starts the program and is presented with the Transaction Sub‑System Menu.  Choosing option 1 takes them to the Transaction Fixed Data screen where they enter the next folio number, provide a VAT account if prompted, and then confirm the entry.  If they confirm, the data is accepted and the menu returns.  Choosing option 9 initiates the recurring transaction processor by transferring control to another program; the user is returned to the menu when that process completes.  Selecting X returns the user to the higher‑level system menu.  

**Program Linkages**  

- pl800   (called when the user selects option 9)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the procedure division, performing the init01 section to set up caller links and, if Next‑Folio is zero, immediately invoke the Fixed‑Data section. [Seen in: init01 section.]  
After initialization, the menu is displayed (Menu‑Return) and user input is accepted (Menu‑Input); the reply determines whether to run Fixed‑Data, invoke another program via loadit, or exit. [Seen in: Menu‑Return, Menu‑Input.]  
Upon completion of the selected action, control returns to the menu display loop until the user chooses the exit option, which triggers Menu‑Exit and a GOBACK to terminate. [Seen in: Menu‑Exit, menu‑Ex.]

5.2 Initialization  
The init01 section copies the caller and called identifiers to temporary links and checks the Next‑Folio value; if it is zero, Fixed‑Data is performed immediately. [Seen in: init01 section.]  
No external files are opened during initialization; the program relies solely on screen I/O and the linkage section for data transfer. [Seen in: init01 section.]

5.3 Core Processing  
Path: Fixed‑Data  
Trigger: menu‑Reply = "1" or init01 section when Next‑Folio = zero  
Key steps: display prompts for Next‑Folio and VAT account, loop in Data‑Entry to obtain valid Next‑Folio, optionally prompt for VAT account if G‑L flag is set, then ask for confirmation before exiting.  
I/O: screen display and accept statements only (no files).  
Outcomes: sets Next‑Folio and vat‑ac in working storage; returns to menu.  
[Seen in: Fixed‑Data section, Data‑Entry, Confirmation, Main‑Exit.]  

Path: loadit  
Trigger: menu‑Reply = "9"  
Key steps: set WS‑called to "pl800" and perform a call to that program, then return to the menu.  
I/O: call to external program via WS‑called; no file I/O.  
Outcomes: control passes to pl800 and upon return, the menu is redisplayed.  
[Seen in: Menu‑Input, loadit.]  

Path: Menu‑Exit  
Trigger: menu‑Reply = "X" or after loadit returns to Menu‑Return and user selects exit.  
Key steps: restore caller/called links, then execute GOBACK to terminate the program.  
I/O: none.  
Outcomes: program exits to the calling environment.  
[Seen in: Menu‑Exit, menu‑Ex.]

5.4 Termination  
When the user selects the exit option, Menu‑Exit restores the caller/called linkage and performs a GOBACK, ending the program. [Seen in: Menu‑Exit, menu‑Ex.]  
No additional cleanup is performed beyond the GOBACK; all screen state is cleared by the final display statements. [Seen in: menu‑Ex.]

---
## pl190
*[161/267]*

### Business/Functional Perspective
### Purchase Ledger Dump  

**Program Purpose**  
The program creates a printed report of supplier ledger records that match user‑specified criteria. It allows a user to filter by supplier number, status (live, dormant, or all), credit period, invoice activity, average order value, and overdue days. The resulting report provides detailed supplier information—including credit terms, balances, and activity dates—helping accountants verify supplier standing, monitor outstanding amounts, and support audit trails.

**Screen Interactions**  
1. **Title** – “Supplier File” appears at the top of the screen.  
2. **Date** – The current system date is shown beside the title.  
3. **Report Attributes** – A header indicating that the following fields are report criteria.  
4. **Supplier Number** – User may enter up to six characters to match supplier keys.  
5. **Status** – A single character field; options: `<L>` Live, `<D>` Dormant, or blank for all.  
6. **Credit Period** – Two fields: a two‑digit number of days and an operator field (`<L>`, `<G>`, `<E>`, or blank).  
7. **Invoice Activity** – Two fields: a five‑digit number of orders and an operator field (`<L>`, `<G>`, `<E>`, or blank).  
8. **Average Value** – Two fields: a five‑digit monetary amount and an operator field (`<L>`, `<G>`, `<E>`, or blank).  
9. **Overdue A/Cs** – Two fields: a five‑digit number of days overdue and an operator field (`<L>`, `<G>`, `<E>`, or blank).  
10. **Input Prompt** – Instructions guiding the user on how to enter values and operators.  
11. **Accept** – After all fields are entered, the user accepts the screen; the program validates the inputs and then generates the report.  

**Messages and Errors**  
- If the user enters an invalid operator or status, the program re‑prompts for correct input.  
- After processing, if no supplier records match the criteria, the report is not generated and the screen simply returns to the input prompt.  
- When records are found, a printed report is sent to the spool; the user is not notified of success, but the absence of a report indicates no matches.  

**User Flow Summary**  
1. The user launches the program and is presented with a screen of filter fields.  
2. The user enters desired values for supplier number, status, credit days, invoice count, average value, and overdue days, using the specified operators (`<`, `>`, or `=`).  
3. Upon acceptance, the program validates the input, opens the purchase ledger file, and scans records applying the entered filters.  
4. For each matching record, the program writes supplier details (key, name, credit terms, balances, activity dates, contact information, and turnover data) to the print spool.  
5. If at least one record is written, the spool is executed; otherwise, no report is produced.  
6. The program then closes the ledger file and exits, returning control to the caller.  

**Program Linkages**  
- maps04  
- SYSTEM  
- Purch-Open-Input  
- Purch-Read-Indexed  
- Purch-Read-Next  
- Purch-Close

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in init01 which sets up screen, date conversion, environment flags and then performs report-1. [Seen in: init01.]  
report-1 performs report-selection to gather user criteria, report-heading-setup to build the report header, and produce-report to generate the output. [Seen in: report-1.]  
produce-report opens the print file, iterates through the purchase file applying the selection filters, writes each matching record to the print file, and finally closes the file and triggers the print spooler if records were produced. [Seen in: produce-report.]

5.2 Initialization  
init01 moves program metadata to the screen, converts the current date to the system date format, sets screen exception handling, and initializes the print spool name and file key. [Seen in: init01.]  
It then calls report-1 to begin the report generation sequence. [Seen in: init01.]

5.3 Core Processing  
Path: Report Selection  
Trigger: Entry into report-selection paragraph.  
Key steps: Open purchase file, clear selection variables, display screen, accept user input, validate status and operator fields, loop until valid.  
I/O: purchase file (input), screen.  
Outcomes: Supplier-in, status-in, credit-in, etc. set for later.  
[Seen in: report-selection.]

Path: Report Heading Setup  
Trigger: Entry into report-heading-setup paragraph.  
Key steps: Build l3-report string based on selection criteria.  
I/O: none.  
Outcomes: l3-report used in report heading.  
[Seen in: report-heading-setup.]

Path: Produce Report (Read Loop)  
Trigger: Entry into produce-report paragraph.  
Key steps: Open print file, initialize counters, if specific supplier key then read indexed else loop reading next; apply status, supplier key, array, numeric filters; call listing for each record; loop until end of file.  
I/O: purchase file (input), print-file (output).  
Outcomes: records written, Rec-Cnt incremented, print file closed, spool called if records exist.  
[Seen in: produce-report, read-loop, listing, end-report.]

Path: Date Conversion (zz070-Convert-Date)  
Trigger: Call to zz070-Convert-Date during init01.  
Key steps: Convert to-day to ws-date, adjust for date format (UK, USA, International).  
I/O: none.  
Outcomes: ws-date set for display.  
[Seen in: zz070-Convert-Date.]

Path: Date Conversion (zz060-Convert-Date)  
Trigger: Call to zz060-Convert-Date during listing when converting binary dates to display.  
Key steps: Convert u-bin to ws-date, adjust format.  
I/O: none.  
Outcomes: ws-date set for display of dates.  
[Seen in: zz060-Convert-Date.]

5.4 Termination  
After closing the print file and purchase file, the program calls the operating system print routine if any records were printed. [Seen in: end-report.]  
The program then exits via the menu-exit paragraph, returning control to the caller. [Seen in: menu-exit.]

---
## pl800
*[162/267]*

### Business/Functional Perspective
### Recurring Invoice Menu  

**Program Purpose**  
The program presents a menu for managing recurring (auto‑generated) invoices. It displays the current date, a list of options for entering or amending invoices, proofing them, or posting them, and indicates that the feature is not yet available. The menu is intended to guide the user toward the system menu once the required functionality has been implemented, ensuring a consistent entry point for future invoice processing.  

**Screen Interactions**  
1. **Title Screen** – Shows “Recurring (Autogen) Purchase Invoicing Menu” with the current date displayed.  
2. **Options Prompt** – Displays a numbered list:  
   - (1) Enter / Amend Recurring Invoice  
   - (2) Proof Recurring Invoicing  
   - (3) Post Recurring Invoices  
   - (X) Return To System menu  
3. **Status Notice** – A highlighted block of text informs the user that recurring transactions/invoices/purchase orders have not yet been written and are awaiting sales testing. It encourages pressing Return to return to the system menu.  
4. **Input Field** – The user enters a single character (1, 2, 3, or X) to choose an action.  

**Messages and Errors**  
- The program does not validate the entered choice beyond recognizing “X”; selecting 1, 2, or 3 simply returns to the menu without performing any action.  
- Pressing “X” or Return exits to the system menu.  
- No additional error messages or prompts are provided.  

**User Flow Summary**  
When a user launches the program, they are presented with a menu that lists the available recurring‑invoice options and a clear note that the feature is not yet implemented. The user can type a number (1, 2, or 3) but the program will ignore the request and redisplay the menu. Choosing “X” or pressing Return exits the menu, returning the user to the main system interface. This flow ensures that the user is aware of the current development status while maintaining a simple, predictable exit path.  

**Program Linkages**  
- Dynamic: ws-called

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program initializes screen exception handling, converts the current date to the appropriate format, and displays the recurring invoice menu. [Seen in: Init01 section.]  
It then waits for user input, accepting a menu selection and routing the choice to the appropriate subprogram via a dynamic call. [Seen in: Menu-Input.]  
After the subprogram completes, control returns to the main menu loop or exits to the system menu based on the selection, ultimately terminating the program. [Seen in: Menu-Exit.]

5.2 Initialization  
The Init01 section sets screen exception flags, performs date conversion, and initializes caller/called linkages. [Seen in: Init01 section.]  
It displays the program name, title, current date, and menu options on the screen. [Seen in: Menu-Return.]

5.3 Core Processing  
Path: Menu-Input  
Trigger: User enters a menu selection.  
Key steps: Accept input; if the reply is “X” go to Menu-Exit; otherwise return to Menu-Return.  
I/O: none.  
Outcomes: Sets Menu-Reply; may trigger program exit.  
[Seen in: Menu-Input.]

Path: Loadit  
Trigger: After Menu-Input when Menu-Reply is not “X”.  
Key steps: Call the subprogram specified in ws-called with the current parameters; if Menu-Reply equals 1 go to Menu-Exit, else go to Menu-Return.  
I/O: ws-called, system-record, to-day, file-defs.  
Outcomes: Executes subprogram logic; may cause exit or return to menu.  
[Seen in: Loadit.]

Path: Menu-Exit  
Trigger: User selects “X” or subprogram returns with Menu-Reply = 1.  
Key steps: Set pass-value to zero, reset ws-called to ws-caller, reset ws-caller to ws-del-link.  
I/O: none.  
Outcomes: Prepares for program termination.  
[Seen in: Menu-Exit.]

Path: zz070-Convert-Date  
Trigger: Performed during program initialization.  
Key steps: Move to-day to ws-date; adjust format based on Date-Form; swap month/day for USA format; set international format if needed.  
I/O: none.  
Outcomes: Sets ws-date to the correct display format.  
[Seen in: zz070-Convert-Date.]

Path: Menu-Ex  
Trigger: After Menu-Exit.  
Key steps: Exit the program.  
I/O: none.  
Outcomes: Program terminates.  
[Seen in: Menu-Ex.]

5.4 Termination  
The Menu-Ex paragraph exits the program, concluding the recurring invoice processing session. [Seen in: Menu-Ex.]  
Prior to exit, Menu-Exit resets the caller/called linkage and clears the pass-value to indicate normal termination. [Seen in: Menu-Exit.]

---
## pl900
*[163/267]*

### Business/Functional Perspective
### Payment Menu Navigation  

**Program Purpose**  
The program presents the main payment‑management menu to staff. It shows the current date, lists six payment options and an exit choice, and routes the user to the appropriate sub‑program. The menu supports quick access to generating, amending, proving, and printing payment records, helping users keep payment processing streamlined and accurate.  

**Screen Interactions**  
1. **Payment Menu screen** –  
   *Title:* “Payment Menu” displayed prominently.  
   *Date display:* The current date (formatted for UK, USA or international use).  
   *Options:*  
   - (1) Generate Payments to be made  
   - (2) Amend Payments  
   - (3) Proof Payments  
   - (4) Generate Payments  
   - (5) Print Payment Register  
   - (6) Print Remittance Advices  
   - (X) Return to System Menu  
   *Input field:* A single character or number entered at the “Select one of the following by number :- [ ]” prompt.  

**Messages and Errors**  
The program only accepts a valid menu selection. If an invalid entry is entered, the menu simply re‑displays and asks for input again. There are no explicit error messages or alerts shown to the user.  

**User Flow Summary**  
When launched, the system displays the current date and the payment menu. The user types a number 1‑6 or “X” and presses Enter. If “X” is chosen, the program exits back to the main system menu. For selections 1‑6, the program calls the corresponding sub‑program (pl910‑pl960) to perform the requested payment operation and then returns to the main menu for further actions.  

**Program Linkages**  
- pl910  
- pl920  
- pl930  
- pl940  
- pl950  
- pl960  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by moving caller linkage data, displays the menu header and current date, and shows the payment options. [Seen in: main, menu-start, zz070-Convert-Date.]  
User input is accepted; based on the reply, the program either exits or loads the appropriate subprogram. [Seen in: menu-input.]  
After the subprogram completes, control returns to the menu start to allow another selection or exit. [Seen in: loadit, menu-start.]

5.2 Initialization  
Entry point moves ws-caller to ws-del-link and ws-called to ws-caller to preserve caller linkage. [Seen in: main.]  
The menu-start paragraph initializes menu-reply to zero, displays program name and date, and shows the menu options. [Seen in: menu-start.]  
The date conversion section zz070-Convert-Date is performed to format the current date for display. [Seen in: zz070-Convert-Date.]  
No file or database opens occur in this file; subprograms handle I/O. [Seen in: N/A.]

5.3 Core Processing  
Path: Menu Exit  
Trigger: menu-reply equal "X"  
Key steps: set ws-called to ws-caller, set ws-del-link to ws-caller, exit program.  
I/O: none.  
Outcomes: program terminates.  
[Seen in: menu-input, menu-exit.]

Path: Generate Payments to be made  
Trigger: menu-reply equal 1  
Key steps: set ws-called to "pl910", call subprogram, return to menu-start.  
I/O: subprogram handles files.  
Outcomes: subprogram performs payment generation.  
[Seen in: menu-input, loadit.]

Path: Amend Payments  
Trigger: menu-reply equal 2  
Key steps: set ws-called to "pl920", call subprogram, return to menu-start.  
I/O: subprogram handles files.  
Outcomes: subprogram performs payment amendment.  
[Seen in: menu-input, loadit.]

Path: Proof Payments  
Trigger: menu-reply equal 3  
Key steps: set ws-called to "pl930", call subprogram, return to menu-start.  
I/O: subprogram handles files.  
Outcomes: subprogram performs payment proof.  
[Seen in: menu-input, loadit.]

Path: Generate Payments  
Trigger: menu-reply equal 4  
Key steps: set ws-called to "pl940", call subprogram, return to menu-start.  
I/O: subprogram handles files.  
Outcomes: subprogram generates payments.  
[Seen in: menu-input, loadit.]

Path: Print Payment Register  
Trigger: menu-reply equal 5  
Key steps: set ws-called to "pl950", call subprogram, return to menu-start.  
I/O: subprogram handles files.  
Outcomes: subprogram prints register.  
[Seen in: menu-input, loadit.]

Path: Print Remittance Advices  
Trigger: menu-reply equal 6  
Key steps: set ws-called to "pl960", call subprogram, return to menu-start.  
I/O: subprogram handles files.  
Outcomes: subprogram prints advices.  
[Seen in: menu-input, loadit.]

Path: Date Conversion  
Trigger: performed at menu-start.  
Key steps: move to-day to ws-date, adjust format based on Date-Form, swap days/month for USA, or set Intl format.  
I/O: none.  
Outcomes: ws-date formatted for display.  
[Seen in: zz070-Convert-Date.]

5.4 Termination  
On exit, program restores caller linkage and exits via exit program. [Seen in: menu-exit.]  
No additional cleanup is performed in this file. [Seen in: N/A.]

---
## pl910
*[164/267]*

### Business/Functional Perspective
### Payments Due Reporting  

**Program Purpose**  
This program creates a payments‑due report that lists all suppliers, invoices, and amounts outstanding up to a specified cut‑off date. It shows the current age of each invoice and aggregates amounts in 0‑day, 30‑day, 60‑day, 90‑day, and total columns. The report supports accounts‑payable staff in prioritising payments, verifying discounts, and managing cash flow.  

**Screen Interactions**  
1. **Initial screen** – Displays the title “Payments Due Reporting”, the current system date, the user‑supplied “Age‑To‑Pay” value, and a Y/N prompt to confirm the age value.  
2. **Confirmation input** – The user enters Y or N. If N, the user can re‑enter a new Age‑To‑Pay value.  
3. **Report screen** – After confirmation, the program shows a formatted report with headings, supplier names, invoice numbers, dates, amounts in each ageing bucket, and a total payable amount. The report is printed via a spool command, but the user can also view the printed output.  

**Messages and Errors**  
- *Logic error*: If the program encounters an unexpected condition, it displays a notice and pauses for the user to acknowledge.  
- *Ledger file missing*: The user is informed that the purchase ledger could not be located.  
- *Open‑Item file missing*: The user is notified that the Open‑Item file could not be opened.  
- *Payment file error*: The user is alerted that the payment file could not be created or accessed.  
- *General note*: For any of the above errors, a brief message appears and the user must press return to exit.  

**User Flow Summary**  
The user runs the program and is presented with a screen showing the current date and a field for “Age‑To‑Pay”. After confirming the age value, the program processes all purchase records and open‑item records up to the cut‑off date. It calculates how much each supplier owes in the current, 30‑, 60‑, and 90‑day buckets, applies any discount logic, and aggregates totals. A formatted payments‑due report is displayed and printed. The user reviews the report, which includes the total amount payable, and then exits the program.  

**Program Linkages**  
- maps04  
- SYSTEM   (used for printing the report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init section**, displaying prompts, converting dates, and invoking **Payment-Gen**. [Seen in: init section.]  
**Payment-Gen** opens the purchase, open‑item, and print files, then iterates through purchase records, reads related open‑item records, calculates amounts, writes report lines and payment records, and finally writes totals. [Seen in: Payment-Gen.]  
After processing, the program writes the final totals, closes all files, calls the operating‑system print routine, and exits via **Main-Exit**. [Seen in: Main-Exit.]

5.2 Initialization  
The **init section** sets screen exception flags, displays the program name and current date, prompts for the age‑to‑pay value, and converts the current date to UK format. [Seen in: init section.]  
It then subtracts the age‑to‑pay from the run date to determine the “to‑be‑paid” cutoff, converts that binary date to a string, and calls **Payment-Gen** to start report generation. [Seen in: init section.]

5.3 Core Processing  

Path: Payment-Gen  
Trigger: called from **init section** after date conversion.  
Key steps: open purchase, open‑item, and print files; write headings; loop over purchase records; for each purchase, read related open‑item records, filter by status and date, compute invoice amounts, apply discounts, age invoices, accumulate balances, write report line‑5, and write payment records when a supplier’s items are finished.  
I/O: purchase-file, open-item-file‑5, print-file, pay-file.  
Outcomes: report lines and payment records are written; totals and balances are accumulated; page headers are written via **Headings**.  
[Seen in: Payment-Gen, Headings, zz050-Validate-Date, zz060-Convert-Date.]

Path: Main-End  
Trigger: reached when the purchase‑read loop ends (label **main-end**).  
Key steps: write totals line‑6 and line‑7, close print, open‑item, purchase, and pay files, and invoke the system print routine.  
I/O: print-file, open-item-file‑5, purchase-file, pay-file.  
Outcomes: final totals are output, all files are closed, and the report is sent to the printer.  
[Seen in: Main-End, Main-Exit.]

Path: Headings  
Trigger: invoked by **Payment-Gen** at start and whenever the page line count exceeds the page‑lines limit.  
Key steps: increment page counter, write header lines (line‑1, line‑2, line‑4), and reset line counter.  
I/O: print-file.  
Outcomes: a new page header is printed.  
[Seen in: Headings.]

Path: zz050-Validate-Date  
Trigger: called from **init section** to convert the input date string to UK format.  
Key steps: set date format, adjust for USA or international formats, call **maps04** for validation, and set **ws-date**.  
I/O: none.  
Outcomes: **ws-date** contains a validated UK‑formatted date.  
[Seen in: zz050-Validate-Date, maps04.]

Path: zz060-Convert-Date  
Trigger: called from **init section** after computing the “to‑be‑paid” binary date.  
Key steps: call **maps04**, convert binary date to string, adjust for date format, and set **ws-date**.  
I/O: none.  
Outcomes: **ws-date** holds the string representation of the binary date.  
[Seen in: zz060-Convert-Date, maps04.]

5.4 Termination  
The program writes the final totals, closes all open files, calls the operating‑system print routine, and exits via **Main-Exit**. [Seen in: Main-Exit.]  
The **Main-Exit** section performs a clean exit of the program. [Seen in: Main-Exit.]

---
## pl920
*[165/267]*

### Business/Functional Perspective
### Payment Due Amendment  

**Program Purpose**  
The program lets finance staff modify the amounts recorded on a supplier’s payment file. By selecting a supplier and payment number, the user can review each line item, adjust individual values, and recalculate the total payable amount. This ensures the payment ledger remains accurate, supports timely cash‑flow planning, and keeps the system compliant with accounting standards.  

**Screen Interactions**  
1. **Header** – Displays “Payment Due Amendment” and the current date at the top of the screen.  
2. **Supplier and Payment Entry** – Prompts the user to enter a supplier key followed by a payment number. After a successful lookup, the screen lists up to nine line items, each showing the folio number, current value, and invoice number.  
3. **Amount Adjustment Prompt** – Shows the gross amount for the payment and asks for the line number the user wishes to change. If “0” is entered, the program exits the adjustment loop.  
4. **Money Entry Screen** – Lets the user input a new amount for the selected line in pounds and pence. The updated line value and revised gross amount are displayed and the user can repeat the process for additional lines.  

**Messages and Errors**  
- If a supplier key or payment number does not exist, the program re‑prompts the user for new input.  
- Choosing a line number that has no amount or entering an invalid number causes the program to ask again for a valid selection.  
- After successfully writing the updated payment record, the program returns to the supplier entry prompt for another operation or exits when the user enters 0 for the line number.  

**User Flow Summary**  
A user starts the program and sees a heading with the current date. They are asked to enter a supplier identifier and then a payment number. The system retrieves the payment record and displays its nine line items. The user selects a line to modify, enters the new amount, and the program updates the line value and gross total. The user may continue adjusting other lines, and when finished, enters “0” to exit the adjustment loop. The program writes the revised payment back to the file and returns to the supplier prompt, ready for another transaction.  

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init section**, displaying the title and converting the current date before setting a file key and invoking the payment amendment routine. [Seen in: init section.]  
The **Payment‑Amend section** opens the purchase and payment files, prompts the user for a supplier key, reads the corresponding payment record, displays payment details, allows the user to modify amounts, rewrites the record, and then loops back to accept another key. [Seen in: Payment‑Amend section.]  
After the amendment routine completes, the **init section** closes the purchase and payment files and exits the program. [Seen in: init section.]

5.2 Initialization  
The **init section** displays the program name and title, performs a date conversion to the appropriate format, displays the formatted date, and sets the file key number for subsequent file operations. [Seen in: init section.]  
It then performs the **Payment‑Amend** routine followed by closing procedures for the purchase and payment files. [Seen in: init section.]

5.3 Core Processing  
Path: Payment Amendment  
Trigger: init section performs **Payment‑Amend**.  
Key steps: open purchase and payment files; display supplier prompt; accept supplier key; read payment record (Payments‑Read‑Indexed); read purchase record (Purch‑Read‑Indexed); display purchase name and payment details; loop to get change; accept new amounts via accept‑money/accept‑money2; rewrite payment record; loop back to get another key.  
I/O: purchase‑file, pay‑file.  
Outcomes: payment record updated, user can amend multiple records in a single session.  
[Seen in: Payment‑Amend section.]

Path: Date Conversion  
Trigger: init section performs **zz070‑Convert‑Date**.  
Key steps: move to‑day to ws‑date; set Date‑Form if zero; if Date‑UK, exit; if Date‑USA, swap month and day; otherwise set international format.  
I/O: ws‑date.  
Outcomes: ws‑date contains the date in the selected format for display.  
[Seen in: zz070‑Convert‑Date section.]

5.4 Termination  
The **init section** calls **Purch‑Close** and **Payments‑Close** to close the purchase and payment files before exiting. [Seen in: init section.]  
Program exit is performed via the **menu‑exit** paragraph (or **main‑exit** within Payment‑Amend) which issues a GOBACK to terminate the program. [Seen in: menu‑exit, main‑exit.]

---
## pl930
*[166/267]*

### Business/Functional Perspective
### Payments Due Proof Report  

**Program Purpose**  
This program generates a printable report that lists all outstanding payments for each supplier. For every supplier it shows the folio number, invoice reference, payment method, the due date, and the amounts due in the current period and in the 30‑, 60‑ and 90‑day aging buckets. Totals for each bucket and a grand total are also displayed. The report supports finance teams in reviewing overdue amounts, planning cash flow, and verifying compliance with payment terms.  

**Screen Interactions**  
1. **Startup Screen** – When launched, the program prints the following to the terminal:  
   - Program name and version (`PL930 (3.02.09)`).  
   - Report title “Payments Due Proof Report”.  
   - Current date in the selected format.  
   No other user input or prompts are displayed.  

**Messages and Errors**  
- **No Payment Data** – If no payment records are found, the program finishes silently, producing an empty report.  
- **File Access Issues** – If a required file (purchase, payment, or print) cannot be opened or read, the program stops and exits, leaving the spool file unchanged.  
- **General Completion** – Upon successful processing, the report is sent to the print spool and the program terminates normally.  

**User Flow Summary**  
A user runs the program (typically from a batch job). The terminal shows a brief header with the program name, title, and date. The program then reads all purchase and payment records, aggregates amounts due by aging bucket for each supplier, and writes a formatted report to the print spool. Each page begins with a heading that includes the page number and date, followed by a list of suppliers with their outstanding balances. At the bottom of the report, subtotals for the 0‑, 30‑, 60‑, and 90‑day buckets and a grand total are printed. Once the report is generated, the program closes all files, sends the print command, and exits.  

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by executing the **init-process** section, which displays header information, converts the current date, and opens the purchase, payments, and print files. [Seen in: init-process section.]  
It then enters the **read-purchase** loop, reading payment records sequentially, retrieving associated purchase data, and preparing data for printing. [Seen in: read-purchase.]  
For each payment record, the program iterates through its payment values, formats the output lines, manages page headers, and accumulates totals before writing a summary and terminating. [Seen in: print-loop, main-end.]

5.2 Initialization  
The **init-process** section displays the program name and title, converts the system date to the configured format, and sets up file keys and screen variables. [Seen in: init-process section.]  
It opens the purchase and payments input files, opens the print output file, and writes the initial page headings. [Seen in: init-process section, headings section.]

5.3 Core Processing  
Path: **System Setup**  
Trigger: Program start.  
Key steps: display header, convert date, set file key, open files, write headings.  
I/O: purchase file, payments file, print file.  
Outcomes: files opened, initial page ready.  
[Seen in: init-process section, headings section.]

Path: **Read-Purchase Loop**  
Trigger: Payments-Read-Next returns fs-reply not 10.  
Key steps: read payment record, check end, skip-pay-read, set key, read purchase record, handle missing key, prepare supplier data.  
I/O: payments file, purchase file.  
Outcomes: payment record loaded, purchase data available, line counter updated.  
[Seen in: read-purchase, skip-pay-read.]

Path: **Print-Loop**  
Trigger: payment record loaded and z index less than 10.  
Key steps: for each payment value, determine method, set invoice, folio, convert date, assign balances per period, accumulate totals, write line-5, manage page count, reset balances.  
I/O: print file.  
Outcomes: lines printed, totals updated, page count managed.  
[Seen in: print-loop.]

Path: **Process-Continuation**  
Trigger: after finishing all payment values for a supplier and pay-cont = "C".  
Key steps: read next payment record, if end add remaining balance to totals and go to main-end; if key unchanged go to print-loop.  
I/O: payments file.  
Outcomes: next payment processed or termination.  
[Seen in: process-cont.]

Path: **Termination**  
Trigger: end of payments file or after processing all records.  
Key steps: write totals lines, close files, call system print, exit program.  
I/O: print file, purchase file, payments file.  
Outcomes: report finalized, resources released.  
[Seen in: main-end.]

5.4 Termination  
The **main-end** section writes the final totals to the print file, closes all open files, and invokes the external print routine before exiting. [Seen in: main-end.]  
The program then exits cleanly with the exit program statement. [Seen in: main-end.]

---
## pl940
*[167/267]*

### Business/Functional Perspective
### Cheque File Generation  

**Program Purpose**  
The program creates a printable text file that contains all the necessary information for a batch of supplier payments. It gathers account, payee details, amount expressed in words and numerically, cheque or BACS indicator, payment date, and invoice references, then writes each record to an output file ready for printing or for upload to a banking system. The program validates dates, formats amounts correctly, and updates the original payment records with the chosen payment date, ensuring accurate, compliant, and auditable payment documentation.  

**Screen Interactions**  
1. **Title screen** – Displays “Cheque Print File Generation” and the current date.  
2. **First Cheque Number prompt** – “First Cheque number - [        ]” where the user enters the starting cheque number for the batch.  
3. **Payment Date prompt** – “Payment date        - [          ]” where the user enters the date to apply to all payments; the user may re-enter until a valid date is supplied.  

**Messages and Errors**  
- If no payment data is available or a file cannot be opened, the program displays “No data to process. Hit return” and stops.  
- If a particular payment record is missing required information, the program displays “Missing data” for that record.  
- If the entered payment date is not valid, the program prompts the user to re‑enter a correct date.  
- Once all records are processed, the program terminates normally.  

**User Flow Summary**  
When the user starts the program, they see a header with the title and the current date. They then supply the first cheque number to be used in the batch, followed by the payment date to apply to all payments. After confirming the date, the program automatically reads each pending payment record, formats the amount in words and numbers, assigns a cheque number or marks the record for BACS, writes a line to the output file, and updates the payment record with the chosen date. This loop continues until all payment records have been processed, after which the program closes its files and exits, leaving the output file ready for printing or bank submission.  

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the init section, displaying the program name, converting the current date, opening the purchase and payment files, and prompting the user for the first cheque number and payment date. [Seen in: init section.]  
It then enters a loop that reads each payment record, builds a cheque record, writes it to the cheque file, rewrites the payment record, and repeats until no more payments are available. [Seen in: read-purchase.]  
When the payment file is exhausted, the program closes all files and exits. [Seen in: main-end.]

5.2 Initialization  
The init section displays the program name and title, converts the system date to UK format, and opens the purchase and payment files for input and I/O respectively. [Seen in: init section.]  
If either file fails to open, an error message is displayed, the files are closed, and the program terminates. [Seen in: init section.]  
The cheque file is opened for output, and the user is prompted to enter the first cheque number and the desired payment date, which is then validated in a loop until a valid date is supplied. [Seen in: init section.]

5.3 Core Processing  
Path: Read‑Purchase Loop  
Trigger: Payments‑Read‑Next returns fs‑reply not equal to 10.  
Key steps: read a payment record, skip if pay‑gross < .01, read the related purchase record, build the cheque record fields (account, name, address, amount words, cheque number or BACS marker), write the cheque record, rewrite the payment record, and loop back to read the next payment.  
I/O: Payments file, Purchase file, Cheque file.  
Outcomes: cheque record written, payment record updated, loop continues until end of file.  
[Seen in: read-purchase.]

Path: Date Validation Loop  
Trigger: User enters a date that fails validation (u‑bin = zero).  
Key steps: accept date input, call zz050‑Validate‑Date, if u‑bin is zero repeat input.  
I/O: none.  
Outcomes: ws‑test‑date set to a valid UK‑formatted date.  
[Seen in: get-date.]

Path: Purchase Key Not Found  
Trigger: Purch‑Read‑Indexed returns fs‑reply = 21 or 23.  
Key steps: set purch‑name and purch‑address to PL902 error message.  
I/O: Purchase file.  
Outcomes: placeholder values used for account name and address in the cheque record.  
[Seen in: read-purchase.]

Path: BACS Path (pay‑sortcode non‑zero)  
Trigger: pay‑sortcode ≠ zero.  
Key steps: set pay‑cheque to zero and c‑cheque‑x to “BACS”.  
I/O: none.  
Outcomes: cheque record contains BACS marker instead of a sequential cheque number.  
[Seen in: read-purchase.]

Path: Cheque Number Path (pay‑sortcode zero)  
Trigger: pay‑sortcode = zero.  
Key steps: set c‑cheque and pay‑cheque to the current cheque number, then increment the cheque number.  
I/O: none.  
Outcomes: sequential cheque numbers written to the cheque file.  
[Seen in: read-purchase.]

5.4 Termination  
The program closes the cheque, purchase, and payment files, then exits the program. [Seen in: main-end.]

---
## pl950
*[168/267]*

### Business/Functional Perspective
### Cheque Register Report

**Program Purpose**  
The program produces a payment register that lists all bank‑to‑bank or cheque payments for a specified period. It gathers payment details, totals values, and updates internal accounting records, ensuring that the register reflects accurate and current payment information. The report supports audit trails, compliance checks, and financial reconciliation, thereby reducing risk of discrepancies in the accounting system.

**Screen Interactions**  
1. **Continuation Prompt** – The program displays:  
   *“Warning: Updating Open Item File. Do You Wish to Continue (YES/NO) [   ]”*  
   and waits for the user to enter **YES** or **NO**.  
2. **Report Output** – The register is printed to the designated print spool; no further user input is required during printing.

**Messages and Errors**  
- **Prompt Response** – If the user enters anything other than **YES** or **NO**, the prompt repeats until a valid response is given.  
- **Missing Record** – If a referenced purchase record cannot be found, the report notes “Record Missing” next to the affected line.  
- **Logic Error** – Unexpected conditions during open‑item processing trigger a message such as “PE 950‑01 Logic” or “PE 950‑02 Logic,” after which the user is asked to press Return to continue.  
- **Posting Failure** – If a posting write to the batch file fails, the program displays a general error and halts, allowing the user to review the issue.  
- **General Exception** – Any other unexpected error results in a concise note and pause for user acknowledgement.

**User Flow Summary**  
1. The user runs the program and is asked whether to proceed with updating the Open Item file.  
2. Upon confirming **YES**, the program reads the payment and purchase files, compiles each payment’s cheque number, bank details, payee name, and value, and writes these entries to the report.  
3. It calculates a running total of all payment values and includes a grand total line at the end of the report.  
4. After printing, the program updates open‑item records, writes necessary postings, and adjusts deduction and value tables as required.  
5. If any errors occur during processing, the program displays a clear message and pauses for the user to acknowledge before exiting.

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by performing **init01** which displays headers, converts dates, and prompts the user before opening input files. [Seen in: init01.]  
It then enters a report generation loop (**read-purchase**) that reads payment records, prints formatted lines, and accumulates totals until the payment file is exhausted. [Seen in: read-purchase.]  
After the report, the program processes each payment record again in **loop-outer/loop-inner** to create open‑item entries, rewrite them, and write corresponding posting records, optionally performing value deduction analysis and batch posting before exiting. [Seen in: loop-outer.]

5.2 Initialization  
**init01** displays the program title, converts the current date to UK format, and asks the user whether to proceed with updating the Open Item file. [Seen in: init01.]  
It then opens the purchase, payment, and print files, and reads the first payment record to prepare for reporting. [Seen in: init01, read-purchase.]

5.3 Core Processing  

Path: Report Generation  
Trigger: start of program after **init01**.  
Key steps: perform Purch-Open-Input, Payments-Open-Input, open print-file, read payments, headings, print lines, accumulate bal‑t.  
I/O: payments file, print file.  
Outcomes: bal‑t total, line‑cnt, page headings.  
[Seen in: read-purchase.]

Path: Posting Path  
Trigger: **loop-outer** after report.  
Key steps: read payments, create oi-header, write OTM5-Write, rewrite OTM5-Rewrite in loop-inner, update deduct amounts, write postings via bl-write.  
I/O: payments file, open-item file 5, posting file (GL or IRS).  
Outcomes: oi records updated, posting records written, batch numbers incremented.  
[Seen in: loop-outer, loop-inner, bl-write.]

Path: Value Deduction Analysis  
Trigger: **end-run** if t‑deduct not zero.  
Key steps: perform Value-Open, analise-deductions, Value-Close.  
I/O: value file.  
Outcomes: va-t-this, va-v-this, va-t-year, va-v-year updated.  
[Seen in: analise-deductions.]

Path: Batch Posting  
Trigger: **bl-open** called during posting when G‑L flag set.  
Key steps: open batch file, write batch record, write postings, close batch.  
I/O: batch file, posting file.  
Outcomes: batch record written, postings count updated.  
[Seen in: bl-open, bl-write, bl-close.]

Path: End‑of‑Cycle  
Trigger: **end-run** after loop-outer.  
Key steps: close files, open output payment file, close, perform value adjustments, close batch.  
I/O: payments file, open-item file, batch file, value file.  
Outcomes: cleanup, program exit.  
[Seen in: end-run.]

5.4 Termination  
The program exits by closing the print file, performing Payments-Close, and calling SYSTEM to print the report. [Seen in: main-end.]  
Finally, it performs all remaining file closures, writes any remaining postings, and terminates with EXIT PROGRAM. [Seen in: end-run.]

---
## pl960
*[169/267]*

### Business/Functional Perspective
### Remittance Advice Report  

#### Program Purpose  
The program creates a printed remittance advice for payments made by cheque or BACS. It pulls payment details from a sequential cheque file, formats them into a professional report, and sends the report to the print spool. The resulting document contains all relevant invoice numbers, folios, amounts, and addresses, supporting accurate financial reconciliation, audit trail creation, and compliance with banking procedures.  

#### Screen Interactions  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

#### Messages and Errors  
* If the cheque file cannot be opened, the program terminates immediately and returns control to the calling environment.  
* If the file is processed normally, the report is generated and sent to the printer; no user‑visible success message is displayed.  
* Any failure in the final system print command (the OS print utility) will cause the job to terminate with an operating‑system error.  

#### User Flow Summary  
1. The user (or an automated job) starts the program, which requires no interactive input.  
2. The program reads each cheque record from the input file in order. For every record, it writes a structured page to the print spool, including the payer and recipient addresses, account number, date, list of invoice numbers with folios and amounts, and the total payment amount.  
3. After all records are processed, the program sends the assembled report to the printer via the operating‑system command line. The printed document can then be mailed or emailed to the appropriate bank.  

#### Program Linkages  
- SYSTEM   (used to invoke the print command)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the init section, setting up the print command and opening the cheque and print files. [Seen in: init section.]  
It then enters a loop that reads each cheque record, writes formatted remittance advice lines to the print file, and repeats until the end of the cheque file. [Seen in: loop.]  
Upon reaching the end of the file, the program closes both files, invokes the system print command, and exits. [Seen in: main-end.]

5.2 Initialization  
The init section constructs the print spool command string and opens the cheque-file for input, aborting if the open status is non‑zero. [Seen in: init section.]  
It also opens the print-file for output, preparing it for record writes. [Seen in: init section.]

5.3 Core Processing  
Path: Record Read  
Trigger: read cheque-file at start of loop  
Key steps: read record, detect end‑of‑file, set cheque variable  
I/O: cheque-file  
Outcomes: loads cheque data into working storage, proceeds to header write  
[Seen in: loop.]

Path: Header Write  
Trigger: after successful read, before address lines  
Key steps: write line‑box, line‑0, line‑box, set l1‑to/l1‑from, write line‑1  
I/O: print-file  
Outcomes: prints header section of remittance advice  
[Seen in: loop.]

Path: Address Lines Write  
Trigger: after header, writes up to five address lines  
Key steps: move each address field to l1‑addr1/addr2, write line‑1  
I/O: print-file  
Outcomes: prints all address lines for the cheque  
[Seen in: loop.]

Path: Invoice Lines Write  
Trigger: after address lines, writes invoice and folio information  
Key steps: perform varying z from 1 to 9, move c‑inv, c‑folio, c‑value to l4‑inv/folio/amount, write line‑4 when amount not spaces  
I/O: print-file  
Outcomes: prints all non‑empty invoice entries  
[Seen in: loop.]

Path: Totals Write  
Trigger: after invoice lines, writes totals and separator lines  
Key steps: write line‑5, write line‑6 with cheque type and gross total, write line‑5  
I/O: print-file  
Outcomes: prints total paid by cheque/BACS and closes the record  
[Seen in: loop.]

Path: End‑of‑File  
Trigger: read at end of cheque-file  
Key steps: close print-file and cheque-file, call SYSTEM with Print‑Report, exit program  
I/O: print-file, cheque-file  
Outcomes: program terminates cleanly  
[Seen in: main-end.]

5.4 Termination  
The main‑end paragraph closes both the print and cheque files, calls the operating system to print the spool file, and exits the program. [Seen in: main-end.]  
No further cleanup is performed beyond the file closures and system call. [Seen in: main-end.]

---
## plautogenLD
*[170/267]*

### Business/Functional Perspective
### PLautogen Table Load  

#### Program Purpose  
This batch program loads the PLautogen data file into the MySQL PLautogen table used by the accounting system. It reads the system configuration, establishes a database connection, and transfers each record while handling duplicate keys. The utility ensures the PLautogen table remains current, supporting downstream accounting processes. It records the number of records processed and any errors for audit and troubleshooting purposes.  

#### Screen Interactions  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

#### Messages and Errors  
- **Configuration issues** – Problems opening the system file or missing database details stop the run and inform the user that required settings are not available.  
- **File access problems** – If the source PLautogen file cannot be opened or is empty, the program reports the issue and exits.  
- **Duplicate records** – When a record already exists in the database, the program logs a warning and continues processing the next record.  
- **Database errors** – Any other failure to write a record to the database (e.g., constraint violations, connection loss) is reported with a descriptive message, after which the program stops.  
- **Rollback / Commit status** – If the program attempts to roll back or commit a transaction and it fails, the error is reported.  

#### User Flow Summary  
The user initiates the program, typically from a script or command line. The program first validates the system configuration file and retrieves database connection information. It then opens the source PLautogen file and the target MySQL table. Each record is read and inserted; duplicate entries are noted and skipped, while serious database errors cause the program to halt and report the problem. After all records are processed, a summary of how many records were read, written, and rewritten is written to the system output. The program then cleans up, closes files, and exits.  

#### Program Linkages  
- acas-get-params  
- acas030  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **aa000-main-start**, performing argument parsing, logging initialization, and opening the system parameter file. [Seen in: aa000-main-start.]  
It then reads the system record, loads RDB configuration (possibly via **acas-get-params**), and opens the PLautogen COBOL file for input and the target MySQL table for output. [Seen in: aa000-main-start.]  
The main loop reads each record from the PLautogen file, attempts to write it to the database, handles duplicate key or other SQL errors, and continues until end‑of‑file before performing cleanup and exiting. [Seen in: aa010-Read.]

5.2 Initialization  
The program parses up to two command line arguments via **zz020-Get-Program-Args** and sets up logging parameters (WS‑Log‑System and WS‑Log‑File‑No). [Seen in: aa000-main-start.]  
It opens the system file, reads the first record, and verifies that the RDBMS parameters are present; if missing, it may invoke **acas-get-params** to load them from acas.param. [Seen in: aa000-main-start.]  
The program then opens the PLautogen input file and the MySQL output table, handling any file open errors and setting File‑System‑Used flags accordingly. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: Read and Write Loop  
Trigger: Record read from the PLautogen file.  
Key steps: Read record, check EOF, write to MySQL, handle duplicate key or other SQL errors, increment counters, loop.  
I/O: PLautogen file, MySQL table.  
Outcomes: Record counts updated, duplicates rewritten or skipped, program continues until EOF or error.  
[Seen in: aa010-Read.]  

Path: Duplicate Key Handling  
Trigger: SQL‑State "23000" or FS‑Reply 22/99 or SQL‑Err 1062/1022 after a write attempt.  
Key steps: Reset FS‑Reply and WE‑Error, rewrite the record, increment rewrite counter, continue loop.  
I/O: MySQL table.  
Outcomes: Duplicate record rewritten, rewrite counter incremented, loop proceeds.  
[Seen in: aa010-Read.]  

Path: Non‑Duplicate Error Handling  
Trigger: FS‑Reply not zero after a write attempt (other than duplicate).  
Key steps: Log error details, set return‑code 16, exit loop.  
I/O: MySQL table.  
Outcomes: Program terminates with error status.  
[Seen in: aa010-Read.]  

Path: System Parameter Load via acas-get-params  
Trigger: RDBMS‑DB‑Name empty or FS‑Cobol‑Files‑Used flag set.  
Key steps: Call **acas-get-params**, handle return codes, set RDBMS parameters, go to **aa010-Proc-Override**.  
I/O: acas.param file.  
Outcomes: RDBMS configuration loaded, file open sequence continues.  
[Seen in: aa000-main-start.]  

Path: Finalization (Program Exit)  
Trigger: EOF reached or error exit.  
Key steps: Log record counts, close MySQL and PLautogen files, close system file, GOBACK.  
I/O: System file, PLautogen file, MySQL table.  
Outcomes: Program ends with appropriate return‑code.  
[Seen in: aa999-Finish.]

5.4 Termination  
Upon completion or error, the program logs record counts, closes the MySQL and PLautogen files, closes the system file, and returns to the caller. [Seen in: aa999-Finish.]  
The final GOBACK occurs after all cleanup, with the return‑code set to indicate success or failure. [Seen in: aa999-Finish.]

---
## plautogenMT
*[171/267]*

### Business/Functional Perspective
### Purchase Autogen RDB Handler  

**Program Purpose**  
The program is a database access layer that stores, retrieves, updates and deletes purchase‑autogen records and their line items. It ensures that each purchase invoice and its detailed line items are accurately written to the database, validates that the data exists before use, and prevents duplicate or invalid entries. The handler supports auditability by logging each operation and its outcome, helping the business maintain consistent and reliable accounting data.

**Screen Interactions**  
No direct screens. This program is invoked by other application modules that perform data entry or display, and it returns results to those contexts.

**Messages and Errors**  
- *Operation success* – The requested read, write, delete or update completes and the calling module receives the record data or confirmation of the action.  
- *No data found* – When a requested record or line item does not exist, the program indicates the absence of data.  
- *Duplicate key error* – An attempt to insert a record with a key that already exists is reported.  
- *Invalid key or function* – If the supplied key is out of range or an unsupported operation is requested, the program signals the error.  
- *Database connection or SQL error* – Problems connecting to the database or executing SQL statements are reported with a general failure indication.  
- *Unexpected failure* – Any other unexpected issue during processing is reported as a generic error.

**User Flow Summary**  
1. A higher‑level module supplies a purchase invoice record (header) and, if applicable, a line‑item record to the handler along with a function code (e.g., read, write, delete).  
2. The handler determines whether the operation concerns the main invoice table or the line‑item repeat group based on the key value.  
3. For a *read* request it retrieves the requested record(s) from the database; for *write* it inserts a new record or updates an existing one; for *delete* it removes the specified record or all line items for an invoice.  
4. After the database operation, the handler populates the return linkage area with the record data (if a read) and sets reply codes that indicate success, data‑not‑found, duplicate key, or other errors.  
5. The calling module receives the data or error status and proceeds accordingly—displaying messages to the user, updating the interface, or logging the action for audit purposes.

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_query  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by initializing environment settings and then dispatches to a specific paragraph based on the File-Function value received from the caller. [Seen in: ba-ACAS-DAL-Process]  
For data retrieval it performs a SELECT followed by a FETCH to return either an invoice header or its associated line items, maintaining a cursor for sequential access. [Seen in: ba040-Process-Read-Next, ba041-Reread]  
Data modification operations such as INSERT, UPDATE, or DELETE are executed against the PUAUTOGEN-REC and PUAUTOGEN-LINES-REC tables, with special handling for line items via the RG (repeat group) sections. [Seen in: ba070-Process-Write, ba080-Process-Delete, ba090-Process-Rewrite, bc070-Process-Write, bc080-Process-Delete, bc090-Process-Rewrite]

5.2 Initialization  
On entry, the program sets screen exception handling, initializes counters, and clears all error and logging fields. [Seen in: ba-ACAS-DAL-Process]  
It then evaluates the File-Function to determine the requested operation, performing an OPEN or CLOSE of the database if required. [Seen in: ba-ACAS-DAL-Process, ba020-Process-Open, ba030-Process-Close]

5.3 Core Processing  

Path: Open  
Trigger: File-Function = 1 (OPEN)  
Key steps: Build connection parameters, call MYSQL-1000-OPEN, set cursor inactive, set File-Key to “OPEN PL AUTOGEN”.  
I/O: None (only database connection).  
Outcomes: fs-reply = 0, WE-Error = 0, cursor not active.  
[Seen in: ba020-Process-Open]  

Path: Read-Next  
Trigger: File-Function = 34 (Read-Next-Header)  
Key steps: If cursor inactive, build WHERE clause for first key, SELECT PUAUTOGEN-REC, fetch first row, set cursor active, store row count, log. Subsequent calls use ba041-Reread to fetch next rows or next header.  
I/O: SELECT and FETCH on PUAUTOGEN-REC.  
Outcomes: WS-Invoice-Record populated, FS-Reply = 0, WE-Error = 0, cursor active.  
[Seen in: ba040-Process-Read-Next, ba041-Reread]  

Path: Read-Indexed  
Trigger: File-Function = 4 (READ-INDEXED)  
Key steps: If WS-ih-test non‑zero, delegate to RG read; otherwise SELECT PUAUTOGEN-REC where key matches, FETCH row, load HVs, set FS-Reply = 0.  
I/O: SELECT and FETCH on PUAUTOGEN-REC.  
Outcomes: WS-Invoice-Record populated, FS-Reply = 0, WE-Error = 0.  
[Seen in: ba050-Process-Read-Indexed]  

Path: Write  
Trigger: File-Function = 5 (WRITE)  
Key steps: If WS-ih-Test non‑zero, delegate to RG write (bc070-Process-Write); else load HVs, INSERT into PUAUTOGEN-REC, check row count, set errors if duplicate.  
I/O: INSERT on PUAUTOGEN-REC (and PUAUTOGEN-LINES-REC if line).  
Outcomes: FS-Reply = 0 or 22, WE-Error = 0 or 22, WS-Invoice-Record contains inserted key.  
[Seen in: ba070-Process-Write, bc070-Process-Write]  

Path: Delete  
Trigger: File-Function = 8 (DELETE)  
Key steps: If WS-ih-Test non‑zero, delegate to RG delete (bc080-Process-Delete); else DELETE from PUAUTOGEN-REC where key matches, check row count, set errors.  
I/O: DELETE on PUAUTOGEN-REC (and PUAUTOGEN-LINES-REC if line).  
Outcomes: FS-Reply = 0, WE-Error = 0, WS-File-Key indicates status.  
[Seen in: ba080-Process-Delete, bc080-Process-Delete]  

Path: Rewrite  
Trigger: File-Function = 7 (REWRITE)  
Key steps: If WS-ih-Test non‑zero, delegate to RG rewrite (bc090-Process-Rewrite); else load HVs, UPDATE PUAUTOGEN-REC where key matches, check row count, set errors.  
I/O: UPDATE on PUAUTOGEN-REC (and PUAUTOGEN-LINES-REC if line).  
Outcomes: FS-Reply = 0 or 99, WE-Error = 0 or 994, WS-Invoice-Record updated.  
[Seen in: ba090-Process-Rewrite, bc090-Process-Rewrite]  

5.4 Termination  
After completing the requested operation, the program performs any necessary cleanup such as freeing cursors and logging, then exits with GOBACK. [Seen in: ba999-end, ba998-Free]  
The final status codes (FS-Reply, WE-Error, SQL-Err, SQL-Msg, SQL-State) are left in the linkage area for the caller to interpret. [Seen in: ba999-end]

---
## plautogenRES
*[172/267]*

### Business/Functional Perspective
### Backup of Autogen File  

#### Program Purpose  
The program creates a backup copy of the accounting “autogen” data by reading the sequential file *plautogen.seq* and writing its records to a new sequential file. It logs each step and the total number of records processed, ensuring that the data can be restored if the original file becomes corrupted or incompatible with a newer library. The utility provides a simple, reliable way to preserve transaction data and supports compliance and audit requirements.  

#### Screen Interactions  
No direct screens. This program is invoked from a command‑line or batch environment and writes progress and error messages to the log file.  

#### Messages and Errors  
- **Missing source file** – The program reports that there is no *plautogen* file to process and then stops.  
- **File access problems** – If the input file cannot be opened or read, or if the output file cannot be opened or written to, the program logs an error message and stops.  
- **Read or write errors** – Any error encountered while reading the source file or writing the backup file is logged, and the program aborts the transfer.  
- **Environment setup issues** – If required environment variables are not set, the program logs an abort message.  

#### User Flow Summary  
The user runs the program (typically with no or minimal command‑line arguments). The program starts by logging its initiation and the fact that it will process the *plautogen.seq* file. It then opens the source file; if the file is missing or unreadable, it logs a failure message and terminates. Otherwise, it opens the destination file and begins copying records one by one, logging any read or write errors that occur. For each successful record it increments a counter. When the source file ends, the program closes both files, logs the total number of records read and written, writes a final “CLOSE” marker, and exits with a success status.  

#### Program Linkages  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph aa000-Main-Start, retrieving command‑line arguments, configuring logging parameters, and writing an initial status message. [Seen in: aa000-Main-Start.]  
It opens the source sequential file (plautogen-File-Seq) and the destination output file (Agen-Invoice-File), handling any open‑file errors before proceeding. [Seen in: aa000-Main-Start.]  
During aa010-Read-Recs it reads each record from the source, writes it to the output file, updates record counters, and exits on read or write errors; after the loop aa020-Finish-Off closes the files, logs totals, and terminates. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command‑line parameters, then sets WS-Log-System and WS-Log-File-no for logging. [Seen in: aa000-Main-Start.]  
It logs a startup message via Call‑Sysout, opens the input file plautogen-File-Seq, checks FS-Reply for errors, then opens the output file Agen-Invoice-File and checks FS-Reply again. [Seen in: aa000-Main-Start.]  
Record counters WS-Rec-Cnt-In and WS-Rec-Cnt-Out are initialized to zero before processing begins. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read-Records  
Trigger: Execution of aa010-Read-Recs loop until end of file or error. [Seen in: aa010-Read-Recs.]  
Key steps: read next record from plautogen-File-Seq, check FS-Reply; if OK, write WS-PInvoice-Record to Agen-Invoice-File, check FS-Reply; increment WS-Rec-Cnt-In and WS-Rec-Cnt-Out; on any error, log message via Call‑Sysout and branch to aa020-Finish-Off.  
I/O: plautogen-File-Seq, Agen-Invoice-File.  
Outcomes: record counts updated; on error, program exits the loop and proceeds to finish.

Path: Finish-Off  
Trigger: Completion of aa010-Read-Recs (end of file) or an error condition. [Seen in: aa020-Finish-Off.]  
Key steps: close plautogen-File-Seq and Agen-Invoice-File, compose a summary message with record counts, log it via Call‑Sysout, set Return-Code to zero, and goback to terminate.  
I/O: plautogen-File-Seq, Agen-Invoice-File.  
Outcomes: files closed, final status logged, program exits cleanly.

5.4 Termination  
The program closes both the input and output files, logs a final record‑count summary, sets Return-Code to zero, and performs a GOBACK to terminate. [Seen in: aa020-Finish-Off.]

---
## plautogenUNL
*[173/267]*

### Business/Functional Perspective
### PLAUTGEN File Unload  

**Program Purpose**  
This program creates a backup copy of the PL AUTOGEN data file. It reads every record from the original ISAM file and writes them into a new sequential file with a .seq extension. The backup can later be used to restore the data if the original file becomes corrupt or incompatible. The operation is logged to a system display file so that administrators can verify the backup succeeded and check record counts.

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry step and writes its results to the system log; it does not prompt the user for input or display a terminal interface.

**Messages and Errors**  
- **Missing or unreadable source file** – The program reports that no PL AUTOGEN file was found or that a read error occurred.  
- **Write failure to the .seq file** – A message indicates a write error when attempting to create the backup file.  
- **Program argument or environment problems** – If required arguments or environment variables are missing, the program aborts and logs a notice.  
- **Completion summary** – After all records are processed, the program logs the total number of records read and written.  

**User Flow Summary**  
A user runs the backup program from a command line or automated job. The program opens the PL AUTOGEN ISAM file, reads each record, and writes it sequentially to a new .seq file. Throughout the process, status messages are written to the system log (SYS‑DISPLAY.log). If the source file is missing or corrupted, an error message is logged and the program exits. Upon successful completion, the log shows the counts of records transferred, confirming that the backup file has been created.

**Program Linkages**  
- ACAS‑Sysout  

(Only external program invoked.)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins execution at paragraph **aa000-Main-Start**, where it retrieves command‑line arguments, configures logging, and opens the input file **Agen-Invoice-File**. If the input file opens successfully, it opens the output sequential file **plautogen-File-Seq** and enters a loop in paragraph **aa010-Read-Recs** that reads each record, writes it to the output file, and updates counters. Upon reaching the end of the input file or encountering an error, control transfers to paragraph **aa020-Finish-Off**, which closes both files, prints a summary, sets the return code, and exits. [Seen in: aa000-Main-Start.] [Seen in: aa010-Read-Recs.] [Seen in: aa020-Finish-Off.]

5.2 Initialization  
In **aa000-Main-Start**, the routine **zz020-Get-Program-Args** is performed to capture program arguments, and logging parameters **WS-Log-System** and **WS-Log-File-no** are initialized. The program then attempts to open **Agen-Invoice-File** for input; if the status **FS-Reply** is non‑zero, an error message is printed and the program terminates early. If the input file opens successfully, **plautogen-File-Seq** is opened for output and the record counters **ws-Rec-Cnt-In** and **ws-Rec-Cnt-Out** are set to zero. [Seen in: aa000-Main-Start.] [Seen in: aa010-Read-Recs.]

5.3 Core Processing  
Path: **Input File Open Failure**  
Trigger: **FS-Reply** non‑zero after opening **Agen-Invoice-File**  
Key steps: Print error message, close **Agen-Invoice-File**, goback.  
I/O: **Agen-Invoice-File**  
Outcomes: Program exits immediately.  
[Seen in: aa000-Main-Start.]

Path: **Record Read Loop**  
Trigger: Successful open of **Agen-Invoice-File**; loop begins.  
Key steps: Read next record, check **FS-Reply**, write to **plautogen-File-Seq**, increment counters, repeat until end.  
I/O: **Agen-Invoice-File**, **plautogen-File-Seq**  
Outcomes: All records copied; counters reflect totals.  
[Seen in: aa010-Read-Recs.]

Path: **Read Error**  
Trigger: **FS-Reply** non‑zero after a read operation.  
Key steps: Print error message, go to **aa020-Finish-Off**.  
I/O: **Agen-Invoice-File**  
Outcomes: Loop terminates, files closed, summary printed.  
[Seen in: aa010-Read-Recs.]

Path: **Write Error**  
Trigger: **FS-Reply** non‑zero after a write operation.  
Key steps: Print error message, go to **aa020-Finish-Off**.  
I/O: **plautogen-File-Seq**  
Outcomes: Loop terminates, files closed, summary printed.  
[Seen in: aa010-Read-Recs.]

Path: **End of File**  
Trigger: End‑of‑file condition encountered during read.  
Key steps: Transfer control to **aa020-Finish-Off**.  
I/O: **Agen-Invoice-File**, **plautogen-File-Seq**  
Outcomes: Files closed, summary printed, program exits normally.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
Paragraph **aa020-Finish-Off** closes both **plautogen-File-Seq** and **Agen-Invoice-File**, prints a summary of records processed, sets **Return-Code** to zero, and exits via **GOBACK**. [Seen in: aa020-Finish-Off.]

---
## plinvoiceLD
*[174/267]*

### Business/Functional Perspective
### Invoice Table Load  

#### Program Purpose  
This program transfers invoice records from the PL Invoice file into a MySQL database. It reads system configuration to determine database connection details, validates the presence of the source file, and writes each record to the target table. Duplicate records are identified and skipped, while any database or file errors cause the process to halt with a descriptive message. The operation is logged to support audit trails and reduce data entry risk.  

#### Screen Interactions  
No direct screens. This program is run after a separate data‑entry step and returns status information back to that context.  

#### Messages and Errors  
- **System configuration problems** – If the system file cannot be opened or the required database parameters are missing, the program stops and informs the user that the environment is not set up.  
- **Missing source file** – If the PL Invoice file is absent, a brief message indicates nothing to process and the program exits.  
- **File read or write errors** – Any issue reading the source file or writing to the database results in a stop message describing the error.  
- **Duplicate records** – Records that already exist in the database are ignored; a count of rewrites is kept and displayed at completion.  
- **Database errors** – General SQL errors (e.g., connection failures, constraint violations) cause the program to abort after displaying the error details.  
- **Completion summary** – At the end, the program prints the number of records processed, written, and rewrote, as well as any log records written.  

#### User Flow Summary  
1. The user starts the program, optionally providing up to two command‑line arguments.  
2. The program reads the system configuration file to obtain MySQL connection details. If the file is missing or incomplete, the user is notified and the program stops.  
3. The program attempts to open the PL Invoice source file. If the file is not present, a short message is displayed and the process ends.  
4. For each record in the source file, the program writes the data to the MySQL table. If a record already exists (duplicate key), it is skipped and counted as a rewrite. Any other database or file error causes the program to halt with an error message.  
5. After all records have been processed, the program prints a summary of records read, written, and rewritten, then closes all files and exits gracefully.  

#### Program Linkages  
- acas-get-params  
- acas026  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **aa000-main-start**, where it parses command‑line arguments, initializes logging, and opens the system parameter file. From there it reads the system record, optionally overrides RDB settings via **acas-get-params**, and then opens the COBOL invoice file and the RDB output table. The main processing loop is executed in paragraph **aa010-Read**, which reads each invoice record, writes it to the RDB, and handles duplicate keys or errors. Upon reaching end‑of‑file or encountering a fatal error, control transfers to **aa999-Finish**, which closes all files, logs summary counts, and exits. [Seen in: aa000-main-start, aa010-Proc-Override, aa010-Read, aa999-Finish.]

5.2 Initialization  
The program performs argument parsing with **zz020-Get-Program-Args**, sets logging parameters, and opens the system file. It reads the first system record, loads RDB connection details, and sets file‑system‑used flags before opening the invoice file (**acas026-Open-Input**) and the RDB output table (**acas026-Open-Output**). [Seen in: aa000-main-start, aa010-Proc-Override.]

5.3 Core Processing  
Path: Invoice Load  
Trigger: Execution of paragraph **aa010-Read** after successful file openings.  
Key steps: Read next invoice record, write to RDB, increment input and output counters, handle duplicate key or SQL errors, and loop back to read the next record.  
I/O: System‑File (read earlier), COBOL invoice file via **acas026-Read-Next**, RDB table via **acas026-Write**.  
Outcomes: Counters (ws‑Rec‑Cnt‑In, ws‑Rec‑Cnt‑Out, ws‑Rec‑Cnt‑R‑Out) updated; FS‑Reply, WE‑Error, SQL‑Err, SQL‑State set for subsequent logic.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: FS‑Reply = 22 or 99, or SQL‑STATE = "23000" during a write operation.  
Key steps: Reset FS‑Reply and WE‑Error, perform **acas026-Rewrite** to update the existing record, increment rewrite counter.  
I/O: **acas026-Rewrite** on the RDB table.  
Outcomes: Duplicate record updated, rewrite counter incremented, processing continues with next record.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: Any FS‑Reply not equal to zero during read or write operations.  
Key steps: Log the error details via **Call‑Sysout**, set return‑code to 16, and transfer control to **aa999-Finish**.  
I/O: None beyond logging; System‑File remains open until finish.  
Outcomes: Program terminates with error status, no further records processed.  
[Seen in: aa010-Read, aa100-Check-4-Errors.]

Path: Finish  
Trigger: End‑of‑file (FS‑Reply = 10) or fatal error causing a jump to **aa999-Finish**.  
Key steps: Log summary counts, close RDB and COBOL files, close system file, and perform **goback**.  
I/O: **acas026-Close** for both RDB and COBOL files, **System-File** close.  
Outcomes: All resources released, program exits cleanly.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program logs final record counts, closes the RDB and COBOL invoice files, closes the system file, and exits with **goback**. [Seen in: aa999-Finish.]

---
## plinvoiceMT
*[175/267]*

### Business/Functional Perspective
### Purchase Invoice RDB Handler  

**Program Purpose**  
This program supplies the data‑access layer for purchase invoice records in the Applewood Accounting System. It opens and closes the database, and performs the full set of create, read, update, and delete (CRUD) operations on both the invoice header table and its associated line‑item table. The module ensures that each invoice and its lines are stored, retrieved, and validated correctly, which keeps the accounting data accurate, prevents duplicate entries, and supports auditability and compliance across the application.

**Screen Interactions**  
No direct screens. This program is invoked by other modules after data entry has taken place and returns results back to that context.

**Messages and Errors**  
* **Success** – operation completes without issue.  
* **End of Data** – the requested read operation has reached the last record.  
* **Record Not Found** – an invoice or line item with the specified key does not exist.  
* **Duplicate Key** – an attempt to insert an invoice or line that already exists.  
* **Invalid Key** – the supplied key value is outside the allowed range.  
* **Access Violation** – the requested database operation is not permitted (e.g., trying to delete a locked record).  
* **Database Error** – any underlying SQL error such as a connection failure, timeout, or syntax problem.  
* **Other System Errors** – unexpected conditions that cause the program to terminate or return a generic failure code.

**User Flow Summary**  
1. **Open** – The caller requests a database connection. The program establishes the connection and signals success or a connection error.  
2. **Read** –  
   * *Read‑Next* retrieves the next invoice header and, if requested, its line items one at a time.  
   * *Read‑Indexed* fetches a specific invoice (header or line) based on a key.  
   The returned record is passed back to the caller; if no data is found an appropriate “not found” indicator is returned.  
3. **Write** – Depending on the key, the program inserts a new header or a new line item. It reports success or duplicate‑key/validation failures.  
4. **Delete** – A header or individual line item can be removed; a special delete‑all operation removes every line belonging to a given invoice. Deletion failures (e.g., due to locks) are reported.  
5. **Rewrite (Update)** – An existing header or line is updated; the program reports success or errors such as duplicate keys or SQL failures.  
6. **Close** – The database connection is closed cleanly, releasing any allocated resources.

At each step the program returns a reply code indicating success or the type of failure, along with a descriptive message for logging or user display by the calling module.

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- MySQL_query   (via the pre‑compiled MySQL procedure calls)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by accepting environment lines, setting screen exception flags, and initializing key variables before evaluating the File-Function to determine the requested operation. [Seen in: ba010-Initialise.]  
Based on the File-Function value, control is transferred to one of the dedicated processing paragraphs such as ba020-Process-Open, ba030-Process-Close, ba040-Process-Read-Next, ba050-Process-Read-Indexed, ba060-Process-Start, ba070-Process-Write, ba080-Process-Delete, ba085-Process-Delete-All, or ba090-Process-Rewrite. [Seen in: ba020-Process-Open.]  
Each processing paragraph performs the necessary SQL operations, updates host variables, and sets status codes (FS-Reply, WE-Error, SQL-Err, SQL-Msg, SQL-State) before returning control to the end routine. [Seen in: ba999-end.]  
Finally, the program executes cleanup actions such as freeing cursors, logging, and then exits via GOBACK or STOP RUN. [Seen in: ba999-exit.]

5.2 Initialization  
The program accepts environment lines and sets the COB_SCREEN_EXCEPTIONS and COB_SCREEN_ESC environment variables to enable screen exception handling. [Seen in: ba010-Initialise.]  
It initializes key variables such as WS-Reply, WS-MYSQL-Error-Message, WS-MYSQL-Error-Number, WS-Log-Where, WS-File-Key, SQL-Msg, and SQL-Err to spaces or zero. [Seen in: ba010-Initialise.]  
The program then evaluates the File-Function to determine the operation to perform, routing to the appropriate paragraph via a series of GO TO statements. [Seen in: ba020-Process-Open.]  
For open operations, it performs a MySQL open sequence (MYSQL-1000-OPEN to MYSQL-1090-EXIT) and sets the cursor inactive flag. [Seen in: ba020-Process-Open.]

5.3 Core Processing  
Path: Open  
Trigger: File-Function = 1  
Key steps: perform MYSQL-1000-OPEN to MYSQL-1090-EXIT, set Cursor-Not-Active, set WS-File-Key to "OPEN SL INVOICE".  
I/O: MySQL database connection (open).  
Outcomes: fs-reply set to 0 if success, else go to ba999-end; Cursor-Not-Active true.  
[Seen in: ba020-Process-Open.]  

Path: Read-Next  
Trigger: File-Function = 34 (special Read-Next-Header)  
Key steps: if cursor not active, build WHERE clause for key >= '0000000000', perform SELECT on PUINVOICE-REC, store result, set cursor active, handle no rows, log message, then perform ba999-End; if cursor active, perform ba041-Reread to fetch next record.  
I/O: PUINVOICE-REC table, cursor.  
Outcomes: fs-reply 10 for EOF, WS-File-Key set to key or error message, cursor active flag.  
[Seen in: ba040-Process-Read-Next, ba041-Reread.]  

Path: Read-Indexed  
Trigger: File-Function = 4  
Key steps: if WS-ih-test not zero, delegate to bc050-Process-Read-Indexed for RG; else build WHERE clause for key = record key, perform SELECT on PUINVOICE-REC, fetch record, handle errors, unload HVs to record, set FS-Reply 0, WS-File-Key set.  
I/O: PUINVOICE-REC table, cursor.  
Outcomes: fs-reply 23 if not found, WS-File-Key set, cursor active flag.  
[Seen in: ba050-Process-Read-Indexed, bc050-Process-Read-Indexed.]  

Path: Write  
Trigger: File-Function = 5  
Key steps: if WS-ih-Test not zero, delegate to bc070-Process-Write for RG; else load HVs, perform bb200-Insert on PUINVOICE-REC, check row count, handle duplicate key errors, set fs-reply, WS-File-Key.  
I/O: PUINVOICE-REC table.  
Outcomes: fs-reply 22 on duplicate, 99 on error, WS-File-Key set.  
[Seen in: ba070-Process-Write, bc070-Process-Write.]  

Path: Delete  
Trigger: File-Function = 8  
Key steps: if WS-ih-Test not zero, delegate to bc080-Process-Delete for RG; else build WHERE clause for key = record key, perform DELETE on PUINVOICE-REC, check row count, set fs-reply, WS-File-Key.  
I/O: PUINVOICE-REC table.  
Outcomes: fs-reply 99 on error, WS-File-Key set.  
[Seen in: ba080-Process-Delete, bc080-Process-Delete.]  

Path: Rewrite  
Trigger: File-Function = 7  
Key steps: if WS-ih-Test not zero, delegate to bc090-Process-Rewrite for RG; else load HVs, perform bb300-Update on PUINVOICE-REC, check row count, set fs-reply, WS-File-Key.  
I/O: PUINVOICE-REC table.  
Outcomes: fs-reply 99 on error, WS-File-Key set.  
[Seen in: ba090-Process-Rewrite, bc090-Process-Rewrite.]  

5.4 Termination  
After processing, the program executes the ba999-end routine which performs logging if testing is enabled and then proceeds to ba999-exit. [Seen in: ba999-end.]  
The ba999-exit routine simply exits the program, freeing any remaining resources such as cursors via ba998-Free if necessary. [Seen in: ba999-exit, ba998-Free.]

---
## plinvoiceRES
*[176/267]*

### Business/Functional Perspective
### Invoice File Restore

**Program Purpose**  
The program copies all invoice records from the sequential file *pinvoice.seq* into a target file used by the accounting system. It logs the start and completion of the operation, including the number of records read and written, and records any problems that occur during the process. By ensuring that a fresh copy of the invoice data is available, it supports data integrity and audit readiness while reducing manual intervention.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the source invoice file does not exist or cannot be opened, the program logs a message stating that no invoice file was found.  
- If the target file cannot be opened for writing, an error message describing the failure is logged.  
- During processing, if a read error occurs, a “problem reading file” message is logged.  
- If a write error occurs, a “write error on file” message is logged.  
- After completion, the program logs a summary showing the number of records read and written.  
- All messages are written to the system log and may include an instruction to check the log for details.

**User Flow Summary**  
When the user initiates the restore, the program begins by logging a brief start message. It then attempts to open the source invoice file. If the file is missing, the user is informed via the log that no file was found and the program ends. If the file is available, the program reads each record one by one, writes it to the destination file, and keeps a running count of processed records. Any read or write problems are logged immediately, and the program stops processing further records. Once all records have been handled, the program logs a final message showing how many records were read and written, then exits cleanly.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by retrieving command line arguments and initializing logging parameters. [Seen in: aa000-Main-Start.]  
It opens the source sequential file for reading and a destination file for writing, handling any open errors. [Seen in: aa000-Main-Start.]  
It then reads each record from the source, writes it to the destination, counts records, and finally closes both files and reports totals before exiting. [Seen in: aa010-Read-Recs.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and sets up logging system identifiers. [Seen in: aa000-Main-Start.]  
It initializes record counters to zero and prepares a status message buffer. [Seen in: aa000-Main-Start.]  
It opens the source pInvoice-File-Seq for input and the destination Invoice-File for output, checking status codes and logging any failures. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read-Write-Loop  
Trigger: Successful open of both files and entering aa010-Read-Recs.  
Key steps: Read each record, increment input counter, write to output, increment output counter, handle write errors.  
I/O: pInvoice-File-Seq, Invoice-File.  
Outcomes: Record counts updated, errors logged, loop exits on end‑of‑file or error.  
[Seen in: aa010-Read-Recs.]  

Path: Open-Source-Failure  
Trigger: FS-Reply non‑zero after opening input file.  
Key steps: Log message “No pInvoice file to process”, close Invoice-File, exit.  
I/O: pInvoice-File-Seq, Invoice-File.  
Outcomes: Program terminates early with goback.  
[Seen in: aa000-Main-Start.]  

Path: Open-Destination-Failure  
Trigger: FS-Reply non‑zero after opening output file.  
Key steps: Log failure message with FS-Reply, close Invoice-File, exit.  
I/O: Invoice-File.  
Outcomes: Program terminates early with goback.  
[Seen in: aa000-Main-Start.]  

Path: Read-Error  
Trigger: FS-Reply non‑zero during read of source file.  
Key steps: Log SY003 with FS-Reply, exit loop, close files.  
I/O: pInvoice-File-Seq.  
Outcomes: Program terminates with goback.  
[Seen in: aa010-Read-Recs.]  

Path: Write-Error  
Trigger: FS-Reply non‑zero during write to destination file.  
Key steps: Log SY006, exit loop, close files.  
I/O: Invoice-File.  
Outcomes: Program terminates with goback.  
[Seen in: aa010-Read-Recs.]

5.4 Termination  
After processing, the program closes both files, logs the total records processed, sets Return-Code to zero, and performs a goback to terminate. [Seen in: aa020-Finish-Off.]  
A final call to ACAS‑Sysout is made to output any remaining status messages. [Seen in: Call-Sysout.]

---
## plinvoiceUNL
*[177/267]*

### Business/Functional Perspective
### Invoice File Unload Backup  

**Program Purpose**  
The program creates a backup of the current invoice data by copying all records from the existing pInvoice file into a new sequential file named *pinvoice.seq*. It logs the operation, including the number of records processed, to a system log for audit and troubleshooting purposes. The backup process is automated so that the data can be restored later if the original file becomes corrupted or lost. This helps maintain data integrity and supports compliance with record‑keeping requirements.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the original invoice file cannot be opened, the user is informed that no file was found.  
- Any error while reading the invoice file produces a message indicating a problem with that file.  
- If writing to the sequential backup file fails, a write‑error message is logged.  
- The program will terminate immediately if required environment settings are missing or if command‑line arguments are incorrect.

**User Flow Summary**  
The user runs the program from the command line. It first verifies that the required environment variables and command‑line parameters are present. The program then attempts to open the current invoice file. If successful, it reads each record one by one and writes the record to a new sequential file. Throughout the process, it logs status messages, including a start message, any errors that occur, and a final message reporting the total number of records processed. Once all records have been written, the program closes both files, writes a closing log entry, and exits.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and initializing logging parameters in paragraph aa000‑Main‑Start. It then opens the source pInvoice ISAM file for input and the target sequential file for output, proceeding to read and write records in paragraph aa010‑Read‑Recs. Upon reaching end‑of‑file or encountering an error, it closes both files, logs a summary, and exits in paragraph aa020‑Finish‑Off. [Seen in: aa000‑Main‑Start.] [Seen in: aa010‑Read‑Recs.] [Seen in: aa020‑Finish‑Off.]

5.2 Initialization  
The program performs zz020‑Get‑Program‑Args to capture command‑line parameters and sets up logging identifiers (WS‑Log‑System, WS‑Log‑File‑no) in aa000‑Main‑Start. It then opens the input pInvoice file and checks FS‑Reply; if the file is missing, it logs a message and aborts. The output sequential file is opened next, and record counters are initialized to zero. [Seen in: aa000‑Main‑Start.] [Seen in: zz020‑Get‑Program‑Args.]

5.3 Core Processing  
Path: Normal Read/Write  
Trigger: Successful open of both input and output files.  
Key steps: Loop reading each record from Invoice‑File, incrementing WS‑Rec‑Cnt‑In, writing the record to pInvoice‑File‑Seq, incrementing WS‑Rec‑Cnt‑Out, and checking FS‑Reply after each operation.  
I/O: Invoice‑File, pInvoice‑File‑Seq.  
Outcomes: Records are copied to the sequential file; counters reflect total processed.  
[Seen in: aa010‑Read‑Recs.]

Path: Input File Not Found  
Trigger: FS‑Reply non‑zero after opening Invoice‑File.  
Key steps: Log “No pInvoice file to process”, close the input file, and goback.  
I/O: Invoice‑File.  
Outcomes: Program terminates without creating output file.  
[Seen in: aa000‑Main‑Start.]

Path: Read Error  
Trigger: FS‑Reply non‑zero during a read operation in aa010‑Read‑Recs.  
Key steps: Log SY003 with the error code, close files, and goback.  
I/O: Invoice‑File.  
Outcomes: Program aborts mid‑processing, no further records written.  
[Seen in: aa010‑Read‑Recs.]

Path: Write Error  
Trigger: FS‑Reply non‑zero after a write to pInvoice‑File‑Seq.  
Key steps: Log SY006, close files, and goback.  
I/O: pInvoice‑File‑Seq.  
Outcomes: Program aborts after partial output, counters may be incomplete.  
[Seen in: aa010‑Read‑Recs.]

Path: End‑of‑File / Finish  
Trigger: End‑of‑file reached during read loop.  
Key steps: Close both files, log record counts, set Return‑Code to zero, and goback.  
I/O: Invoice‑File, pInvoice‑File‑Seq.  
Outcomes: Program exits cleanly with summary of records processed.  
[Seen in: aa020‑Finish‑Off.]

5.4 Termination  
The program closes both the input and output files, logs a final message indicating the number of records processed, sets Return‑Code to zero, and exits via GOBACK. [Seen in: aa020‑Finish‑Off.]

---
## purchase
*[178/267]*

### Business/Functional Perspective
### Purchase Ledger Menu  

**Program Purpose**  
The program presents a menu for managing the purchase ledger. It allows users to view or modify supplier and purchase records, run reports, and perform end‑of‑month processing. By providing a single point of access to these functions, the system ensures that all purchase transactions are entered, amended, proved, and posted in a consistent, auditable manner, reducing the risk of data errors.  

**Screen Interactions**  
1. **Date/Time Entry Screen** – Displays the current date and time. The user can edit these values before proceeding.  
2. **Main Menu Screen** – Shows the title “Purchase Ledger System Menu”, the current date and time, the operating‑system name, and a list of options (A–X, Z if permitted). The user selects a function by entering the corresponding letter.  

**Messages and Errors**  
- If the terminal is too small (fewer than 24 lines or 80 columns) a message is shown and the program exits.  
- If a backup script cannot be found, a notice is displayed.  
- Choosing option Z when it is restricted displays “Not permitted”.  
- Selecting an unavailable option displays “Sorry not available”.  

**User Flow Summary**  
The user starts the program, optionally edits the date and time, and then views the menu of purchase‑ledger functions. By entering a letter, the user invokes a specific subprogram—for example, entering “A” to enter a new date, “B” to maintain suppliers, “D” to input purchase transactions, or “T” to run end‑of‑cycle processing. After the chosen task completes, control returns to the menu, allowing the user to perform additional actions or exit the program.  

**Program Linkages**  
- maps04  
- CBL_CHECK_FILE_EXIST  
- SYSTEM  
- pl000  
- pl010  
- pl015  
- pl020  
- pl030  
- pl040  
- pl050  
- pl055  
- pl060  
- pl080  
- pl085  
- pl090  
- pl095  
- pl100  
- pl070  
- pl130  
- pl140  
- pl165  
- pl115  
- pl120  
- pl160  
- pl170  
- pl190  
- pl180  
- xl150  
- pl900

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by initializing screen and environment settings, parsing command‑line arguments, and loading system parameters before presenting a menu to the user. [Seen in: Purchase-Main.]  
The user selects an option, which is mapped to a numeric index and dispatched to a corresponding load paragraph that invokes the appropriate PL program. [Seen in: load-it.]  
After the selected operation completes, the program may rewrite system records, optionally run a backup script, and then return to the menu or exit. [Seen in: pre-overrewrite.]

5.2 Initialization  
Environment variables for terminal size are validated and the program aborts if the terminal is too small. [Seen in: Purchase-Main.]  
Command line arguments are parsed and stored in WS‑Calling‑Data; if arguments are invalid, an error message is shown. [Seen in: zz020-Get-Program-Args.]

5.3 Core Processing  
Path: Auto‑run trigger  
Trigger: WS‑CD‑Args starts with “xl150”.  
Key steps: set WS‑Called to “xl150”, set WS‑Caller to “purchase”, perform Load00, then go to Pre‑OverRewrite.  
I/O: calls to PL programs via Load00 (e.g., pl000, pl020).  
Outcomes: may rewrite system records and set ws‑term‑code.  
[Seen in: Purchase-Main.]

Path: General Menu Dispatch  
Trigger: User selects a letter from the menu.  
Key steps: map reply to index z, dispatch to load01–load22 or loadsr based on z.  
I/O: calls to PL programs (pl000, pl010, pl015, …, pl190).  
Outcomes: sets ws‑term‑code, may rewrite system records, and returns to menu or exits.  
[Seen in: load-it.]

Path: End‑of‑Cycle Processing  
Trigger: Menu reply “T”.  
Key steps: if ws‑term‑code = 3 go to load20a; otherwise call pl140 then Load00; in load20a call xl150, possibly loop back to load20a.  
I/O: calls to pl140, xl150, pl130.  
Outcomes: may set ws‑term‑code, may rewrite system records, and may return to menu.  
[Seen in: load20.]

5.4 Termination  
When the user selects exit or after a forced run, the program performs any pending backup script execution and then terminates with GOBACK. [Seen in: pre-overrewrite.]  
All open files are closed and the program returns to the caller via GOBACK. [Seen in: overclose.]

---
## purchLD
*[179/267]*

### Business/Functional Perspective
### Purchase File Loader

**Program Purpose**  
The Purchase File Loader imports purchase records from a designated source file into the company’s MySQL database. It verifies that the source file and database connection are correctly configured before proceeding, preventing accidental data loss or corruption. By automatically inserting or updating records, the program keeps the financial data current and eliminates manual entry mistakes. After completion it reports how many records were read, inserted, or updated, providing a quick audit trail for the user.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the purchase file cannot be found or opened, the program stops and displays a “no purchase file present” message.  
- If the system configuration file is missing or corrupted, or if database credentials are not set, the program halts with an error message indicating that the database is not configured.  
- During loading, duplicate records are skipped; a notification is shown for each duplicate encountered.  
- Any write error to the database (e.g., constraint violation, connection problem) causes the program to abort and report the specific failure.  
- Successful completion shows the total number of records read, inserted, rewritten, and the number of log entries written.  
- If a rollback or commit fails, the program reports the failure but continues to finish processing any remaining records.

**User Flow Summary**  
The user initiates the loader (typically via a command line or script). The program first reads system parameters to confirm database settings. It then attempts to open the purchase data file; if the file is missing, the process stops immediately. If the file is present, the program reads each record in turn, inserting it into the MySQL table or updating an existing entry when a duplicate key is found. Throughout execution, status messages are sent to the system log, and any errors are reported immediately. Once all records have been processed, the program outputs a summary of records processed and closes all files and database connections before terminating.

**Program Linkages**  
- acas-get-params  
- acas022  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-main-start, obtains command line arguments, sets up logging, and opens the system parameter file. [Seen in: aa000-main-start.]  
It reads the system record to load database connection parameters, optionally overriding with acas.param if needed, then opens the Cobol purchase file and the MySQL purchase table via acas022 calls. [Seen in: aa010-Proc-Override.]  
The main processing loop reads each purchase record, writes it to the MySQL table, handles duplicate key conditions, and on completion or error transitions to aa999-Finish for cleanup. [Seen in: aa010-Read.]

5.2 Initialization  
The program initializes working storage, sets logging system and file numbers, and performs zz020-Get-Program-Args to capture command line arguments. [Seen in: aa000-main-start.]  
It opens the System-File, reads the first record, and if necessary loads RDB parameters from acas.param, then prepares the file access flags before opening the purchase file and RDB. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  

Path: System File Read & DB Setup  
Trigger: Successful open and read of System-File, and RDBMS-DB-Name not spaces.  
Key steps: open System-File, read record, load RDB parameters, call acas-get-params if needed, set up logging, go to aa010-Proc-Override.  
I/O: System-File.  
Outcomes: RDB parameters loaded, File-System-Used flags set, ready for purchase file open.  
[Seen in: aa000-main-start, aa010-Proc-Override.]

Path: Purchase File Not Found  
Trigger: acas022-Open-Input returns FS-Reply 35.  
Key steps: detect FS-Reply 35, output message “Terminating nothing to do”, close System-File, close purchase file, goback.  
I/O: Purchase file via acas022-Open-Input.  
Outcomes: Program exits without processing.  
[Seen in: aa010-Proc-Override.]

Path: RDB Open Failure  
Trigger: acas022-Open returns FS-Reply not zero.  
Key steps: detect error, output message, close System-File, close purchase file, set File-System-Used to zero, goback.  
I/O: RDB via acas022-Open.  
Outcomes: Program exits with error.  
[Seen in: aa010-Proc-Override.]

Path: Normal Record Processing  
Trigger: acas022-Read-Next returns FS-Reply zero (record read).  
Key steps: increment input count, write record to RDB via acas022-Write, handle duplicate key, increment output count, loop.  
I/O: Purchase file read, RDB write.  
Outcomes: Records transferred, counts updated.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: SQL-State = “23000” or FS-Reply 22 or 99 or SQL-Err 1062/1022.  
Key steps: reset FS-Reply, WE-Error, rewrite record, if rewrite fails output error messages, else increment rewrite count, continue loop.  
I/O: RDB write/rewrite.  
Outcomes: Duplicate records skipped, rewrite count incremented.  
[Seen in: aa010-Read.]

Path: General Error Handling  
Trigger: FS-Reply not zero after write (non-duplicate).  
Key steps: output error messages, set return-code 16, go to aa999-Finish.  
I/O: RDB write.  
Outcomes: Program terminates with error.  
[Seen in: aa010-Read.]

5.4 Termination  
At aa999-Finish, the program prints record counts, closes the RDB and purchase files, closes the System-File, and returns to the caller. [Seen in: aa999-Finish.]  
The final status is set via return-code, and the program ends with a GOBACK. [Seen in: aa999-Finish.]

---
## purchMT
*[180/267]*

### Business/Functional Perspective
### Purchase Ledger Data Access  

**Program Purpose**  
This program provides a single entry point for all create, read, update and delete operations on the purchase ledger.  It opens and closes a connection to the database, then carries out the requested function – from starting a query to writing a new supplier record.  By centralising the database access the system guarantees that supplier information is stored consistently, that duplicate entries are prevented, and that any errors are captured for audit and troubleshooting.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – the requested operation completes and a record (if applicable) is returned.  
- **Duplicate record** – an attempt to add a supplier with an existing key is rejected.  
- **Record not found** – the key specified for a read, update or delete does not exist.  
- **End of data** – a read‑next operation reaches the end of the result set.  
- **Invalid key or function** – the key format or function code is inappropriate.  
- **Database connection error** – the system cannot connect to or communicate with the database.  
- **SQL error** – any database‑level error such as a constraint violation or syntax problem.  

**User Flow Summary**  
1. The calling module supplies a record (the supplier data) and a function code that indicates the desired action: open, close, start a query, read the next record, read by key, write a new record, rewrite an existing record, or delete a record.  
2. The program opens the database connection (if required) and executes the SQL command that matches the requested action.  
3. For a read or read‑next, the program returns the supplier record that matches the key or the next record in the current cursor.  
4. For write or rewrite, the supplied record is inserted or updated; duplicate or constraint errors are flagged.  
5. For delete, the record identified by the key is removed.  
6. After the operation, the program returns status codes indicating success or the type of failure, and any resulting record data.  

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **ba-ACAS-DAL-Process** paragraph, accepting linkage areas and setting screen exceptions. [Seen in: ba-ACAS-DAL-Process.]  
It initializes environment variables and clears status fields in **ba010-Initialise**, then evaluates **File-Function** to dispatch to the appropriate processing paragraph. [Seen in: ba010-Initialise.]  
After the selected processing paragraph completes, control returns to **ba999-end** for final logging (if enabled) and program exit. [Seen in: ba999-end.]

5.2 Initialization  
The **ba-ACAS-DAL-Process** paragraph sets environment variables for screen handling and initializes the line counters. [Seen in: ba-ACAS-DAL-Process.]  
The **ba010-Initialise** paragraph clears all status and error fields (WS-MYSQL-Error-Message, SQL-Err, etc.) and prepares the record buffer for use. [Seen in: ba010-Initialise.]

5.3 Core Processing  

Path: Process-Open  
Trigger: File-Function = 1  
Key steps: Builds connection strings, performs MYSQL-1000-OPEN, and sets cursor status.  
I/O: MYSQL-1000-OPEN (database connection).  
Outcomes: fs-reply set to 0 on success; otherwise jumps to ba999-end.  
[Seen in: ba020-Process-Open.]

Path: Process-Close  
Trigger: File-Function = 2  
Key steps: Frees any active cursor via ba998-Free, then performs MYSQL-1980-CLOSE.  
I/O: MYSQL-1980-CLOSE (database close).  
Outcomes: fs-reply set to 0; cursor marked inactive.  
[Seen in: ba030-Process-Close.]

Path: Process-Read-Next (first read)  
Trigger: File-Function = 3 or 31  
Key steps: If no cursor active, constructs a SELECT with ORDER BY PURCH-NAME, executes MYSQL-1210-COMMAND, stores result, and fetches first record.  
I/O: MYSQL-1210-COMMAND, MYSQL-1220-STORE-RESULT, MYSQL-1239-EXIT, MYSQL-fetch_record.  
Outcomes: fs-reply set to 10 on EOF; cursor marked active; record loaded into Purch-Rec.  
[Seen in: ba040-Process-Read-Next, ba141-Reread.]

Path: Process-Read-Indexed  
Trigger: File-Function = 4  
Key steps: Builds a SELECT WHERE key = Purch-Rec, executes command, stores result, fetches record.  
I/O: MYSQL-1210-COMMAND, MYSQL-1220-STORE-RESULT, MYSQL-1239-EXIT, MYSQL-fetch_record.  
Outcomes: fs-reply set to 21 if key not found; otherwise record loaded and cursor active.  
[Seen in: ba050-Process-Read-Indexed.]

Path: Process-Write  
Trigger: File-Function = 5  
Key steps: Loads HV fields from Purch-Rec, constructs INSERT statement via bb200-Insert, executes command.  
I/O: MYSQL-1210-COMMAND.  
Outcomes: fs-reply set to 0 on success; duplicate key sets fs-reply to 22; other errors set fs-reply to 99.  
[Seen in: ba070-Process-Write, bb200-Insert.]

Path: Process-Delete  
Trigger: File-Function = 8  
Key steps: Builds DELETE WHERE key = Purch-Rec, executes command.  
I/O: MYSQL-1210-COMMAND.  
Outcomes: fs-reply set to 0 on success; if rows affected ≠ 1, sets fs-reply to 99 and WE-Error to 995.  
[Seen in: ba080-Process-Delete.]

5.4 Termination  
The **ba999-end** paragraph performs optional logging via Ca-Process-Logs if Testing-1 is set, then exits the program. [Seen in: ba999-end.]  
All open cursors are freed by **ba998-Free** before termination, ensuring no resource leaks. [Seen in: ba998-Free.]

---
## purchRES
*[181/267]*

### Business/Functional Perspective
### Purchase File Backup  

**Program Purpose**  
The program copies purchase records from a sequential file into a target purchase file, effectively creating a backup or restoring data after changes to the underlying database library. It writes each record from the source file to the destination file, counts the records processed, and records the results in a system log. This routine ensures that purchase data can be reliably transferred or recovered, supporting data integrity, audit trails, and compliance with data retention requirements.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the source purchase file does not exist, the program logs “No Purchase file to process.”  
- If opening the source or destination files fails, it logs an error message indicating the failure.  
- If a record cannot be read, it logs “Problem reading .seq file” followed by the error details.  
- If a record cannot be written, it logs “SYS06 Write error on .dat file.”  
- Upon completion, it logs the total number of records read and written (“Records in = X Records Total out = Y”).  

**User Flow Summary**  
A user or automated job launches the program with the required command‑line arguments. The program attempts to open the sequential purchase file for reading. For each record, it writes the record to a target purchase file and updates an internal count. If any error occurs during reading or writing, the program logs an appropriate message and terminates. When all records are processed successfully, the program logs the total counts and exits, returning control to the calling context or batch job.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-Main-Start, retrieves command line arguments, configures logging, and writes initial status to sysout. [Seen in: aa000-Main-Start.]  
It opens the sequential purchase file for input, checks for errors, then opens an output file for writing, handling any open failures. [Seen in: aa000-Main-Start.]  
The program enters a loop that reads each record from the input file, writes it to the output file, and counts records, terminating on end‑of‑file or error, then performs cleanup and exits. [Seen in: aa010-Read-Recs.]

5.2 Initialization  
The initialization phase performs zz020-Get-Program-Args, sets logging system and file numbers, and outputs a start message via Call‑Sysout. [Seen in: aa000-Main-Start.]  
It opens the input file Purchase‑File‑Seq, verifies FS‑Reply, and if successful opens the output file Purchase‑File, initializing record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read‑Records  
Trigger: Loop in aa010‑Read‑Recs until end‑of‑file or error.  
Key steps: read next record, check FS‑Reply, write to output, check FS‑Reply, increment input and output counters.  
I/O: Purchase‑File‑Seq (input), Purchase‑File (output).  
Outcomes: counters updated, error messages logged, exit to aa020‑Finish‑Off on error or EOF.  
[Seen in: aa010‑Read‑Recs.]  

Path: Finish‑Off  
Trigger: End‑of‑file or error condition leading to aa020‑Finish‑Off.  
Key steps: close both files, build summary string with record counts, output via Call‑Sysout, set Return‑Code to zero, goback.  
I/O: close Purchase‑File‑Seq and Purchase‑File.  
Outcomes: program terminates, summary logged, return code set.  
[Seen in: aa020‑Finish‑Off.]

5.4 Termination  
On termination, the program closes both input and output files, logs a final summary of records processed, and writes a “CLOSE” message. [Seen in: aa020‑Finish‑Off.]  
It then sets Return‑Code to zero and performs goback to exit the program. [Seen in: aa020‑Finish‑Off.]

---
## purchUNL
*[182/267]*

### Business/Functional Perspective
### Purchase File Backup  

**Program Purpose**  
This program creates a sequential backup of the system’s Purchase file. It copies every record from the existing Purchase ISAM file into a new sequential file named *purchled.seq*. The backup supports quick restoration, audit trails, and protects against data loss from file corruption. By logging the process, it also gives administrators clear visibility into how many records were processed and whether any issues occurred.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *No file to process*: the program reports that the Purchase file cannot be found and stops.  
- *Read error*: if a record cannot be read, the program logs a problem message and stops.  
- *Write error*: if a record cannot be written to the backup file, the program logs a write error and stops.  
- *Incorrect arguments*: if the user supplies invalid command‑line arguments, a brief error message is shown.  
- *Missing environment setup*: if required system variables are not set, the program aborts with a notice.  

**User Flow Summary**  
A user or automated process runs the program from the command line or a batch job. The program begins by announcing that it will back up the Purchase file. It opens the source Purchase file, then reads each record one by one, writing each to the new *purchled.seq* file while keeping a count of records processed. Throughout, it logs progress and any errors that occur. When all records have been copied, the program closes both files, logs the total number of records read and written, and then terminates. The resulting sequential file can be used later for recovery or audit purposes.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by performing argument retrieval and logging initialization in paragraph aa000-Main-Start. [Seen in: aa000-Main-Start.]  
It then opens the source Purchase file, verifies its availability, and opens a sequential output file for the backup records. [Seen in: aa000-Main-Start.]  
A loop in paragraph aa010-Read-Recs reads each Purchase record, writes it to the sequential file, and tracks record counts until end‑of‑file or an error occurs, after which control passes to aa020-Finish-Off for cleanup. [Seen in: aa010-Read-Recs.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command‑line parameters and sets logging identifiers (WS-Log-System, WS-Log-File-no). [Seen in: aa000-Main-Start.]  
It logs an initial message via Call‑Sysout and opens the input Purchase file, checking FS‑Reply for errors before proceeding. [Seen in: aa000-Main-Start.]  
Upon successful opening, it opens the output sequential file Purchase‑File‑Seq and initializes record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read and Write Records  
Trigger: Loop in aa010‑Read‑Recs reading Purchase‑File until end‑of‑file or FS‑Reply error.  
Key steps: read next record, check FS‑Reply, write record to Purchase‑File‑Seq, check FS‑Reply, increment input and output counters, handle errors by logging and jumping to finish.  
I/O: Purchase‑File, Purchase‑File‑Seq.  
Outcomes: record counts updated, error messages logged, control transferred to aa020‑Finish‑Off on error or EOF.  
[Seen in: aa010-Read-Recs.]

Path: Finish Off  
Trigger: End‑of‑File or error condition causes jump to aa020‑Finish‑Off.  
Key steps: close both files, compose summary message with record counts, log the summary and a “CLOSE” message, set Return‑Code to zero, and goback.  
I/O: Purchase‑File, Purchase‑File‑Seq.  
Outcomes: files closed, final status logged, program exits cleanly.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both the input and output files, logs a final summary of records processed, and performs a GOBACK to terminate. [Seen in: aa020-Finish-Off.]  
It sets Return‑Code to zero before exiting, indicating successful completion. [Seen in: aa020-Finish-Off.]

---
## sales
*[183/267]*

### Business/Functional Perspective
### Sales Ledger System Menu  

#### Program Purpose  
This program presents the main menu for the Applewood Sales Ledger System. It validates the user’s terminal size, loads system parameters, and allows a user to select a wide range of ledger and reporting functions by entering a single letter. The menu also displays the current date and time, the operating system, and a backup‑script status. By selecting an option the user invokes the appropriate sales or finance routine, and the menu re‑appears until the user chooses to exit, which triggers a backup script and ends the program.  

#### Screen Interactions  
1. **Main Menu Screen** –  
   * Title: “Sales Ledger System Menu”  
   * Current date and time displayed.  
   * Operating system and backup‑script status displayed.  
   * List of selectable options:  
     - (A) Date Entry  
     - (B) Customer File Maintenance  
     - (C) Sales Ledger Enquiry  
     - (D) Sales Transactions Input  
     - (E) Sales Transactions Amend  
     - (F) Sales Transactions Proof  
     - (G) Sales Transactions Post  
     - (H) Payment Input  
     - (I) Payment Amend  
     - (J) Payment Proof  
     - (K) Payment Post  
     - (L) Set‑Up Sales Analysis Codes  
     - (M) Sales Analysis Report  
     - (N) Sales Day Book  
     - (O) Statement Production  
     - (P) Dunning Letters Generation  
     - (Q) Aged Debtors Analysis  
     - (R) Alphabetical Customer List  
     - (S) Customer Turnover Report  
     - (T) Invoice Sub‑System  
     - (U) End of Cycle Processing  
     - (V) Customer File Dump  
     - (X) Exit To  
   * If permitted, a (Z) System Setup option appears.  
   * The user types a letter (case‑insensitive) to select an option.  

No other screens are displayed directly by the program.  

#### Messages and Errors  
* If the terminal is shorter than 24 lines or narrower than 80 columns, a message is shown explaining the requirement and the program stops.  
* If the required backup script cannot be found, a notice is displayed.  
* Selecting the restricted System Setup option when not allowed results in a “Not permitted” message.  
* Choosing an unavailable option (e.g., a future feature) displays “Sorry not available.”  

#### User Flow Summary  
1. The user starts the program.  
2. The program checks terminal size; if insufficient, it displays an error and ends.  
3. System parameters are loaded and the current date, time, OS, and backup‑script status are displayed on the main menu.  
4. The user enters a letter to choose a function.  
5. The program invokes the routine associated with that letter (for example, selecting (D) runs the sales transactions input routine).  
6. After the routine completes, the menu re‑appears, allowing the user to make another selection.  
7. Selecting (X) exits the menu: a backup script is executed and the program terminates.  
8. If the user selects (Z) System Setup (and it is permitted), system records and parameters are updated; control then returns to the main menu.  

#### Program Linkages  
- maps04  
- CBL_CHECK_FILE_EXIST  
- SYSTEM  
- Dynamic: ws-called   *(stores program names such as sl000, sl010, xl150, etc.)*

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in Sales-Main, sets screen exception flags, reads terminal size, and opens the system parameter file. [Seen in: Sales-Main.]  
It then displays a menu, accepts user input, and dispatches to the appropriate load paragraph based on the selected letter. [Seen in: accept-loop.]  
After executing the chosen routine, control returns to the menu until the user selects Exit, at which point the program performs a backup and terminates. [Seen in: pre-overrewrite.]

5.2 Initialization  
Sales-Main performs environment checks for terminal columns and lines, aborting if they are below required values. [Seen in: Sales-Main.]  
It initializes date and time variables, opens the system parameter file via System-Open, and reads system records into working storage. [Seen in: Sales-Main, Open-System, aa010-Get-System-Recs.]  
If command‑line arguments indicate an auto‑run (e.g., xl150), it sets up the call parameters and jumps to the auto‑run path. [Seen in: Sales-Main.]

5.3 Core Processing  

Path: Auto‑run xl150  
Trigger: WS-CD-Args (1:5) = "xl150" in Sales-Main.  
Key steps: set WS-Called to "xl150", set caller, perform Load00, go to Pre-OverRewrite.  
I/O: calls program xl150 via Load00, uses system parameter file.  
Outcomes: backup script is executed and program exits.  
[Seen in: Sales-Main.]

Path: Menu Dispatch  
Trigger: User selects a letter in accept-loop.  
Key steps: map letter to z, go to load-it, which performs the corresponding load paragraph (e.g., load01 for A, load07 for G, etc.).  
I/O: calls various slxxxx programs through Load00 or Load000.  
Outcomes: selected routine runs and returns to menu or exits.  
[Seen in: accept-loop, load-it.]

Path: Sales Transaction Posting  
Trigger: Menu letter G triggers load07.  
Key steps: perform Load00 with sl830, then perform Load000 with sl055, then perform Load000 with sl060.  
I/O: calls sl830, sl055, sl060 programs.  
Outcomes: sales transactions are posted and control returns to menu.  
[Seen in: load07.]

Path: End‑of‑Cycle Processing  
Trigger: Menu letter U triggers pre-overrewrite.  
Key steps: build backup command, call SYSTEM to execute backup script, goback.  
I/O: backup script file, system call.  
Outcomes: backup performed and program terminates.  
[Seen in: pre-overrewrite.]

Path: System Setup  
Trigger: Menu letter Z triggers call-system-setup.  
Key steps: call ws-called "sys002" to write system records, rewrite system file, then re‑open system file.  
I/O: system parameter file.  
Outcomes: system records updated, control returns to menu.  
[Seen in: call-system-setup.]

5.4 Termination  
Upon selecting Exit or completing an auto‑run, the program executes the backup script via SYSTEM and then performs GOBACK to terminate. [Seen in: pre-overrewrite.]  
If a system setup routine terminates with a non‑zero term code, the program stops immediately. [Seen in: call-system-setup.]

---
## salesLD
*[184/267]*

### Business/Functional Perspective
### Sales Table Load  

**Program Purpose**  
The program reads a pre‑formatted sales file and loads each record into the MySQL sales table used by the accounting system. It validates the database connection, checks for duplicate keys, and writes detailed status information back to the console or log. The process ensures that only unique, correctly formatted sales data is persisted, which keeps the financial records accurate and compliant with business rules.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Configuration issues** – if the system parameter file cannot be read or does not contain database details, the program stops and reports the missing configuration.  
- **File access problems** – if the sales file is missing, cannot be opened, or cannot be read, the program terminates after displaying an appropriate error.  
- **Duplicate records** – when a record already exists in the database, the program logs the duplicate and continues without inserting the record.  
- **Database write errors** – any failure to write a record (other than a duplicate) is reported with the database error message, and the program aborts the load.  
- **General failures** – any unexpected reply from the file or database routines causes the program to log the error details and terminate.  

**User Flow Summary**  
A user runs the program, usually via a command line or script, after the sales file has been prepared. The program first reads system settings to obtain the MySQL connection parameters. It then opens the sales file and the target database table. Each record from the file is processed: if the record is valid and does not duplicate an existing entry, it is inserted into the table; if it duplicates an existing key, the program counts it as skipped. Any errors encountered during file access or database operations are logged, and the program halts. Upon completion, it reports the total number of records processed, written, rewritten, and skipped, and confirms that the load has finished successfully.  

**Program Linkages**  
- acas-get-params  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-main-start, retrieves command line arguments and logs the program name. [Seen in: aa000-main-start.]  
It opens the system parameter file, reads database configuration, and if necessary loads acas.param to obtain RDBMS connection details. [Seen in: aa000-main-start.]  
The program then opens the Cobol sales file for input and the MySQL sales table for writing, entering a loop that reads each sales record and attempts to insert it into the database. [Seen in: aa010-Proc-Override, aa010-Read.]

5.2 Initialization  
Initialization includes setting logging system and file numbers, initializing counters, and performing aa000-main-start's environment setup. [Seen in: aa000-main-start.]  
The program opens the system file, checks for errors, and may invoke acas-get-params to obtain RDBMS parameters if the system record indicates Cobol files only. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: No Sales File  
Trigger: acas012-Open-Input returns FS-Reply = 35.  
Key steps: log “Terminating nothing to do”, close system file, close sales file, exit.  
I/O: System-File, Sales file.  
Outcomes: program exits with no records processed.  
[Seen in: aa010-Proc-Override.]

Path: Normal Read/Write Loop  
Trigger: acas012-Read-Next returns FS-Reply = 0 and WS-Sales-Key not zero.  
Key steps: increment input counter, write record to RDB, handle duplicate key or error, increment output or rewrite counter, continue loop.  
I/O: Sales file, RDB.  
Outcomes: counters updated, duplicates handled, records written.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: SQL-State = "23000" or FS-Reply = 22 or 99 or SQL-Err = "1062" or "1022".  
Key steps: rewrite record, increment rewrite counter, continue loop.  
I/O: RDB.  
Outcomes: duplicate record rewritten, counters updated.  
[Seen in: aa010-Read.]

Path: Write Error (Non‑Duplicate)  
Trigger: FS-Reply not zero after write.  
Key steps: log error details, set return-code, exit loop.  
I/O: RDB.  
Outcomes: program exits with error status.  
[Seen in: aa010-Read.]

Path: End of File  
Trigger: FS-Reply = 10.  
Key steps: go to aa999-Finish.  
I/O: Sales file.  
Outcomes: finish processing.  
[Seen in: aa010-Read.]

5.4 Termination  
Finalization in aa999-Finish logs record counts, closes the RDB and sales files, and returns control to the caller. [Seen in: aa999-Finish.]  
The program ends with a GOBACK, having reset file system usage flags and set the return-code appropriately. [Seen in: aa999-Finish.]

---
## salesMT
*[185/267]*

### Business/Functional Perspective
### Sales Ledger File Access  

**Program Purpose**  
The program provides a reliable interface for managing sales ledger records. It enables higher‑level application modules to open and close the sales ledger table, locate records by key, read records sequentially, insert new entries, update existing ones, and delete unwanted records. By handling database interactions and error conditions internally, it ensures that customer sales information remains accurate, consistent, and available for reporting, compliance and audit purposes.  

**Screen Interactions**  
No direct screens. This program is invoked by other application modules after data has been entered and returns results back to that context.  

**Messages and Errors**  
- **Success** – The requested operation completes without issue and the requested record or status is returned.  
- **Record not found** – A search or read operation could not locate a matching record.  
- **Duplicate key** – An attempt to insert a record that already exists fails.  
- **End of data** – Sequential reads have reached the end of the dataset.  
- **Invalid key or parameters** – The supplied key or function code is inappropriate or out of range.  
- **Database error** – A problem with the underlying database occurs, such as a connection failure or SQL error.  

**User Flow Summary**  
When a user initiates an operation on the sales ledger, the application module calls this program with a record and a function code. For a **read next** request, the program returns the next record in sequence; if no records remain, it indicates end‑of‑data. For a **read indexed** request, it retrieves a record that matches a supplied key. To **write** a new record, the program inserts the data into the database; if the key already exists it reports a duplicate error. A **rewrite** call updates the existing record’s fields, while a **delete** call removes the record. After all operations are complete, the module calls the program to **close** the table. Throughout, the program supplies clear status information and any error messages so the user or calling module can respond appropriately.  

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
On entry, the program initializes environment and prepares linkage areas. [Seen in: ba-ACAS-DAL-Process.]  
It evaluates the File-Function value to dispatch to one of the operation paragraphs such as Open, Close, Read‑Next, Start, Write, Delete, etc. [Seen in: ba-ACAS-DAL-Process.]  
After performing the requested operation, it performs any cleanup and exits via ba999‑end. [Seen in: ba999-end.]

5.2 Initialization  
The program accepts screen line count and sets environment exception flags for screen handling. [Seen in: ba-ACAS-DAL-Process.]  
It initializes key variables such as WS‑MYSQL‑Error‑Message, WS‑MYSQL‑Error‑Number, WS‑Log‑Where, WS‑File‑Key, SQL‑Msg, SQL‑Err, and SQL‑State to spaces or zero. [Seen in: ba-ACAS-DAL-Process.]  
It performs a preliminary evaluation of File‑Function to determine the operation path. [Seen in: ba-ACAS-DAL-Process.]

5.3 Core Processing  
Path: Open  
Trigger: File‑Function = 1  
Key steps: Build MySQL connection strings from linkage areas, perform MYSQL‑1000‑OPEN, set cursor state, set WS‑File‑Key to “OPEN SALEDGER”.  
I/O: MySQL connection (via MYSQL‑1000‑OPEN).  
Outcomes: fs‑reply set to 0 if success else go to ba999‑end.  
[Seen in: ba020-Process-Open.]

Path: Close  
Trigger: File‑Function = 2  
Key steps: If cursor active, free cursor via ba998‑Free, perform MYSQL‑1980‑CLOSE, set WS‑File‑Key to “CLOSE SALEDGER”.  
I/O: MySQL close (MYSQL‑1980‑CLOSE).  
Outcomes: fs‑reply set to 0, exit.  
[Seen in: ba030-Process-Close.]

Path: Read‑Next  
Trigger: File‑Function = 3 or 31  
Key steps: If cursor not active, construct SELECT query with key >= “0000000” and ORDER BY SALES‑KEY or SALES‑NAME, execute SELECT, fetch first row, set cursor active; if cursor active, fetch next row.  
I/O: MySQL SELECT, FETCH, FREE.  
Outcomes: fs‑reply 0, WE‑Error 0, WS‑File‑Key set to key, or 10 for EOF.  
[Seen in: ba040-Process-Read-Next, ba041-Reread, ba140-Process-Read-Next, ba141-Reread.]

Path: Start  
Trigger: File‑Function = 9  
Key steps: Validate access‑type, set up key and relation, construct SELECT with appropriate comparison, execute SELECT, set cursor active if rows found.  
I/O: MySQL SELECT.  
Outcomes: fs‑reply 0, WE‑Error 0, WS‑File‑Key set to key, or 21 for key not found.  
[Seen in: ba060-Process-Start.]

Path: Write  
Trigger: File‑Function = 5  
Key steps: Load host variables from WS‑Sales‑Record, build INSERT statement, execute INSERT, check row count.  
I/O: MySQL INSERT.  
Outcomes: fs‑reply 0, WE‑Error 0, or 22 for duplicate key.  
[Seen in: ba070-Process-Write, bb200-Insert.]

Path: Delete  
Trigger: File‑Function = 8  
Key steps: Build DELETE statement with key, execute DELETE, check row count.  
I/O: MySQL DELETE.  
Outcomes: fs‑reply 0, WE‑Error 0, or 995 for SQL error.  
[Seen in: ba080-Process-Delete.]

5.4 Termination  
After completing the operation, the program performs any pending logging via Ca‑Process‑Logs if testing flag set. [Seen in: ba999-end.]  
It then exits the program with exit program. [Seen in: ba999-exit.]

---
## salesRES
*[186/267]*

### Business/Functional Perspective
### Sales File Restoration  

**Program Purpose**  
The program copies all sales records from a sequential backup file (`salesled.seq`) into the primary sales database file. It checks that the backup file exists, writes each record to the database, and logs the progress and any problems encountered. The record counts are reported for audit and traceability. This restores or migrates sales data quickly and reliably, helping to maintain data integrity and comply with recovery procedures.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- The program reports if the backup file cannot be opened, indicating “No Sales file to process.”  
- If a read or write operation fails, it logs a message that a record could not be processed.  
- If the environment variables required for logging are not set, the program stops and logs an abort message.  
- General system errors (e.g., file‑access problems) are logged with a descriptive message.  

**User Flow Summary**  
1. The user runs the program, optionally supplying command‑line arguments (which are not otherwise used).  
2. The program opens the backup sequential file; if it cannot be opened, a message is logged and the program exits.  
3. It opens the target sales database file and begins copying each record.  
4. Any read or write error causes an error message to be logged and the program stops.  
5. When all records have been processed, the program logs the total number of records read and written, then terminates.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins by retrieving command line arguments, initializing logging parameters, and writing a startup message. [Seen in: aa000-Main-Start.]  
It then attempts to open the sequential sales source file for input and the target ISAM file for output, handling any open errors by logging and terminating. [Seen in: aa000-Main-Start.]  
If both files open successfully, the program reads each record from the source, writes it to the target, counts records, and upon reaching end‑of‑file logs totals before exiting. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line parameters and sets logging system and file numbers for the ACAS logger. [Seen in: aa000-Main-Start.]  
It then writes a startup message to the system output via Call‑Sysout and initializes record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal-Processing  
Trigger: Successful opening of both Sales-File-Seq and Sales-File.  
Key steps: Loop reading each record, writing to Sales-File, incrementing input and output counters, checking FS-Reply after read and write.  
I/O: Sales-File-Seq, Sales-File.  
Outcomes: All records copied, counters updated, no error flags set.  
[Seen in: aa010-Read-Recs.]

Path: Input-File-Not-Found  
Trigger: FS-Reply not zeros after opening Sales-File-Seq.  
Key steps: Log "No Sales file to process", close Sales-File-Seq, log close, goback.  
I/O: Sales-File-Seq.  
Outcomes: Program terminates without processing.  
[Seen in: aa000-Main-Start.]

Path: Output-File-Open-Failure  
Trigger: FS-Reply not zeros after opening Sales-File.  
Key steps: Log failure message with FS-Reply, close Sales-File and Sales-File-Seq, goback.  
I/O: Sales-File.  
Outcomes: Program terminates.  
[Seen in: aa000-Main-Start.]

Path: Read-Error  
Trigger: FS-Reply not zeros during read in aa010-Read-Recs.  
Key steps: Log SY003 with FS-Reply, close files, goback.  
I/O: Sales-File-Seq.  
Outcomes: Program terminates.  
[Seen in: aa010-Read-Recs.]

Path: Write-Error  
Trigger: FS-Reply not zero after write to Sales-File.  
Key steps: Log SY006, close files, goback.  
I/O: Sales-File.  
Outcomes: Program terminates.  
[Seen in: aa010-Read-Recs.]

Path: End-Of-File  
Trigger: End of file reached in aa010-Read-Recs.  
Key steps: Close both files, log record counts, log close, set Return-Code to zero, goback.  
I/O: Sales-File-Seq, Sales-File.  
Outcomes: Program exits normally.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
On normal completion, the program closes both files, logs the total records processed, and returns zero before exiting. [Seen in: aa020-Finish-Off.]  
In error conditions, it logs the error, closes any open files, and exits immediately via GOBACK. [Seen in: aa000-Main-Start, aa010-Read-Recs.]

---
## salesUNL
*[187/267]*

### Business/Functional Perspective
### Sales File Unload  

**Program Purpose**  
This program creates a backup copy of the current Sales data file by writing all sales records to a new sequential file (`salesled.seq`). It logs the operation and record counts to a system display file, providing an audit trail for compliance and recovery. The backup ensures that a consistent, recoverable copy of the Sales file exists in case of data corruption, system failure, or library changes.  

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry or batch step and returns results only through log files.  

**Messages and Errors**  
- *Missing Sales File*: “No Sales file to process” – the program stops if the source file is not available.  
- *Read Error*: If a record cannot be read, a message indicating a problem reading the Sales file is logged and the process terminates.  
- *Write Error*: “Write error on .seq file” is logged if a record cannot be written to the backup file.  
- *Argument Error*: Incorrect command‑line arguments produce a message stating the arguments are incorrect.  
- *Environment Error*: If required environment variables are not set, the program logs a message and aborts.  

**User Flow Summary**  
The user (or a scheduler) runs the program, optionally passing command‑line arguments. The program logs its start and the files in use. It attempts to open the active Sales file; if unavailable, it logs an error and stops. Otherwise, it opens a new sequential file and copies each sales record to it, counting input and output records. Any read or write problems cause the program to log an error and stop. After all records are processed, the program logs the total counts, closes both files, and exits successfully.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-Main-Start, retrieves command line arguments, sets logging, and writes a header to the log. [Seen in: aa000-Main-Start.]  
It opens the source Sales file for input, checks for errors, and if none, opens the destination sequential file for output. [Seen in: aa000-Main-Start.]  
It then reads each record from the source, writes it to the destination, counts records, handles read/write errors, and finally closes files and logs a summary before exiting. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and initializes logging parameters. [Seen in: aa000-Main-Start.]  
It sets the logging system to Sales (3) and log file number to 11, clears the output buffer, and writes a header message via Call-Sysout. [Seen in: aa000-Main-Start.]  
It opens the Sales-File for input and, if successful, opens Sales-File-Seq for output, resetting record counters to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read-Records-Loop  
Trigger: Successful open of Sales-File and Sales-File-Seq  
Key steps: loop reading each record, increment input counter, write to output, increment output counter, check FS-Reply after read and write.  
I/O: Sales-File, Sales-File-Seq  
Outcomes: record counts, possible error flags leading to finish.  
[Seen in: aa010-Read-Recs, aa020-Finish-Off.]  

Path: Error-Read  
Trigger: FS-Reply not zero after reading a record  
Key steps: build error message with SY003 and FS-Reply, call Sysout, go to finish.  
I/O: Sales-File  
Outcomes: error message logged, exit to finish.  
[Seen in: aa010-Read-Recs.]  

Path: Error-Write  
Trigger: FS-Reply not zero after writing a record  
Key steps: set SO-Print to SY006, call Sysout, go to finish.  
I/O: Sales-File-Seq  
Outcomes: error message logged, exit to finish.  
[Seen in: aa010-Read-Recs.]  

Path: Finish-Off  
Trigger: End of file or error  
Key steps: close files, build summary string, call Sysout, set Return-Code zero, goback.  
I/O: Sales-File, Sales-File-Seq  
Outcomes: files closed, summary logged, program exits.  
[Seen in: aa020-Finish-Off.]  

5.4 Termination  
Upon completion or error, the program closes both the source and destination files, logs a final summary, sets Return-Code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]  
Any remaining cleanup such as freeing resources is handled implicitly by the GOBACK statement. [Seen in: aa020-Finish-Off.]

---
## send-mail-test-example
*[188/267]*

### Business/Functional Perspective
### Plain-Text Email Send  

**Program Purpose**  
This library enables a main‑frame application to send plain‑text e‑mail messages. It assembles the email header and body, writes the message to a temporary file, and then invokes the system sendmail utility to deliver the mail. The routine validates that the To‑address, Subject, and From‑address are supplied and reports problems such as missing fields or file‑system errors. By centralizing the e‑mail construction logic, it reduces the chance of inconsistent messages and simplifies audit tracking.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- “Missing To‑address” if the recipient field is blank.  
- “Missing Subject” if the message subject is empty.  
- “Missing From‑address” if the sender field is blank.  
- “Unable to open temporary file” when the file system cannot create the temp file.  
- “Error writing to temporary file” when a write operation fails.  
- “Error closing temporary file” when the file cannot be closed.  
- “Error occurred sending email” when the sendmail command fails.  
- “Unable to delete temporary file” if the temporary file cannot be removed.  

**User Flow Summary**  
A calling program first supplies the recipient address, subject line, and sender details and then calls **MAIL‑INIT** to prepare the temporary message file. After the header is written, the program issues one or more **MAIL‑WRITE‑BODY‑LINE** calls to append the body of the e‑mail. Finally, it invokes **MAIL‑SEND** to finish the message, close the temporary file, launch the system sendmail command, and delete the temporary file. If any step fails, the routine sets a descriptive error text that the caller can display to the user.  

**Program Linkages**  
- tmpnam  
- fopen  
- fputs  
- fclose  
- SYSTEM  
- remove

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The routine begins with **MAIL-INIT**, which validates required fields and creates a temporary file for the email body. [Seen in: MAIL-INIT.]  
After initialization, the caller typically invokes **MAIL-WRITE-HEADERS** to write the To, Subject, and Body headers into the temporary file. [Seen in: MAIL-WRITE-HEADERS.]  
Subsequent calls to **MAIL-WRITE-BODY-LINE** append message content line by line to the temporary file. [Seen in: MAIL-WRITE-BODY-LINE.]  
When the message is complete, **MAIL-SEND** writes the terminating dot line, closes the temporary file, builds the sendmail command, executes it, and then removes the temporary file. [Seen in: MAIL-SEND, MAIL-SEND-COMMAND, MAIL-SEND-CLEANUP.]

5.2 Initialization  
**MAIL-INIT** clears the error text, checks that MAIL-TO-ADDRESS, MAIL-SUBJECT, and MAIL-FROM-ADDRESS are not blank, and if any are missing sets an error message and exits. [Seen in: MAIL-INIT.]  
It then generates a unique temporary filename via tmpnam, opens it for writing, and writes the email headers into the file, setting MAIL-ERROR-TEXT on any failure. [Seen in: MAIL-INIT, MAIL-WRITE-HEADERS.]

5.3 Core Processing  
Path: Initialization & Header Writing  
Trigger: CALL to **MAIL-INIT**  
Key steps: validate required fields, generate temp file name, open temp file, write To, Subject, and Body headers.  
I/O: temporary file (MAIL-TEMP-FILE-POINTER).  
Outcomes: temp file pointer set, MAIL-ERROR-TEXT populated on error.  
[Seen in: MAIL-INIT, MAIL-WRITE-HEADERS.]

Path: Body Line Writing  
Trigger: CALL to **MAIL-WRITE-BODY-LINE**  
Key steps: validate temp file pointer, format body line with newline, write to temp file.  
I/O: temporary file.  
Outcomes: MAIL-ERROR-TEXT set on write failure.  
[Seen in: MAIL-WRITE-BODY-LINE.]

Path: Sending Email  
Trigger: CALL to **MAIL-SEND**  
Key steps: write terminating dot line, close temp file, build sendmail command string, execute SYSTEM call, remove temp file.  
I/O: temporary file, system command.  
Outcomes: MAIL-ERROR-TEXT set on any failure, temp file deleted.  
[Seen in: MAIL-SEND, MAIL-SEND-COMMAND, MAIL-SEND-CLEANUP.]

5.4 Termination  
Each routine ends with an **EXIT** paragraph that returns control to the caller, leaving any error message in MAIL-ERROR-TEXT. [Seen in: MAIL-INIT-EXIT, MAIL-WRITE-BODY-LINE-EXIT, MAIL-SEND-EXIT.]  
The caller is responsible for checking MAIL-ERROR-TEXT to determine success or failure. [Seen in: MAIL-INIT-EXIT, MAIL-WRITE-BODY-LINE-EXIT, MAIL-SEND-EXIT.]

---
## send-some-mail
*[189/267]*

### Business/Functional Perspective
### Email Sending Function  

**Program Purpose**  
The program creates and sends a statement email to a specified recipient. It prepares the email body, subject, and attachment, then dispatches the message through the system mail utility. This ensures customers receive up‑to‑date statements promptly, supporting timely communication and reducing follow‑up inquiries.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the mail command fails, the program displays the error code and pauses for the user to read it.  
- On success, no user‑visible message is shown; the program simply ends.  

**User Flow Summary**  
A user (or another system component) activates the program to send a statement email. The program builds the email content and calls the operating‑system mail utility. If the mail is sent successfully, nothing appears on the screen. If there is an error, the error code is shown, and the user is prompted to press return before the program stops.  

**Program Linkages**  
- system

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins execution at the **beginning.** paragraph, where it initializes email parameters. It constructs a shell command string that invokes the `mailx` utility to send an email with an attachment. Finally, it calls the operating‑system routine, checks the return status, and exits with a GOBACK. [Seen in: beginning.]

5.2 Initialization  
The **beginning.** paragraph assigns literal values to the mail-to, mail-subject, mail-from, and mail-body fields, and specifies the attachment file path. It then concatenates these values into a single command string stored in `mail-command`. No external files or databases are accessed during initialization. [Seen in: beginning.]

5.3 Core Processing  
Path: Send Email  
Trigger: Program entry at **beginning.**  
Key steps: Build the `mail-command` string, invoke the system call `system` with this command, capture the return code in `mail-return`, and if non‑zero, display the error and halt execution.  
I/O: System call to the operating system (no file or database I/O).  
Outcomes: `mail-return` holds the exit status of the mail command; a non‑zero value causes a display and a stop. [Seen in: beginning.]

5.4 Termination  
The program terminates by executing a `GOBACK` statement, returning control to the caller without performing additional cleanup. [Seen in: beginning.]

---
## send-some-mail2
*[190/267]*

### Business/Functional Perspective
### Send Email via Mutt  

**Program Purpose**  
The program builds a command that uses the system mail utility *mutt* to send an email with a specified subject, body, and attachment to a hard‑coded address. It is designed to provide a quick, automated way to deliver test or notification messages. By encapsulating the command construction and execution, the program reduces manual effort and potential errors in manual mail composition.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- The program displays the full shell command that will be executed, allowing the user to verify it.  
- If the underlying system command cannot be run or exits with an error code, the program terminates, indicating that the mail was not sent.  

**User Flow Summary**  
A user or automated process runs the program to send an email. The program assembles the email’s recipient, subject, body, and attachment into a single shell command and then executes that command via the operating system. The user sees the command displayed for confirmation and receives a final status indicating whether the command succeeded.  

**Program Linkages**  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins execution at the `beginning.` paragraph, initializing mail parameters and constructing a shell command. It then displays the command, invokes the operating‑system mail utility via `CALL "SYSTEM"`, and captures the return status. Finally, the program terminates with a `GOBACK` statement. [Seen in: beginning.]

5.2 Initialization  
The `beginning.` paragraph assigns hard‑coded values to `MAIL-TO-ADDRESS`, `MAIL-SUBJECT`, `MAIL-BODY`, and `MAIL-ATTACHMENT-FILENAME`. These values are used later to build the command string that will be executed. [Seen in: beginning.]

5.3 Core Processing  
Path: Main Execution  
Trigger: Program start (entry to `beginning.`)  
Key steps:  
- Build `MAIL-COMMAND` by concatenating literals and the initialized variables using `STRING`.  
- Display the constructed command with `DISPLAY`.  
- Execute the command with `CALL "SYSTEM"`, returning the exit status to `MAIL-RETURN`.  
I/O: None (only system call).  
Outcomes: `MAIL-RETURN` holds the exit code of the mail utility, which can be used for status reporting. [Seen in: beginning.]

5.4 Termination  
The program ends by executing `GOBACK`, returning control to the caller or operating system. No additional cleanup is performed. [Seen in: beginning.]

---
## sl000
*[191/267]*

### Business/Functional Perspective
### Sales Ledger Start Of Day  

**Program Purpose**  
The program enables the user to confirm and record the current day for the sales ledger. By validating the entered date, it ensures that all subsequent sales entries are tied to the correct calendar day, supporting accurate reporting, audit readiness, and risk reduction.  

**Screen Interactions**  
1. **Header screen** – Displays client information, the program name “SL000 (3.02.05)”, the title “Sales Ledger  Start Of Day”, the current system date, and optionally the current time.  
2. **Date entry prompt** – Shows a message such as “Enter todays date as dd/mm/yyyy – [          ]” (or the appropriate format for USA or International dates) and a field where the user can type the date.  
3. **Error line** – If the date is not valid, a line appears with the message “Invalid Date” and the program returns to the date prompt for re‑entry.  

**Messages and Errors**  
- **Invalid date** – When the entered date cannot be processed, the screen displays an “Invalid Date” message and asks the user to re‑enter the date.  

**User Flow Summary**  
The user runs the program and sees a screen with the current date and a prompt to enter today’s date in the required format. The user types the date and presses Enter. If the date is acceptable, the program records it (internally sets the run‑date) and then exits, returning control to the calling context. If the user types an incorrect date, the program shows an “Invalid Date” message and re‑prompts until a valid date is entered.  

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **main** paragraph, setting screen exception flags, moving the supplied date to internal fields, and displaying the initial screen. [Seen in: main.]  
It then enters the **date-entry** paragraph where the user is prompted to enter today's date, which is validated and converted to the standard UK format. [Seen in: date-entry.]  
After successful validation, the program calls **maps04**, bypasses security checks, and proceeds to the **chain-menu** paragraph before exiting via **main-exit**. [Seen in: chain-menu.]

5.2 Initialization  
The **main** paragraph sets environment variables for screen exceptions and captures the input date and time, initializing internal date fields. [Seen in: main.]  
It displays client, user, program name, and menu screens, then moves the supplied date to the internal date variable and prepares for date entry. [Seen in: main.]

5.3 Core Processing  

Path: Date Entry and Validation  
Trigger: User input of today's date in the **date-entry** paragraph.  
Key steps: Prompt user for date, accept input, convert between UK, USA, and Intl formats, validate against zero, display error if invalid, loop back to date-entry if invalid.  
I/O: Accepts **u-date** from screen; displays prompts and error messages; uses internal **ws-date-formats** and **ws-data**.  
Outcomes: Sets **u-bin** to zero if invalid, otherwise clears error display and proceeds to call **maps04**.  
[Seen in: date-entry.]

Path: Call to maps04 and Security Bypass  
Trigger: Successful date validation (**u-bin** not zero) in **date-entry** paragraph.  
Key steps: Call **maps04** with **maps03-ws**; if **u-bin** remains zero, display error and return to date-entry; otherwise clear error and go to chain-menu.  
I/O: Calls **maps04**; uses **maps03-ws**; may display **SL005** error.  
Outcomes: Determines whether to proceed to chain-menu or repeat date entry.  
[Seen in: date-entry.]

Path: Chain to Menu  
Trigger: Successful completion of **maps04** and **u-bin** not zero.  
Key steps: Move **u-bin** to **run-date**, **u-date** to **to-day**, reset **ws-term-code** to zero, then exit program.  
I/O: None beyond internal moves; displays no further output.  
Outcomes: Program terminates with exit status set by **main-exit**.  
[Seen in: chain-menu.]

Path: Program Exit  
Trigger: Execution reaches **main-exit** paragraph.  
Key steps: Exit program via `exit program` statement.  
I/O: None.  
Outcomes: Program terminates cleanly.  
[Seen in: main-exit.]

5.4 Termination  
The program ends by executing the **main-exit** paragraph, which performs an exit program statement to terminate the process. [Seen in: main-exit.]  
No additional cleanup is performed; all internal variables are left to the runtime environment. [Seen in: main-exit.]

---
## sl010
*[192/267]*

### Business/Functional Perspective
### Customer Record Management

**Program Purpose**  
SL010 provides a single point of interaction for creating, amending, deleting, displaying, and printing customer records in the Sales Ledger system. It validates key customer data, enforces business rules such as preventing deletion of active accounts, and supports printing detailed reports that can be filtered by status, credit terms, sales activity, and date ranges. By ensuring accurate and consistent customer information, the program helps maintain reliable financial records, support audit trails, and reduce the risk of data entry errors.

**Screen Interactions**  
1. **Main Menu** – Displays the options:
   * (1) Set‑up Customer records  
   * (2) Amend Customer records  
   * (3) Delete Customer records  
   * (4) Print Customer records  
   * (5) Display Customer records  
   * (6) Amend Back‑Order Status  
   * (9) Return to System Menu  
   User selects an option by typing the corresponding number.

2. **Customer Record Screen (display‑02)** – Shows all editable fields for a customer:
   * Customer number, name, and address (two lines)  
   * Delivery name and address (two lines)  
   * Customer note (two lines)  
   * Telephone, extension, fax, email address  
   * BO (Back‑Order) allowed flag (Y/N)  
   * Late charge flag, minimum and maximum late charge limits  
   * Dunning letter flag, email options (invoice, statement, dunning)  
   * Credit period (days), credit limit, discount percentage  
   * Unapplied balance, current balance, last invoice date, last payment date  
   Options displayed: **B** = Back, **S** = Save, **Q** = Quit. Escape code is also shown for additional commands.

3. **Report Selection Screen (display‑03)** – Allows the user to define criteria for a customer report:
   * Customer number (or pattern)  
   * Status (Live, Dormant, or all)  
   * Credit period (days with operator L/G/E)  
   * Invoice activity (number of invoices with operator L/G/E)  
   * Average transaction value (operator L/G/E)  
   * Overdue accounts (days overdue with operator L/G/E)  
   * Date entered (operator L/G/E)  
   Escape key quits the screen. The screen can be used to start the report generation.

**Messages and Errors**  
* **Invalid address** – prompts user to correct the customer or delivery address.  
* **Invalid response** – if a Y/N field receives a value other than Y or N.  
* **Customer record not found** – when a key entered does not exist.  
* **Customer record already exists** – prevents duplicate records.  
* **Sales ledger files not set up** – informs the user that the necessary files are missing and offers to create them.  
* **File open errors** – indicates problems opening the sales or delivery files.  
* **Cannot delete active account** – blocks deletion if the account has current balances or open back‑order items.  
* **Missing data** – when required fields (e.g., credit period) are left blank.  
* **Invalid date** – when a date entered does not conform to the expected format.  
* **Prompt to create files** – asks the user whether to create missing files.  
* **General notice** – used for informational prompts such as “Now Hit return”.

**User Flow Summary**  
1. The user launches the program and sees the main menu.  
2. Selecting **1** starts the creation of a new customer. The program prompts for a customer number, checks for duplicates, then presents the record screen where the user enters or edits all fields. The user can save (S) or return to the menu (Q).  
3. Selecting **2** edits an existing customer. After entering a valid key, the program shows the record screen pre‑filled with current data; changes are saved (S) or discarded (Q).  
4. Selecting **3** deletes a customer. The program verifies the key, checks that the account has no outstanding balances or open back‑order items, and, if safe, deletes the customer record and any related delivery or note records.  
5. Selecting **4** opens the report selection screen. After specifying criteria, the program generates a printed report listing customers that meet the filters.  
6. Selecting **5** displays a single customer record in read‑only mode; the user can navigate back (B) or quit (Q).  
7. Selecting **6** allows bulk updating of the Back‑Order flag for one or more customers. The user enters a customer number or a prefix to apply the change to all matching accounts.  
8. Selecting **9** exits back to the system menu.  

Throughout the process, the program validates inputs, displays helpful messages for errors, and maintains data integrity across the sales and delivery files.

**Program Linkages**  
- `maps04`  
- `maps09`  
- `SYSTEM` (used for printing the report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by executing the init01 section to set up environment, screen lines, and open the BO file if required. [Seen in: init01 section.]  
It then displays the main menu and accepts a numeric reply, routing the choice to one of the maintenance or reporting sections (ba000-Setup-Customers, ca000-Amend-Customer, da000-Delete-Customer, ea000-Report-Customers, fa000-Display-Customers, ga000-Amend-BO-Status). [Seen in: menu-input.]  
After the selected operation completes, control returns to the menu or exits the program via the menu-exit paragraph. [Seen in: menu-exit.]

5.2 Initialization  
init01 performs environment line count adjustment, sets screen exception flags, and initializes program name and date. [Seen in: init01 section.]  
It checks the SL-BO-Default flag, opens the BO-Stk-Itm-File if SL-BO-Flag is Y, and sets WS-BO-Status accordingly. [Seen in: init01 section.]  
If the sales ledger files are not yet created, it calls slcreate to create them. [Seen in: init01 section.]

5.3 Core Processing  
Path: Setup-Customers  
Trigger: menu reply 1  
Key steps: open sales and delivery files; display outline; accept customer number; use maps09 to check existence; if record exists display error; otherwise initialize defaults from system file; accept details; write sales record; write delivery and notes records if present; close files.  
I/O: Sales file, Delivery file, maps09 call.  
Outcomes: new customer record created; files closed; control returns to menu.  
[Seen in: ba000-Setup-Customers section.]  

Path: Amend-Customer  
Trigger: menu reply 2  
Key steps: open sales and delivery files; display outline; accept key; read sales record; if not found error; otherwise accept details; update delivery and notes records; rewrite sales record; close files.  
I/O: Sales file, Delivery file.  
Outcomes: customer record updated; files closed; control returns to menu.  
[Seen in: ca000-Amend-Customer section.]  

Path: Delete-Customer  
Trigger: menu reply 3  
Key steps: open sales and delivery files; display outline; accept key; read sales record; check if active or unapplied or BO active; if so error; else set status to dormant or delete delivery and sales records; close files.  
I/O: Sales file, Delivery file, BO-Stk-Itm-File.  
Outcomes: customer record deleted or status changed; files closed; control returns to menu.  
[Seen in: da000-Delete-Customer section.]  

Path: Report-Customers  
Trigger: menu reply 4  
Key steps: open sales and delivery files; collect report criteria; open print file; iterate over sales records applying filters; write report lines; close files and print report.  
I/O: Sales file, Delivery file, print file.  
Outcomes: report generated and printed; files closed.  
[Seen in: ea000-Report-Customers section.]  

Path: Amend-BO-Status  
Trigger: menu reply 6  
Key steps: open sales file; accept customer key or group; for each matching record set Sales-Partial-Ship-Flag to WS-BO-State; rewrite sales record; close file.  
I/O: Sales file.  
Outcomes: BO status updated for selected customers; file closed.  
[Seen in: ga000-Amend-BO-Status section.]  

5.4 Termination  
The menu-exit paragraph performs GOBACK to terminate the program. [Seen in: menu-exit.]  
Each operation section closes any open files before returning to the menu or exiting, as seen in the main-end paragraphs. [Seen in: main-end.]

---
## sl020
*[193/267]*

### Business/Functional Perspective
### Sales Ledger Enquiry

**Program Purpose**  
The Sales Ledger Enquiry program allows users to view the current status of a customer’s sales ledger. By entering a customer account number, the user receives a detailed, printable summary of all open invoices, payments, credit notes, and the ageing of outstanding amounts. This information helps sales and finance staff verify balances, identify overdue items, and maintain accurate customer records, supporting compliance and reducing financial risk.

**Screen Interactions**  

1. **Enquiry Screen**  
   * **Title / Heading** – “Sales Ledger Enquiry” displayed at the top, followed by the current date.  
   * **Input Prompt** – “Customer:” field where the user types a customer account number.  
   * **Outputs** – Customer name and up to four address lines, current balance, year‑to‑date turnover, unapplied amount, credit limit, and any unposted invoices.  
   * **Ledger Lines** – A list of ledger entries showing: Invoice number, date, description, invoiced amount, paid amount, and remaining balance.  
   * **Totals** – Summary row with total outstanding, current age bucket amounts (0‑30, 30‑60, 60‑90, 90+), and the number of invoices.  
   * **Options** – At the bottom:  
     * `'P'` – Print the current ledger view.  
     * `'N'` – Start a new enquiry (enter another customer).  
     * `'T'` – Toggle the hold flag on a selected invoice.  
     * `'M'` – Show more ledger lines if the list is longer than the screen.  
     * `'E'` – Exit the enquiry.  

2. **Print Screen**  
   * Same layout as the enquiry screen but written to a printer or spool file. The user presses any key after printing to return to the enquiry screen.  

3. **Toggle Hold Screen**  
   * Prompt: “For Account: <customer> . Give invoice no. to toggle [        ]”  
   * User enters an invoice number; the program toggles the hold status for that invoice and returns to the main enquiry screen.

**Messages and Errors**  

| Situation | User‑Facing Message (simplified) |
|-----------|----------------------------------|
| Work file cannot be created or written to | “Unable to write work file – operation stopped.” |
| Source data file (e.g., invoice data) not found | “Required data file not found – please check configuration.” |
| Requested record not found in data files | “No matching record – please verify the input.” |
| Unable to rewrite a record (e.g., when toggling hold) | “Unable to update the selected record – try again later.” |
| Invalid invoice number entered when toggling hold | “Specified invoice does not exist for this customer.” |
| Other file errors (open, close, read) | “An error occurred accessing the data – contact support.” |

**User Flow Summary**  
1. The user starts the Sales Ledger Enquiry program.  
2. The screen prompts for a customer account number. After entering a number, the program reads the customer’s master record and any open invoices, credit notes, or payments.  
3. The screen displays the customer’s details, current balances, and a ledger list. If the list is longer than the screen, the user can press `'M'` to scroll through additional entries.  
4. At the bottom, the user may:  
   * Press `'P'` to print the ledger, which opens a print job and then returns to the enquiry screen.  
   * Press `'N'` to begin a new enquiry for a different customer.  
   * Press `'T'` to bring up a small prompt for an invoice number; entering a valid number toggles that invoice’s hold status and returns to the enquiry screen.  
   * Press `'E'` to exit the program.  
Throughout, any errors (such as missing files or invalid input) are reported with clear, non‑technical messages, allowing the user to correct the issue or seek assistance.

**Program Linkages**  
- `CBL_CHECK_FILE_EXIST`  
- `SYSTEM`  
- `maps04`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** section, performing environment setup, opening necessary files, building the work file, and then invoking the enquiry section before exiting. [Seen in: init01.]  
The **enquiry** section handles user input, displays customer information, gathers open items, calculates balances and ageing, and presents a menu for further actions such as printing, next enquiry, toggling flags, or exiting. [Seen in: enquiry.]  
The **print-screen** section writes the enquiry results to the printer, formatting headers, detail lines, and totals, then calls the system print routine before returning control. [Seen in: print-screen.]  
The **set-query-flag** section allows the user to toggle the hold flag on a specific open item, rewriting the record in the open-item file and updating the display. [Seen in: set-query-flag.]  
The **set-up-work-file** section creates a temporary work file of unapplied invoices and credit notes, used to compute unposted amounts for each customer during enquiry. [Seen in: set-up-work-file.]

5.2 Initialization  
**init01** accepts environment line count, adjusts screen dimensions, sets screen exception flags, and copies the print spool name to PSN. [Seen in: init01.]  
It verifies the presence of the ITM3 file, displays error messages and aborts if missing, then performs **set-up-work-file** to build the work file. [Seen in: init01.]  
The section opens the work file for input, opens the Sales and OTM3 files for reading, performs the enquiry routine, then closes all files and clears the work file before exiting. [Seen in: init01.]

5.3 Core Processing  

Path: Enquiry Path  
Trigger: User enters a customer number in the enquiry section.  
Key steps: display headers, accept customer, set keys, start Sales and OTM3, read sales records, display customer details, read open items, build line‑7‑19, display totals, show menu, accept action.  
I/O: Sales file, OTM3 file, Work file, Print file (if printing).  
Outcomes: sets balances, displays screen, sets flags for next action.  
[Seen in: enquiry, main001, read-sales, read-open-item, end-statement, es-disp, es-accept.]

Path: Print Path  
Trigger: User selects 'P' in es‑accept.  
Key steps: open print file, write headers, loop through line‑7‑19, write totals, close print file, call system print.  
I/O: Print file.  
Outcomes: prints report, returns to enquiry menu.  
[Seen in: print-screen, Heads1, Heads2, write statements.]

Path: Set‑Query‑Flag Path  
Trigger: User selects 'T' in es‑accept.  
Key steps: display prompt, accept invoice number, close OTM3, open OTM3, read indexed record, toggle hold flag, rewrite record, close OTM3, reopen for input.  
I/O: OTM3 file.  
Outcomes: updates hold flag, refreshes display.  
[Seen in: set-query-flag, open006, perform OTM3-Read-Indexed, perform OTM3-Rewrite.]

Path: Set‑Up‑Work‑File Path  
Trigger: Called from init01 during program start.  
Key steps: display heads, open work file for output, open Invoice file, loop through invoice headers, filter, compute amounts, write to work file, close files, set work-file-data flag.  
I/O: Invoice file, Work file.  
Outcomes: creates temporary work file with unapplied invoices, sets work-file-data flag.  
[Seen in: set-up-work-file, read-invoice, write work-record, eof-test.]

Path: Get‑Unposted Path  
Trigger: Called from enquiry after customer details displayed.  
Key steps: read work file records for the customer, sum amounts into inv-amount, set l4-unposted.  
I/O: Work file.  
Outcomes: calculates unposted amount for display.  
[Seen in: get-unposted, read-work.]

5.4 Termination  
The program exits via the **menu-exit** paragraph, which performs GOBACK to terminate the program after all files have been closed. [Seen in: menu-exit.]  
All opened files (Work, Sales, OTM3, Print) are closed before the program ends, ensuring no resources remain allocated. [Seen in: init01, enquiry, print-screen.]

---
## sl050
*[194/267]*

### Business/Functional Perspective
### Invoice Proof Report

**Program Purpose**  
The Invoice Proof Report presents a complete listing of all sales invoices, credit notes, receipts, and pro‑formas that have not yet been applied to the sales ledger. It groups transactions by type, shows line‑item details, and provides totals and VAT reconciliation. The report supports audit and compliance by giving management a clear audit trail of outstanding sales entries, helping to reduce reconciliation risk and ensure accurate financial reporting.

**Screen Interactions**  
1. **Report Header Screen** – Displays the program title, the current date, and a page number.  
2. **Transaction Listing Screen** – Shows each unapplied transaction with its number, date, customer, type, goods, discount, carriage, net, VAT, and gross amounts.  
3. **Totals and VAT Summary Screens** – After the transaction list, separate sections present total figures for each transaction type and a VAT reconciliation table.  
4. **Error Prompt** – If no transactions exist or the sales file cannot be found, a message is displayed with an instruction to press return to return to the menu.

**Messages and Errors**  
- *No Transactions to proof!* – Triggered when the sales ledger contains no unapplied entries.  
- *Sales Ledger file not found.* – Displayed if the required sales file is missing.  
- In both cases the user is prompted to press return before the program terminates.

**User Flow Summary**  
The user launches the report from the main menu. The program reads the sales and invoice data, identifies all entries that have not yet been applied, and prints them in a structured report. Each page begins with a header showing the program name, date, and page number. Transactions are listed with detailed amounts, followed by cumulative totals for each transaction type and a VAT reconciliation table. If the system detects that there are no unapplied transactions or that the sales ledger file is missing, a clear error message is shown and the user is asked to press return to return to the menu. After printing, the report is closed and the program exits cleanly.

**Program Linkages**  
- maps04  
- CBL_CHECK_FILE_EXIST  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in **init01 section**, initializing totals, setting dates and opening files. [Seen in: init01 section.]  
After initialization, **Menu-Return** displays the header, checks for the sales ledger file, opens the print spool and begins the main invoice processing loop. [Seen in: Menu-Return.]  
The loop reads each invoice record, prints header and line items, performs analysis, and continues until all invoices are processed, then prints totals and closes files. [Seen in: Get-Invoice-Record.]

5.2 Initialization  
**init01 section** sets Print-Spool-Name, zeroes counters, initializes total-group array, sets program name and converts the current date. [Seen in: init01 section.]  
**Menu-Return** displays program title, date, checks for the sales file existence, opens the sales and invoice files, and opens the print-file. [Seen in: Menu-Return.]

5.3 Core Processing  
Path: Invoice Processing Path  
Trigger: Get-Invoice-Record loop  
Key steps: read next invoice, skip applied, read sales record, format amounts, print line‑5, print line‑5B for line items, update totals, handle page breaks.  
I/O: Invoice file, Sales file, print-file.  
Outcomes: totals updated, line‑cnt incremented, possible page header.  
[Seen in: Get-Invoice-Record.]

Path: Analysis-Print Path  
Trigger: Analysis-Print section  
Key steps: read next line item, handle credit note sign, print line‑5B, update vat totals, page break handling.  
I/O: Invoice file (line items), print-file.  
Outcomes: line items printed, vat totals updated.  
[Seen in: Analysis-Print section.]

Path: Extra-Analysis Path  
Trigger: extra-analysis section  
Key steps: print any accumulated deduction, discount, carriage, extra charges lines if present, page break handling.  
I/O: print-file.  
Outcomes: additional lines printed.  
[Seen in: extra-analysis section.]

Path: Termination Path  
Trigger: Main-End  
Key steps: close sales and invoice files, print final totals and vat reconciliation, close print-file, call SYSTEM to output the report.  
I/O: Sales file, Invoice file, print-file.  
Outcomes: report completed, files closed.  
[Seen in: Main-End.]

Path: File‑Not‑Found Path  
Trigger: FS‑Cobol‑Files‑Used check or Sales‑Open‑Input failure  
Key steps: display error message SL120 or SL121, accept reply if not called by xl150, goback.  
I/O: none.  
Outcomes: program exits early.  
[Seen in: Menu-Return.]

Path: Menu‑Call Exit Path  
Trigger: Menu‑Call  
Key steps: exit program.  
I/O: none.  
Outcomes: program terminates.  
[Seen in: Menu-Call.]

5.4 Termination  
Main-End performs Sales‑Close and Invoice‑Close, prints final totals and vat reconciliation, closes the print spool, and calls SYSTEM to output the report. [Seen in: Main-End.]  
The program then exits via GOBACK or Menu‑Call, ensuring all files are closed. [Seen in: Main-End, Menu-Call.]

---
## sl055
*[195/267]*

### Business/Functional Perspective
### Invoice Post Extraction  

**Program Purpose**  
The program processes all invoice records, updates the Value and Analysis tables with current totals, and writes each invoice header to the Open‑Item‑File‑2 (OTM2) for later posting. It checks that every invoice is printed before proceeding and creates emergency analysis records if needed. The routine ensures that the financial data used by downstream sales and reporting systems is complete and accurate, thereby supporting reliable accounting and compliance.  

**Screen Interactions**  
1. **Title Screen** – Displays the program name “SL055 (3.02.15)”, the heading “Invoice Post Extract”, and the current date.  
2. **Status / Error Messages** – When issues are detected the program shows one of the following messages followed by a prompt to press RETURN to continue:  
   * “Unprinted Invoices Exist – Correct & Run Again” (when unprinted invoices are found).  
   * “Analysis File Does Not Exist – You will need to update this” (when the Analysis table is missing).  
   * “Analyst records with desc, 'Emergency Name' created” together with “You will need to update this” (when emergency analysis records are created).  
   * “Error writing to Open Item 2 File” (when a write to OTM2 fails).  

**Messages and Errors**  
- **Missing Analysis File** – The program notifies the user that the Analysis table is absent and requires updating.  
- **Write Failure to Open‑Item File** – If a record cannot be written to OTM2, the user is informed of the write error.  
- **Unprinted Invoices Present** – The routine reports that some invoices have not yet been printed and must be corrected before rerunning.  
- **Emergency Analysis Created** – The program alerts the user that emergency analysis records have been generated and need manual review.  
- **General Processing Errors** – Any other unexpected errors are reported with a generic message and a request for the user to press RETURN.  

**User Flow Summary**  
1. The user starts the program, which immediately shows the title screen with the current date.  
2. The program reads each invoice record from the source file.  
3. For each header record it updates the Value and Analysis tables, writes the invoice header to OTM2, and tracks totals.  
4. If an invoice is already marked as printed it is skipped; otherwise the program flags it.  
5. After all records are processed the program checks for any unprinted invoices.  
6. If any unprinted invoices are found, a message is shown and the program exits.  
7. If the Analysis table was missing, a message is displayed and the program exits.  
8. If emergency analysis records were created, the user is informed and the program exits.  
9. If no issues occur, the program finishes successfully, leaving the Open‑Item‑File‑2 updated for downstream posting.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- sl070

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in **da000-mainline**, performing environment setup, opening value, analysis, and invoice files, and preparing the open‑item‑file‑2 for writing. [Seen in: da000-mainline.]  
It then enters a loop (**da010-Read-Loop**) that reads each invoice record, processes header records via **da020-Header-Analysis** and line items via the inline logic, updating value and analysis tables and writing extracted header records to open‑item‑file‑2. [Seen in: da010-Read-Loop.]  
After all records are processed, **da040-Close-Files** stores accumulated totals, closes all files, checks for unprinted invoices or analysis flags, and exits via **da999-Menu-Exit**. [Seen in: da040-Close-Files.]

5.2 Initialization  
**da000-mainline** accepts environment line count, sets screen exception flags, and opens the value, analysis, and invoice files, opening open‑item‑file‑2 in extend mode or output if extend fails. [Seen in: da000-mainline.]  
It also verifies the existence of the analysis file, creating default entries via **sl070** if missing, and displays the program name and current date. [Seen in: da000-mainline.]

5.3 Core Processing  
Path: Header Analysis  
Trigger: when a header record is read (ih-test zero) and not already analyzed. [Seen in: da010-Read-Loop.]  
Key steps: **dd000-Extract** copies header to open‑item‑file‑2, updates totals, sets ih-update to Z, and rewrites the invoice. [Seen in: dd000-Extract, da020-Header-Analysis.]  
I/O: Invoice file (read/write), open‑item‑file‑2 (write), value and analysis tables (read/write). [Seen in: da020-Header-Analysis.]  
Outcomes: header marked analyzed, totals updated, record written to open‑item‑file‑2. [Seen in: da020-Header-Analysis.]

Path: Line Item Processing  
Trigger: after header analysis, processing of line items where il-analyised false and not comment. [Seen in: da010-Read-Loop.]  
Key steps: Value-Read-Indexed, create value record if missing (**db000-Create**), update VA-T-This, VA-V-This, write or rewrite value record, set il-update to Z, rewrite invoice. [Seen in: da010-Read-Loop, db000-Create.]  
I/O: Value file (read/write), Analysis file (read/write), Invoice file (rewrite). [Seen in: da010-Read-Loop.]  
Outcomes: value record created/updated, invoice line marked analyzed. [Seen in: da010-Read-Loop.]

Path: Skip Invoice  
Trigger: when invoice is a proforma (ih-type=4) or pending or status not L. [Seen in: da030-Skip-Invoice.]  
Key steps: increment invoice counter, reset item counter, set fn-not-less-than true, start invoice key, check for invalid key, loop back to read next. [Seen in: da030-Skip-Invoice.]  
I/O: Invoice file (start). [Seen in: da030-Skip-Invoice.]  
Outcomes: invoice skipped, counters updated. [Seen in: da030-Skip-Invoice.]

Path: Close Files  
Trigger: after read loop ends (fs-reply=10). [Seen in: da040-Close-Files.]  
Key steps: store specials for totals via **dc000-Store-Specials**, close invoice, value, analysis files, close open-item-file‑2, check unprinted invoices flag and analysis flag, display messages, goback. [Seen in: da040-Close-Files.]  
I/O: All files closed. [Seen in: da040-Close-Files.]  
Outcomes: totals stored, files closed, exit status set. [Seen in: da040-Close-Files.]

Path: Create Analysis  
Trigger: when value read fails (fs-reply=21 or 23) during line item processing. [Seen in: db000-Create.]  
Key steps: read analysis record, if missing create via **db010-Create-Anal**, write value record, set ws-Anal-Flag. [Seen in: db000-Create, db010-Create-Anal.]  
I/O: Analysis file (read/write), Value file (write). [Seen in: db000-Create.]  
Outcomes: analysis record created, value record written, flag set. [Seen in: db000-Create.]

Path: Store Specials  
Trigger: after totals calculated, called from **da040-Close-Files**. [Seen in: dc000-Store-Specials.]  
Key steps: read or create value record for special group, update totals, write or rewrite. [Seen in: dc000-Store-Specials.]  
I/O: Value file (read/write). [Seen in: dc000-Store-Specials.]  
Outcomes: special totals stored. [Seen in: dc000-Store-Specials.]

5.4 Termination  
The program exits by performing **da999-Menu-Exit**, which simply gobacks to the caller after any error or completion messages. [Seen in: da999-Menu-Exit.]  
Prior to exit, any unprinted invoices or analysis flags trigger display of SL122 or SL123 messages and the program terminates with a GOBACK. [Seen in: da040-Close-Files.]

---
## sl060
*[196/267]*

### Business/Functional Perspective
### Invoice Posting and Reporting  

**Program Purpose**  
The program takes the list of invoice headers generated in the first step (sl055) and posts each transaction to the general ledger or IRS posting files. It updates customer balances, applies credit notes, records deductions, and produces a printed report summarising all invoices, receipts, and credit notes processed. By ensuring all postings are accurately recorded, the system provides the sales and finance teams with reliable cash‑flow information and supports compliance and audit requirements.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *Posting failure*: If a posting record cannot be written, the user is shown a brief error message and the program continues to the next record.  
- *Missing customer record*: If an invoice refers to a customer not found in the sales file, a warning message is displayed and the invoice is still processed with a placeholder customer name.  
- *File access issues*: Errors while opening or writing to key data files (e.g., the GL batch or IRS posting files) trigger an error message that includes the file name.  
- *General system error*: Any unexpected system failure stops the program after displaying a generic error message.  

**User Flow Summary**  
1. The program starts automatically after the first step of invoice processing.  
2. It reads each invoice header, looks up the customer record, calculates totals (net, VAT, gross), and updates the customer’s balances.  
3. For each transaction, a posting line is written to the appropriate ledger (GL or IRS).  
4. Credit notes are matched against open invoices and applied, reducing outstanding balances and recording any deductions.  
5. As it processes, the program writes a printable report that lists all invoices, receipts, and applied credit notes, including totals for each category.  
6. When finished, the program cleans up temporary files, closes all postings, and sends the report to the printer.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- CBL_DELETE_FILE  
- SYSTEM  
- GL-Batch-Open  
- GL-Posting-Open  
- GL-Posting-Open-Output  
- GL-Posting-Write  
- GL-Posting-Close  
- GL-Batch-Write  
- GL-Batch-Close  
- SPL-Posting-Open-Extend  
- SPL-Posting-Open-Output  
- SPL-Posting-Write  
- SPL-Posting-Close  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by initializing the environment, converting dates, and opening the necessary files before displaying a header. [Seen in: aa000-Main-Process.]  
It then reads each header record from the temporary OTM2 file, updates sales and OTM3 records, and writes a posting line to GL or IRS for each invoice. [Seen in: aa020-Read-Loop.]  
After all invoices are processed, it applies any outstanding credit notes to the OTM3 file, updates value statistics, prints a detailed report, and closes all files before exiting. [Seen in: aa040-End-Loop.]

5.2 Initialization  
The program accepts environment lines, sets default line count, converts the current date, and configures screen exception handling. [Seen in: aa000-Main-Process.]  
It opens the sales, print, and OTM3 files, and if GL posting is enabled, opens the batch and posting files. [Seen in: aa000-Main-Process.]

5.3 Core Processing  

Path: Main Invoice Posting Loop  
Trigger: Reading a header record from open-item-file-2 (OTM2).  
Key steps: read header, look up sales record, compute amounts, update totals, write OTM3 record, write GL/IRS posting, write report line.  
I/O: open-item-file-2, open-item-file-3, sales-file, print-file, GL/IRS posting file.  
Outcomes: updated sales balances, OTM3 record, posting record, report line, totals.  
[Seen in: aa020-Read-Loop.]

Path: Credit Note Application Loop  
Trigger: After main loop, OTM3 file is reopened and each record is read; if record type is credit note (3) then ba000-Cr-Swop is performed.  
Key steps: read OTM3 record, if credit note, perform ba000-Cr-Swop which rewrites OTM3 record and writes posting line.  
I/O: open-item-file-3, GL/IRS posting file, print-file.  
Outcomes: credit note amounts applied, posting lines, updated OTM3 record.  
[Seen in: aa040-End-Loop.]

Path: GL/IRS Posting  
Trigger: Called from aa020-Read-Loop and ba000-Cr-Swop to write a posting line.  
Key steps: build posting record fields, write to GL or IRS posting file, update batch totals.  
I/O: GL posting file or IRS posting file, batch file.  
Outcomes: posting record written, batch totals updated.  
[Seen in: ca000-BL-Write.]

Path: Value File Update  
Trigger: After main loop, if total deductions > 0, Value-Open, ba000-Analise-Deductions, Value-Close.  
Key steps: read value record for current and previous periods, subtract deductions, rewrite.  
I/O: value file.  
Outcomes: value statistics updated.  
[Seen in: ba000-Analise-Deductions.]

5.4 Termination  
The program prints the report, deletes the temporary OTM2 file if it exists, and exits. [Seen in: aa999-Exit-Prog.]  
All open files are closed and the program terminates cleanly. [Seen in: aa999-Exit-Prog.]

---
## sl070
*[197/267]*

### Business/Functional Perspective
### Product Analysis Maintenance  

#### Program Purpose  
SL070 allows users to manage Product‑Analysis (P/A) codes that link product groups to accounting codes. The program supports creating, editing, deleting, displaying, and printing these codes, ensuring that each code is unique, correctly associated with a valid analysis group, and properly stored for use by other accounting modules. This helps maintain accurate financial reporting and reduces errors in transaction postings.  

#### Screen Interactions  

1. **Product Analysis Menu**  
   *Title:* “Product Analysis File Set‑Up & Maintenance”  
   *Inputs:* Numeric selection (1‑5 or 9).  
   *Outputs:* Displays menu options:  
   - 1 – Set‑up P/A records  
   - 2 – Amend/Delete P/A records  
   - 3 – Print P/A records  
   - 4 – Print All P/A records  
   - 5 – Display P/A records  
   - 9 – Return to system menu  

2. **Product Record Entry / Modification Screen**  
   *Title:* “Enter P/A Details” (used for both create and amend).  
   *Inputs:*  
   - **Group Code** – alphanumeric (e.g., “v ”, “vi”).  
   - **G/L Number** – numeric, zero indicates a group header.  
   - **Description** – free text.  
   - **Print Code** – optional text for printing.  
   *Outputs:* Shows the current record fields and a list of available escape codes:  
   - B = Back (re‑enter description)  
   - S = Save (store the record)  
   - Q = Quit (abort entry)  
   - K = Delete (remove the record)  

3. **Product Record Display Screen**  
   *Title:* “P/A Record Listing”  
   *Inputs:* User presses **Enter** to continue scrolling, or **X** to exit.  
   *Outputs:* Lists each record with columns: Group Code, G/L No., Description, Print Code, and Type (Group/Detail).  

#### Messages and Errors  
- **Duplicate Code:** Alerts when a P/A code already exists.  
- **Missing Group Code:** Notifies that the specified group does not exist.  
- **Group Used as Analysis Code:** Warns that the group code is already in use as an analysis code.  
- **Code Not Found:** Indicates the requested P/A code cannot be located.  
- **Processing Errors:** General error messages for analysis or value record operations, prompting the user to retry or cancel.  

#### User Flow Summary  
The user starts SL070 and sees the Product Analysis Menu. Choosing option 1 initiates the set‑up process, where the user enters new P/A codes one by one. The program checks for duplicates, validates the group, and saves the record. Option 2 allows the user to view an existing record, edit its details, or delete it. Option 3 or 4 prints a report of all P/A records (either filtered or complete) to a printer. Option 5 displays all records on the screen, letting the user scroll through them and exit by typing **X**. After completing any action, the program returns to the menu or exits to the system menu.  

#### Program Linkages  
- `CBL_CHECK_FILE_EXIST`  
- `SYSTEM` (used to invoke the print routine)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by executing the **init01** section which performs environment setup, file existence checks and may invoke the **P-A-Setup** routine if called by Stock/ACAS or if the analysis file is missing. [Seen in: init01.]  
After initialization the user is presented with a menu via **menu-return** and **menu-input** paragraphs, and the selection dispatches to one of the **Create**, **Amend**, **Report1**, or **Show** sections. [Seen in: menu-return, menu-input.]  
Each of these sections carries out its respective maintenance or reporting task and then returns to the menu loop until the user selects exit, at which point the **Menu-Exit** paragraph performs a GOBACK. [Seen in: Create, Amend, Report1, Show, Menu-Exit.]

5.2 Initialization  
init01 accepts the number of screen lines, sets default line counts, configures screen exception handling, and initializes the print spool name and file key. [Seen in: init01.]  
It then checks if the analysis file exists; if not, it performs **P-A-Setup** to create default records, and if the program is called with ws-Process-Func = 1 it skips to **Menu-Exit**. [Seen in: init01, P-A-Setup.]

5.3 Core Processing  
Path: **P-A-Setup** (Auto‑run trigger)  
Trigger: Called from init01 when ws-Process-Func = 1 or when the analysis file is missing.  
Key steps: open value file, open analysis file for output, create a series of default records for sales and purchases, close files.  
I/O: value file, analysis file.  
Outcomes: default P/A records inserted, FS-Reply errors handled, program proceeds to exit.  
[Seen in: init01, P-A-Setup, Value-Open, Analysis-Open-Output, Create-Value, Value-Close, Analysis-Close.]

Path: **Create** (Set‑up P/A records)  
Trigger: menu-reply = 1.  
Key steps: open analysis file, loop reading group codes, check for existing records, prompt for details, write new analysis records, handle escape codes, increment line counter.  
I/O: analysis file.  
Outcomes: new P/A records added, FS-Reply errors handled, loop continues until user exits.  
[Seen in: Create, Analysis-Open, product-loop, Analysis-Read-Indexed, aa101-Check-4-Errors, analysis-data, Analysis-Write, main-output.]

Path: **Amend** (Amend/Delete P/A records)  
Trigger: menu-reply = 2.  
Key steps: open analysis file, loop reading group codes, display existing record, prompt for changes, delete or rewrite based on escape code, handle errors.  
I/O: analysis file.  
Outcomes: records updated or removed, FS-Reply errors handled.  
[Seen in: Amend, Analysis-Open, product-loop, Analysis-Read-Indexed, aa101-Check-4-Errors, analysis-data, Analysis-Delete, Analysis-Rewrite, main-output.]

Path: **Report1** (Print P/A records)  
Trigger: menu-reply = 3 or 4.  
Key steps: open analysis file for input, open print file, write headings, loop reading next records, write formatted lines to print file, close files, call SYSTEM to print.  
I/O: analysis file, print-file.  
Outcomes: print file generated, print-report invoked, FS-Reply errors handled.  
[Seen in: Report1, Analysis-Open-Input, print-file, headings, Analysis-Read-Next, aa101-Check-4-Errors, write print-record, close print-file, Analysis-Close, SYSTEM.]

Path: **Show** (Display P/A records)  
Trigger: menu-reply = 5.  
Key steps: open analysis file for input, display outline, loop reading next records, display each record, accept user reply to continue or exit.  
I/O: analysis file.  
Outcomes: records displayed on screen, loop continues until exit.  
[Seen in: Show, Analysis-Open-Input, product-display, Show-read, sread, accept-of-show.]

5.4 Termination  
The **Menu-Exit** paragraph performs a GOBACK to return control to the caller, after optionally clearing a status line. [Seen in: Menu-Exit.]  
All open files are closed by their respective close statements within each processing section before returning. [Seen in: Report1, Show, Create, Amend, P-A-Setup.]

---
## sl080
*[198/267]*

### Business/Functional Perspective
### Payment Data Entry  

#### Program Purpose  
The program lets users record cash or cheque payments against customer invoices. It validates dates, checks that the batch is open, displays the customer’s current and unapplied balances, accepts payment amounts, applies those payments to open invoices, and updates the ledger. This ensures accurate accounting, prevents duplicate or over‑payment, and maintains a clear audit trail for each transaction.  

#### Screen Interactions  
1. **Payment Entry Screen** –  
   - *Inputs*: Transaction date, customer/account number, payment value, and batch number.  
   - *Outputs*: Displays the entered date, customer reference, and batch total.  

2. **Customer Details Screen** –  
   - *Inputs*: Customer/account number (entered above).  
   - *Outputs*: Shows the customer’s address lines, current balance, and, if applicable, the unapplied balance. Presents a yes/no prompt to allocate the unapplied balance to the current payment.  

3. **Payment Value Screen** –  
   - *Inputs*: Amount of the payment (pounds and pence).  
   - *Outputs*: Updated batch total and prompts for additional payments.  

4. **Additional Payments Prompt** –  
   - *Inputs*: Y/N to indicate whether more payments will be entered.  
   - *Outputs*: Returns to the payment entry screen for another transaction or exits the program.  

5. **Invoice Allocation Display** –  
   - *Outputs*: Lists each invoice being paid, the date, net amount, deductions, and how much of the payment is applied. Indicates when an invoice is fully paid, when a payment is too high, or when no change is left.  

#### Messages and Errors  
- **Invalid or missing date** – the user is asked to re‑enter the date.  
- **Batch closed or full** – a warning is shown and the program exits.  
- **Invoices not posted** – the program stops and informs the user that payment entry is not allowed until all invoices are posted.  
- **Payment too high** – the user is notified that the entered amount exceeds the total payable and must re‑enter a lower amount.  
- **Payment fully applied** – the system indicates that the invoice has been paid in full.  
- **No change left** – the program informs the user that the payment amount exactly matches the outstanding balance.  

#### User Flow Summary  
The user starts the program and enters the transaction date. The system validates the date and prompts for a customer/account number. After entering the number, the system displays the customer’s address and current balances. If the customer has an unapplied balance, the user may choose to allocate it to this payment. The user then enters the payment amount, which is applied to the earliest open invoices. The screen shows each invoice’s details, how much is paid, and any remaining balance. After completing a payment, the user can enter additional payments for the same customer or finish. The program then updates the batch total and records all changes, ensuring that the accounting ledger reflects the new balances.  

#### Program Linkages  
- CBL_CHECK_FILE_EXIST  
- MAPS04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by performing init01, which accepts the number of screen lines, sets screen exception flags, and verifies the S-Flag-I to prevent entry when invoices are not posted. [Seen in: init01 section.]  
After initialization, display-heads shows program title and date, then dh-exit opens necessary files, calls New-Payment to handle payment entry, and closes files. [Seen in: dh-exit.]  
Upon completion of payment entry, menu-exit updates batch counters and flags, then main-exit exits the program. [Seen in: menu-exit.]

5.2 Initialization  
init01 accepts the number of screen lines, sets environment exception flags, and verifies the S-Flag-I to prevent entry when invoices are not posted. [Seen in: init01 section.]  
If COBOL files are used, init01 checks for the existence of the open-item file and displays an error if missing, then exits. [Seen in: init01 section.]

5.3 Core Processing  
Path: New-Payment  
Trigger: dh-exit performs New-Payment.  
Key steps: display prompts, date-input, customer-input, value-input, set-batch-item, data-input, more-data, exit.  
I/O: OTM3-Open, Sales-Open, OTM3-Close, Sales-Close.  
Outcomes: sets pay-customer, pay-date, pay-value, batch-value, k, transaction-type, and prepares for payment processing.  
[Seen in: New-Payment section.]

Path: Payment-Appropriate  
Trigger: New-Payment-Main performs Payment-Appropriate.  
Key steps: display headers, start OTM3, loop pay-loop, process payments, rewrite records.  
I/O: OTM3-Read-Next, OTM3-Rewrite, OTM3-Write.  
Outcomes: updates open-item records, sets oi-status, oi-date-cleared, oi-paid, oi-p-c, and related fields.  
[Seen in: Payment-Appropriate section.]

Path: accept-unappl-reqst  
Trigger: after displaying unapplied balance in New-Payment-Main.  
Key steps: accept Y/N, if Y set transaction-type 6, accept money, set pay-value.  
I/O: none.  
Outcomes: sets transaction-type, pay-value, may proceed to set-batch-item.  
[Seen in: accept-unappl-reqst paragraph.]

Path: pay-loop  
Trigger: Payment-Appropriate section.  
Key steps: read next open-item, check type, customer, net, deduct, test-amount, rewrite if fully paid, else go to pay-details.  
I/O: OTM3-Read-Next, OTM3-Rewrite.  
Outcomes: may rewrite record, may set oi-status, oi-date-cleared, etc.  
[Seen in: pay-loop paragraph.]

Path: main-end  
Trigger: after payment loop ends.  
Key steps: initialize oi fields, set oi-customer, oi-date, oi-type, oi-paid, oi-approp, oi-deduct-amt, oi-b-nos, oi-b-item, oi-invoice, write record.  
I/O: OTM3-Write.  
Outcomes: writes new open-item record, resets variables.  
[Seen in: main-end paragraph.]

5.4 Termination  
dh-exit performs OTM3-Close and Sales-Close after New-Payment, then menu-exit updates batch counters and sets oi-3-flag before exiting. [Seen in: dh-exit, menu-exit.]  
main-exit performs exit program. [Seen in: main-exit.]

---
## sl085
*[199/267]*

### Business/Functional Perspective
### Payment Data Amend  

---

**Program Purpose**  
The program lets users correct or delete payment entries on customer invoices. It ensures that payment amounts are accurately reflected, any unapplied balances are handled, and the invoice totals remain consistent. By validating input dates and amounts, it protects against data errors, supports audit trails, and reduces the risk of incorrect financial reporting.  

---

**Screen Interactions**  

1. **Header Screen** – Shows the program name, title, and the current date.  
2. **Payment Search Screen** – Prompts the user to enter:  
   * Date of the payment (in the system’s date format).  
   * A/C (account) number.  
   * Batch number and item number.  
   * Payment value to be amended.  
3. **Customer & Invoice Display** – Presents the customer name, address lines, and current balance.  
4. **Money Entry Screens** – Separate screens for entering the payment amount and any deduction amounts when reversing a payment.  
5. **Confirmation Prompts** –  
   * “Confirm No Action? i.e. Request Cancelled (Y/N)..[ ]”  
   * “Make Further Corrections (Y/N) ? [Y]”  
6. **Processing Message** – Displays “Reversing Please Wait” while the system updates records.  
7. **Error & Warning Screens** – Show messages such as “Warning Unapplied Balance Journal” and “No Payments To Correct/Proof/Post.”  

---

**Messages and Errors**  
- *No payments to amend* – informs the user that there is nothing to correct.  
- *Invalid or missing data* – displayed when required fields are left blank or entered incorrectly.  
- *Not yet supporting corrections* – indicates the requested operation is unavailable.  
- *Amount adjustment not zero* – warns that the payment or deduction amounts still contain non‑zero values.  
- *Unapplied Balance Journal warning* – alerts that an unapplied journal entry was found.  
- *Reversing Please Wait* – shown during record updates.  
- *Confirm No Action?* – prompts the user to cancel the current change.  

---

**User Flow Summary**  
1. The user starts the program and sees the header screen.  
2. The program prompts for the payment date, account number, batch number, and item number.  
3. It looks up the matching payment record. If none is found, the user is notified that no payments exist for the criteria.  
4. When a record is found, the customer’s name, address, and current balance are displayed.  
5. The user enters a new payment amount. If the amount matches the existing one, the system asks whether to cancel the request.  
6. If the amount differs, the program deletes the old payment record and, if needed, writes a new one. For payments that are unapplied, the unapplied balance is updated.  
7. The program may ask for any deduction amounts when reversing a payment.  
8. After processing, the user can choose to make additional corrections or exit.  
9. Throughout, the user receives clear messages about progress, warnings, and errors, and can confirm or cancel actions as needed.  

---

**Program Linkages**  

- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** section, setting screen exception flags, validating the session flag, and displaying the program header before opening the open‑item and sales files. [Seen in: init01 section.]  
After file initialization, control transfers to the **new-payment** section where the user is prompted for batch, customer, and invoice details, and the program searches for matching open‑item records. [Seen in: new-payment section.]  
Once the payment amendment or reversal logic completes, the program closes the files, restores the menu flag, redisplays the header, and exits the program. [Seen in: menu-exit.]

5.2 Initialization  
The **init01** section accepts the number of screen lines, configures screen‑exception handling, and checks the session flag **s-flag-p**; if zero, it displays an error and aborts. [Seen in: init01 section.]  
The program then displays the header, converts the current date to UK format, opens the open‑item and sales files, and calls **new-payment** to begin processing. [Seen in: init01 section.]

5.3 Core Processing  

Path: **New‑Payment**  
Trigger: User enters a non‑blank batch and customer, and selects an invoice.  
Key steps:  
- Display header and prompts (date, batch, customer, invoice).  
- Read open‑item records in **find-trans-loop** until a matching record is found.  
- Display customer and address details, current balance, and prompt for a new value.  
- Accept and validate the new value; if unchanged, ask for confirmation.  
- If the new value is zero, delete the open‑item record; otherwise, handle deduction amounts via **payment-appropriate**.  
I/O: open‑item-file‑3 (read, delete, rewrite), sales-file (read, rewrite).  
Outcomes: Updated or deleted payment record, possible deduction handling, and user confirmation prompts.  
[Seen in: new-payment section, find-trans-loop paragraph, value-input paragraph, value-input-2 paragraph, payment-appropriate section.]

Path: **Payment‑Appropriate**  
Trigger: Deletion of a payment record or reversal of an existing payment.  
Key steps:  
- Start at the first open‑item record for the customer and invoice.  
- For each invoice record, reverse the paid amount, adjust balances, and clear status fields.  
- If a deduction amount is pending, prompt the user to enter a deduction amount via **get-deduct**.  
- Rewrite the open‑item record after adjustments.  
- Continue until all related records are processed.  
I/O: open‑item-file‑3 (read, rewrite, delete).  
Outcomes: Reversed payment amounts, updated balances, and potential deduction prompts.  
[Seen in: payment-appropriate section, pay-loop paragraph, get-deduct paragraph, by-pass-deduct paragraph.]

Path: **Value‑Input‑2** (Delete Payment)  
Trigger: User enters a new value of zero for a payment.  
Key steps:  
- Delete the current open‑item record.  
- If an appropriation amount exists, move it to **si-deduct-amt** for possible deduction.  
- Proceed to **payment-appropriate** to handle any remaining adjustments.  
I/O: open‑item-file‑3 (delete).  
Outcomes: Payment record removed, deduction amount prepared for further processing.  
[Seen in: value-input-2 paragraph, OTM3-Delete call, payment-appropriate section.]

Path: **Skip‑Pay‑Approp** (Unapplied Balance)  
Trigger: The transaction type is unapplied (trans‑unapplied).  
Key steps:  
- Add the held payment amount to the sales record’s unapplied balance.  
- Rewrite the sales record.  
- Prompt the user whether to make further corrections.  
I/O: sales-file (rewrite).  
Outcomes: Unapplied balance updated, user prompted for additional corrections.  
[Seen in: skip-pay-approp paragraph, Sales-Rewrite call.]

Path: **Main‑Exit**  
Trigger: User chooses to exit or all processing completes.  
Key steps:  
- Close open‑item and sales files.  
- Reset the menu flag **oi-3-flag** to “Y”.  
- Redisplay the header and exit the program.  
I/O: open‑item-file‑3 (close), sales-file (close).  
Outcomes: Program termination with clean file closure.  
[Seen in: main-exit paragraph.]

5.4 Termination  
The program closes the open‑item and sales files, resets the menu flag, redisplays the header, and exits via **GOBACK**. [Seen in: main-exit paragraph.]  
No additional status flags are set beyond the menu flag reset before termination. [Seen in: main-exit paragraph.]

---
## sl090
*[200/267]*

### Business/Functional Perspective
### Payment Proof Sort  

**Program Purpose**  
The Payment Proof Sort program organizes payment‑related records that have been entered into the system. It extracts only the relevant open‑item entries, removes receipt and credit‑note types, and orders the remaining records by batch number, item, type, date, and invoice number. This sorted list is required for accurate downstream processing and auditability. The program also verifies that the input and output record structures match to prevent data corruption.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If Cobol files are not being used, the program exits immediately with a status code.  
- When the record lengths of the open‑item input and the sort output differ, a system‑error message is displayed and the user must press return before the program terminates.  
- If no payment data is present for sorting, the user sees a notice that there are no payments to correct/proof/post and must press return to finish.  
- During normal operation, the program completes quietly; the sorted file is ready for the next processing step.  

**User Flow Summary**  
A user initiates the program after data entry has been completed. The program first confirms that Cobol files are active and that the record structures match. It then reads the open‑item file, discarding receipt and credit‑note records and any records without batch information. The remaining records are sorted by batch number, item, type, date, and invoice number and written to a sort file. Once sorting is finished, the program exits, leaving the sorted file available for the subsequent posting or correction routine.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in the **init01** section, performing preliminary checks on Cobol file usage and record length consistency before proceeding. [Seen in: init01 section.]  
If data is present, it sets a flag and performs the **sorting-1** section, which invokes **input-to-sort** to read, filter, and release records into a sort file. [Seen in: sorting-1 section.]  
After sorting completes, the program exits via **menu-exit** (or **main-exit**) and returns control to the caller. [Seen in: menu-exit.]

5.2 Initialization  
The **init01** section first checks the FS-Cobol-Files-Used flag; if false, it returns with status 4. [Seen in: init01 section.]  
It displays the program name, compares the lengths of Open-Item-Record-3 and Sort-Record, and aborts with a prompt if they differ. [Seen in: init01 section.]  
It verifies that S-Flag-P indicates data presence; if not, it displays a message and goes to **menu-exit**. [Seen in: init01 section.]  
If data is present, it sets oi-3-flag to "Y" and performs **sorting-1**. [Seen in: init01 section.]

5.3 Core Processing  
Path: **Sorting Path**  
Trigger: perform sorting-1  
Key steps: sort-file on keys s-b-nos, s-b-item, s-type, s-date, s-invoice; input procedure input-to-sort; giving open-item-file-s.  
I/O: sort-file, open-item-file-3, open-item-file-s.  
Outcomes: sorted file created, open-item-file-s closed.  
[Seen in: sorting-1 section.]

Path: **Input-to-Sort Open Input Path**  
Trigger: perform OTM3-Open-Input  
Key steps: open input file; if fs-reply not zero, close input, create empty output file, close output, go to main-exit; otherwise proceed to process-input.  
I/O: open-item-file-3, open-item-file-s.  
Outcomes: error leads to empty output file; success leads to reading loop.  
[Seen in: input-to-sort section.]

Path: **Process-Input Path**  
Trigger: perform OTM3-Read-Next  
Key steps: read next record; skip if oi-type is 1 or 3; skip if zero batch data; release sort-record; loop to process-input.  
I/O: open-item-file-3, sort-record.  
Outcomes: records released to sort file.  
[Seen in: process-input paragraph.]

Path: **End-of-Input Path**  
Trigger: fs-reply = 10 (end of file)  
Key steps: close open-item-file-3; exit section.  
I/O: open-item-file-3.  
Outcomes: input file closed, control returns to sorting.  
[Seen in: end-of-input paragraph.]

5.4 Termination  
The program exits via **menu-exit**, performing exit program and returning control to the caller. [Seen in: menu-exit.]  
If sorting completes without errors, the sort file remains open until the program ends; the **main-exit** section is used to terminate. [Seen in: main-exit section.]  
In error scenarios, the program may create an empty output file and close the input file before exiting. [Seen in: input-to-sort section.]

---
## sl095
*[201/267]*

### Business/Functional Perspective
### Payment Proof Report  

**Program Purpose**  
The program generates a printed report that lists all payments, invoices and journal entries for a given period. It pulls data from sales and payment files, matches payments to customers, and aggregates totals for payments, appropriations, unapplied cash and deductions. The report is used by accountants and auditors to verify that every transaction has been recorded correctly, to support compliance and financial reporting, and to reduce the risk of mis‑posted entries.  

**Screen Interactions**  
No direct user‑screen prompts are provided. The program displays a brief status line (“Printing… Please Wait”) on the console while the report is generated and writes the formatted report to the printer or spooler.  

**Messages and Errors**  
- **Successful completion** – The report is printed and the program returns to its caller.  
- **File‑access error** – If the required sales or payment files cannot be opened, the program stops and the caller receives a failure signal.  
- **Missing customer** – If a payment references a customer not found in the sales file, the report line shows “!! Customer Unknown” beside the customer name.  

**User Flow Summary**  
1. The user runs the report (typically from a batch job or a higher‑level application).  
2. The program opens the sales and payment files, prints the page header with the current date, and displays a “Printing… Please Wait” message.  
3. It reads each payment record, converts dates to the local format, looks up the customer name, and writes a line showing the batch number, payment type, dates, amount, appropriation, deductions, and customer details.  
4. For each invoice that has received payment, the program writes a separate line showing the invoice number, date, amount applied, and remaining balance.  
5. After all records are processed, the program prints summary totals for payments, appropriations, unapplied cash, and deductions, and then prints a similar set of totals for the journal side of the entries.  
6. The printer spool file is closed, a system print command is invoked, and the program terminates, returning control to the calling context.  

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the `init01` section, performing flag checks, initializing variables, and displaying the header before invoking the main reporting routine. [Seen in: init01.]  
The `report1` section opens the necessary input files or tables, reads and processes each record, writes formatted lines to the print file, and accumulates totals. [Seen in: report1.]  
After processing all records, the program writes summary totals, closes all files, calls the system print routine, and exits. [Seen in: loop-end.]

5.2 Initialization  
The `init01` section checks the `S-Flag-P` flag, sets program name and spool parameters, and displays the report title and current date. [Seen in: init01.]  
It then performs a date conversion, displays a waiting message, and calls the `report1` section to start the main processing loop. [Seen in: init01.]

5.3 Core Processing  

Path: File-Based Processing (Cobol Files)  
Trigger: `FS-Cobol-Files-Used` is true.  
Key steps: open `open-item-file-s` for input, read each record, process invoices or payments, write formatted lines to `print-file`, and close files.  
I/O: `open-item-file-s`, `print-file`, `sales-file`.  
Outcomes: all records printed, totals accumulated, files closed.  
[Seen in: report1.]

Path: Table-Based Processing (OTM3)  
Trigger: `FS-Cobol-Files-Used` is false.  
Key steps: perform `OTM3-Open-Input`, read next sorted record with `OTM3-Read-Next-Sorted-By-Batch`, process the record, and close the OTM3 table.  
I/O: OTM3 table, `print-file`, `sales-file`.  
Outcomes: records processed and printed, totals updated, tables closed.  
[Seen in: report1.]

Path: Process Invoice  
Trigger: `oi-type = 2` and `oi-paid > 0` and `oi-customer = save-customer`.  
Key steps: set invoice fields, convert dates, calculate balances, write a line-6 record, and increment line counter.  
I/O: `print-file`.  
Outcomes: invoice line printed, line counter updated.  
[Seen in: process-invoice.]

Path: Process Payment  
Trigger: `oi-type = 5` or `oi-type = 6` and `s-open` true.  
Key steps: populate payment fields, convert date, retrieve customer name, update payment or journal totals, write a line-6 record, reset temporary fields, and loop back to read next record.  
I/O: `print-file`, `sales-file`.  
Outcomes: payment line printed, totals updated, loop continues.  
[Seen in: read-loop-tests.]

Path: Loop End Summary  
Trigger: end of the read loop (`loop-end`).  
Key steps: write summary totals (lines 7‑9), close `print-file`, close `sales-file`, close `open-item-file-s` if used, call the system print routine, and go to `main-exit`.  
I/O: `print-file`, `sales-file`, `open-item-file-s`.  
Outcomes: report finalized, files closed, program ready to exit.  
[Seen in: loop-end.]

5.4 Termination  
The `loop-end` paragraph writes final totals, closes all files, and invokes the system print routine before transferring control to `main-exit`. [Seen in: loop-end.]  
The `main-exit` paragraph exits the program, completing the termination sequence. [Seen in: main-exit.]

---
## sl100
*[202/267]*

### Business/Functional Perspective
### Cash Posting Report  

**Program Purpose**  
The program processes pending cash posting transactions for sales. It updates sales records, records posting entries, and produces a printed posting report that includes individual transaction details and summary totals. The report provides an audit trail of payments applied to customers, supporting compliance and financial accuracy. By validating dates and handling any posting errors, it reduces the risk of mis‑posted transactions and ensures that accounting records remain consistent.  

**Screen Interactions**  
1. **Start‑Screen** – Displays the program name, “Sales Cash Posting,” and the current date.  
2. **Prompt** – Asks the user “OK to Post Payment Transactions (YES/NO) ?” and waits for a “YES” or “NO” response.  

No additional user‑input screens are presented; all further activity is processed automatically and the results are printed.  

**Messages and Errors**  
- *Payments Not Proofed* – If the program determines that the transaction batch is not closed, it shows a notice that payments are not proofed and prompts the user to press return.  
- *Batch Write Error* – If the GL batch write fails, the program displays an error message, shows the status code and a brief description, then waits for the user to press return.  
- *General Note* – If the user chooses “NO” at the prompt, the program exits without making changes.  

**User Flow Summary**  
The user launches the program, which shows the date and asks whether to post pending cash transactions. If the user confirms with “YES,” the program reads each open‑item record, updates the corresponding sales record, records posting entries in the ledger (and, if applicable, IRS files), and compiles a printed report. The report lists each posting with customer details, old and new balances, payment, deduction, and apportioned amounts, followed by payment and journal totals. After printing, the program returns to the calling context. If the user declines or an error occurs, the program stops and informs the user accordingly.  

**Program Linkages**  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in **init01**, performing environment setup, date conversion, and a flag check before displaying the posting prompt and opening necessary files. [Seen in: init01.]  
After user confirmation, the program enters a loop that reads each open‑item record, processes payments or journal entries, updates sales records, writes posting details to the print file, and optionally writes GL or IRS postings. [Seen in: loop.]  
Upon reaching the end of the open‑item file, the program closes files, prints totals, performs value‑file adjustments, and exits. [Seen in: main-end.]

5.2 Initialization  
init01 sets the program name, spool name, and screen exception flags, then converts the current date and checks the S‑Flag‑P; if the flag is not 2, it displays an error and exits. [Seen in: init01.]  
The program then displays the posting screen, prompts the user for confirmation, and opens the open‑item file (OTM3‑Open), sales file (Sales‑Open), batch file (Bl‑Open) if G‑L is set, and the print output file. [Seen in: acpt‑xrply, OTM3‑Open, Sales‑Open, Bl‑Open, headings.]

5.3 Core Processing  

Path: User Confirmation & File Open  
Trigger: wx‑reply = “YES”  
Key steps: open files, set j to zero, display headings.  
I/O: open‑item‑file‑3, sales file, batch file (if G‑L), print file.  
Outcomes: files opened, j initialized, headings displayed.  
[Seen in: acpt‑xrply, OTM3‑Open, Sales‑Open, Bl‑Open, headings.]

Path: Open‑Item Processing  
Trigger: OTM3‑Read‑Next returns fs‑reply ≠ 10  
Key steps: read record, check type, compute‑sales‑pay, update sales, write GL/IRS posting via bl‑write, write print record, loop.  
I/O: open‑item‑file‑3, sales file, print file, GL/IRS posting files.  
Outcomes: sales updated, postings written, print output generated.  
[Seen in: loop, compute‑sales‑pay, Sales‑Read‑Indexed, Sales‑Rewrite, Bl‑Write, write print‑record.]

Path: End‑of‑File  
Trigger: fs‑reply = 10  
Key steps: close open‑item‑file‑3, sales file, write totals to print, close print file, call print‑report, perform value analysis if deductions, close value file, close batch file.  
I/O: open‑item‑file‑3, sales file, print file, value file, batch file.  
Outcomes: totals printed, value file updated, batch closed.  
[Seen in: main‑end, OTM3‑Close, Sales‑Close, write print‑record, Value‑Open, analise‑deductions, Value‑Close, bl‑close.]

Path: Value Analysis  
Trigger: t‑deduct ≠ 0  
Key steps: open value file, subtract deductions from totals, rewrite records.  
I/O: value file.  
Outcomes: value totals adjusted.  
[Seen in: analise‑deductions.]

Path: Batch Posting  
Trigger: G‑L set  
Key steps: bl‑open, bl‑write, bl‑close.  
I/O: batch file, GL posting file, IRS posting file.  
Outcomes: batch record written, postings written.  
[Seen in: bl‑open, bl‑write, bl‑close.]

5.4 Termination  
After completing all processing, the program sets oi‑3‑flag to Y, clears S‑Flag‑P, and exits via menu‑exit. [Seen in: menu‑exit.]  
The exit routine simply performs GOBACK (exit program). [Seen in: menu‑exit.]

---
## sl110
*[203/267]*

### Business/Functional Perspective
### Statement Production  

**Program Purpose**  
This program generates a printed account statement for one or more customers.  It gathers a date, optional customer account numbers and a minimum outstanding value, then retrieves the relevant sales and open‑item records, formats them into line items, and prints the statement on pre‑printed or laser forms.  The process validates input dates, ensures that only applicable transactions are shown, and produces a totals section that aids audit and compliance by showing balances in current, 30‑day, 60‑day, 90‑plus‑day and total‑due categories.

**Screen Interactions**  

1. **Input screen** – Displays a field for *Date*, *A/C Nos* and *Value* with prompts and instructions.  
2. **Notes area** – Shows three instructional notes (e.g., “<Date> appears on statement”).  
3. **Flavour lines screen** – Two message lines (Msg Line 1 and Msg Line 2) where the user can enter up to 64 characters each.  
4. **Alignment confirmation** – After printing, the program asks “Statement correctly aligned… (Y/N) ? – [ ]”.  

No additional interactive screens are presented.

**Messages and Errors**  

- *Missing file error*: If the required sales data file is not found, the program displays a notice that sales transactions are not posted and then waits for the user to press return.  
- *Invalid date*: If the date entered is not a valid calendar date, the program re‑prompts for the date until a valid entry is made.  
- *Alignment check*: If the user indicates the statement is not properly aligned, the program re‑prints the heading section and allows a second alignment confirmation.  
- *Other informational prompts*: The program shows generic prompts for entering data and for confirming completion of printing.  

**User Flow Summary**  

The user begins by entering a statement date, optionally a list of customer account numbers and a minimum outstanding value.  After confirming the date, the program validates it and then asks for two optional message lines to appear on the statement.  It then searches the sales and open‑item records for the specified customers and date, filters out transactions that are fully paid or below the specified value, and assembles each line item with details such as invoice number, date, description and amount.  For each customer, the program prints a header, the list of line items, and a totals section that separates balances into ageing buckets.  After printing, the user is asked whether the statement is correctly aligned; if not, the headings are re‑printed and the alignment is verified again.  Finally the program terminates, having produced a complete statement ready for distribution.

**Program Linkages**  

- CBL_CHECK_FILE_EXIST  
- SYSTEM  
- maps04   (via CALL “maps04” using maps03-ws)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** paragraph, performing file existence checks, setting screen exception flags, and displaying the header and current date. [Seen in: init01.]  
It then proceeds to the **statements** section where it displays input prompts, accepts the statement date, customer number, minimum balance, and optional flavour lines, converting the date into an internal format. [Seen in: statements.]  
After gathering input, the program opens the necessary data files (sales, open‑item, and print), starts the sales file at the requested key, and enters the main processing loop that reads sales and open‑item records, prints statement lines, and updates balances until all customers are processed. [Seen in: read-sales, read-open-item.]  
Once all records for a customer are printed, the **end-statement** paragraph finalises the page, prints totals, and resets counters before looping back to the next customer. [Seen in: end-statement.]  
When no more customers remain, the **main-end** paragraph closes all files and exits the program. [Seen in: main-end.]

5.2 Initialization  
The **init01** paragraph checks for the presence of the ITM3 file, displays error messages if missing, sets screen exception handling, assigns the spool name, and converts the current date for display. [Seen in: init01.]  
It then calls **zz070-Convert-Date** to format the system date, displays the program name and title, and performs the **statements** section to collect user input. [Seen in: zz070-Convert-Date, statements.]

5.3 Core Processing  
Path: Initialization  
Trigger: Program start.  
Key steps: File existence check, environment flag setting, spool name assignment, date conversion, header display.  
I/O: None.  
Outcomes: Environment prepared, header displayed, date ready.  
[Seen in: init01.]

Path: User Input  
Trigger: After initialization.  
Key steps: Display prompts for date, customer, value, flavour lines; accept and validate date; accept customer number; accept value; accept flavour lines; convert date to binary.  
I/O: None.  
Outcomes: ws-date, customer-in, pay-value, flavour lines populated.  
[Seen in: statements, date-input, customer-input, value-input, flavour-in.]

Path: Sales Loop  
Trigger: After user input and file opening.  
Key steps: Open sales and open‑item files (or RDB tables), open print file, set sales key, read next sales record, filter by customer and amount, set address lines, print headings, handle unapplied credit, then go to read‑open‑item.  
I/O: sales-file, open-item-file-s, print-file.  
Outcomes: Sales header printed, unapplied credit printed, ready to process open‑item records.  
[Seen in: read-sales.]

Path: Open‑Item Loop  
Trigger: After processing a sales record.  
Key steps: Read open‑item records, filter by customer, process each type (2,3,5,6) to compute amounts, ageing, update balances, print statement lines, loop until all items for the customer are processed.  
I/O: open-item-file-s.  
Outcomes: Statement lines printed, balances updated, l‑p counter advanced.  
[Seen in: read-open-item.]

Path: End‑Statement  
Trigger: When no more open‑item records for the customer.  
Key steps: Compute remaining lines, print flavour lines, print totals, reset balances, write blank lines, then loop back to read‑sales for next customer.  
I/O: print-file.  
Outcomes: Statement page completed, counters reset, ready for next customer.  
[Seen in: end-statement.]

Path: Main‑End  
Trigger: After all customers processed.  
Key steps: Close print file, close sales file, clear open‑item file if using files, exit program.  
I/O: print-file, sales-file, open-item-file-s.  
Outcomes: All files closed, program terminated.  
[Seen in: main-end.]

5.4 Termination  
The **main-end** paragraph closes all open files, clears the open‑item file if file mode is used, and exits the program. [Seen in: main-end.]  
No further processing occurs after the GOBACK/EXIT in **main-end**. [Seen in: main-end.]

---
## sl115
*[204/267]*

### Business/Functional Perspective
### Statement & Trial Balance Sort  

**Program Purpose**  
The program prepares sorted transaction data for statement generation and trial balance reporting. It reads transaction records from a master file, orders them by customer, date, invoice, and type, and writes the sorted list to a staging file used by downstream reporting modules. By ensuring the data is correctly ordered, the program supports accurate financial statements and compliance with accounting standards. It also verifies that sales transaction data is available before proceeding, preventing downstream errors.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the required sales‑transaction file is missing, the user is shown a message that the sales transactions have not been posted and is prompted to press return to continue.  
- If no sorting is required (e.g., the program is invoked after a previous sort), the program exits quietly.  
- If the program cannot find the file that contains the data to be sorted, it stops and informs the user that the data is unavailable.  

**User Flow Summary**  
The user initiates the statement and trial balance preparation process, which calls this program. The program first checks whether sorting is necessary and verifies that the sales‑transaction file exists. If the file is absent, the user receives a notification and can correct the issue before retrying. When the file is present, the program reads each transaction record, writes a sorted version of the record to an output file, and then exits. The sorted output file is then consumed by subsequent modules that generate the statement and trial balance. Throughout, the user does not interact with the program except for any error prompts.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the procedure division and immediately performs the init01 section, which checks whether COBOL files are used and whether a previous sorted file is available. [Seen in: init01]  
If the checks pass, the program performs the Sorting-1 section, which initiates a sort of the open‑item data into a temporary sort file using the input-to-sort procedure. [Seen in: Sorting-1]  
After sorting completes, the program exits via the menu‑exit paragraph, returning control to the caller. [Seen in: menu-exit]

5.2 Initialization  
The init01 section verifies that COBOL files are in use; if not, it gobacks with return code 4. [Seen in: init01]  
It also checks the oi‑3‑flag; if it is “N”, the program skips sorting and exits immediately. [Seen in: init01]

5.3 Core Processing  
Path: No COBOL Files Used  
Trigger: FS‑Cobol‑Files‑Used = “N”  
Key steps: goback returning 4, skipping all further processing.  
I/O: none.  
Outcomes: program terminates early.  
[Seen in: init01]

Path: Previous Sorted File Exists  
Trigger: oi‑3‑flag = “N”  
Key steps: go to menu‑exit, exit program.  
I/O: none.  
Outcomes: program terminates without sorting.  
[Seen in: init01]

Path: File Not Found  
Trigger: CBL_CHECK_FILE_EXIST returns non‑zero for File‑19  
Key steps: set oi‑3‑flag to “Y”, display error messages SL151 and SL003, accept user reply, go to menu‑exit.  
I/O: File‑19, display output.  
Outcomes: program terminates with error status.  
[Seen in: init01]

Path: Sorting  
Trigger: FS‑Cobol‑Files‑Used = “Y” and oi‑3‑flag = “N” and file exists  
Key steps: perform Sorting‑1, which executes a sort on sort‑file with keys s‑customer, s‑date, s‑invoice, s‑type; the input procedure input‑to‑sort opens the open‑item file, reads each record, releases it into the sort file, and closes the file when done.  
I/O: open‑item‑file‑3 (input), sort‑file (output).  
Outcomes: sort‑file populated, oi‑3‑flag set to “N”, program proceeds to menu‑exit.  
[Seen in: Sorting-1, input-to-sort, process-input, end-of-input]

5.4 Termination  
The menu‑exit paragraph exits the program, returning control to the caller. [Seen in: menu-exit]  
No additional cleanup is performed beyond the implicit closure of the sort file by the sort operation. [Seen in: Sorting-1]

---
## sl120
*[205/267]*

### Business/Functional Perspective
### Aged Debtor Analysis  

**Program Purpose**  
The program produces a detailed aged debtor (receivables) report that lists customer accounts, outstanding invoices, payment history, credit limits, and other key balances. It aggregates amounts into age buckets (current, 30, 60, 90+ days) and summarizes totals, averages, and outstanding cash. The report helps finance staff assess collection risk, verify posted transactions, and support decision‑making on credit policy and cash‑flow management.  

**Screen Interactions**  
1. **Report Setup Screen** – Displays the title “Aged Debtors Report” and prompts the user for:  
   - **Date**: the reporting date (appears on the listing).  
   - **A/C Nos**: optional account numbers to filter the report.  
   - **Value**: a minimum balance threshold for inclusion.  
   The screen also shows instructional notes:  
   - (1) Date appears on listing.  
   - (2) A/C Nos filters which accounts are printed.  
   - (3) Value limits the minimum outstanding balance.  
   The user enters these values and presses **Enter** to continue.  

2. **Amount Entry Field** – After the initial screen, the program requests a monetary value (the “Value” field). The user enters the amount in pounds and pence and confirms with **Enter**.  

**Messages and Errors**  
- If sales transactions have not been posted, the program displays “Sales Transactions Not Posted” and waits for the user to continue.  
- If payments proofed have not been posted, the program shows “Payments Proofed Not Posted” and pauses.  
- If no open invoice records are present, it alerts “No Open invoice records present” and stops further processing.  
- For any missing required file (e.g., the open‑items file), the user sees “Sales Transactions Not Posted” (or the appropriate message) followed by a prompt to hit **Return** to continue.  
- Invalid date entries prompt the user to re‑enter the date.  

**User Flow Summary**  
The user launches the program, which first displays a screen requesting the report date, any specific account numbers, and a minimum balance value. After entering these parameters and the amount field, the program validates the date format and then processes all relevant sales and open‑item records. It calculates aging buckets, payment status, credit balances, and other key statistics. The resulting report is written to the print spool (or displayed on the screen) and includes a header, detailed line items per customer, summary totals, and reconciliation data. The user can then review the report, verify accuracy, and use it for collections or financial analysis.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in the procedure division, performing initialization and displaying the header. [Seen in: init01 section.]  
The user is prompted for a date, customer key, and amount, which are validated and converted. [Seen in: date-input, customer-input, value-input.]  
Sales and open‑item records are read sequentially, aging calculations are performed, and report lines are written to the print file. [Seen in: Sales-Open-Input, read-sales, read-open-item, end-statement.]  
After all records are processed, a summary analysis is generated and written to the print file. [Seen in: report-analysis.]  
The print file is closed, the report is sent to the printer, and the program exits. [Seen in: main-end, close print-file, call SYSTEM.]

5.2 Initialization  
The init01 section clears the screen, checks the FS-Cobol-Files-Used flag, and verifies the existence of the open‑item file. [Seen in: init01 section.]  
The program displays the program name and prompts for the date, converting it to internal binary format. [Seen in: init01 section, zz070-Convert-Date.]

5.3 Core Processing  

Path: Date Input & Validation  
Trigger: User enters a date at the date prompt.  
Key steps: display date prompt, accept date, validate via zz050-Validate-Date, convert to binary.  
I/O: none.  
Outcomes: sets ws-date, entered-date, u-bin.  
[Seen in: date-input, zz050-Validate-Date, zz050-test-date, zz050-exit.]

Path: Customer Input  
Trigger: User enters a customer key.  
Key steps: accept customer-in, convert to upper case.  
I/O: none.  
Outcomes: sets WS-Sales-Key.  
[Seen in: customer-input.]

Path: Sales and Open‑Item Processing  
Trigger: After opening files, the program reads sales records and then open‑item records for each customer.  
Key steps: open sales-file, read-sales, read-open-item, compute aging, write print lines, update totals.  
I/O: sales-file, open-item-file-s, print-file.  
Outcomes: populates report lines, updates totals, writes to print file.  
[Seen in: Sales-Open-Input, read-sales, read-open-item, zz060-Convert-Date, zz070-Convert-Date, check-zero, end-statement, write print-record.]

Path: Report Analysis  
Trigger: After all records are processed, report-analysis is performed.  
Key steps: compute totals, percentages, averages, write summary lines.  
I/O: print-file.  
Outcomes: final summary report lines.  
[Seen in: report-analysis, headings-1, write print-record.]

Path: Termination  
Trigger: Program reaches main-end or menu-ent.  
Key steps: close open-item-file-s, close sales-file, close print-file, call SYSTEM to print, GOBACK.  
I/O: close files, system call.  
Outcomes: report printed, program exits.  
[Seen in: main-end, Sales-Close, OTM3-Close, close print-file, call SYSTEM, main-exit.]

5.4 Termination  
The main-end paragraph closes all open files, calls the system print routine, and exits the program. [Seen in: main-end, close print-file, call SYSTEM, main-exit.]  
If the user aborts at the date prompt, the program exits immediately after clearing the screen. [Seen in: date-input, main-exit.]

---
## sl130
*[206/267]*

### Business/Functional Perspective
### Sales Analysis Report  

**Program Purpose**  
The program generates a printed Sales Analysis report. It reads value data records, filters for sales entries, calculates transaction and volume metrics, and prints a formatted report that includes totals, percentages, and trend information. The report supports business decision‑making by summarizing current versus previous periods and providing year‑to‑date comparisons, thereby aiding financial oversight and planning.  

**Screen Interactions**  
1. **Header Display** – Shows the title “Sales Analysis”, the page number, the user’s name, and the current date. This screen appears at the start of the program and on each new page of the report.  
2. **Error Prompt** – If the program cannot open the value file or encounters a read error, it displays an error message followed by “Hit Return To Continue”. The user presses the Enter key to acknowledge the message before the program exits.  

**Messages and Errors**  
- **No Data** – “No data, nothing to do – exiting.” The report is not generated.  
- **Read Error** – “Error reading value records – <detail>.” The program stops and prompts the user to press Return.  
- **Successful Completion** – The report is printed to the spool device; no further user action is required.  

**User Flow Summary**  
When the user initiates the program, it first shows a header containing the report title, page number, user name, and date. It then attempts to open the value data file. If the file is missing or unreadable, a clear message is shown and the user presses Return to exit. If the file opens successfully, the program reads each record, selects only sales entries, calculates transaction totals and growth percentages, and writes a formatted line to the print spool for each record. Once all records are processed, the program closes the files and triggers the printing of the report. Finally, the program ends and control returns to the calling context.  

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in **init01**, initializing spool name, header display, and converting the current date before invoking **Report1**. [Seen in: init01 section.]  
**Report1** opens the value file, reads each record, and writes formatted report lines to the Print‑File, handling errors and page breaks as needed. [Seen in: Report1 section.]  
Upon completion, **Report1** closes the files, calls the SYSTEM routine to print the report, and the program exits via **Main‑Exit**. [Seen in: End-Report section.]

5.2 Initialization  
**init01** sets the spool name, program version, and prints the report title and user information, then converts the current date to UK format and displays it. [Seen in: init01 section.]  
It then performs **Report1** to generate the report, reads and rewrites system parameters, clears the sales analysis flag, and finally exits if required. [Seen in: init01 section.]  
The program uses early PERFORMs to open the value file and to set up the print spool before any data processing begins. [Seen in: init01 section.]

5.3 Core Processing  

Path: Normal Report Generation  
Trigger: Program start after **init01**, performing **Report1**.  
Key steps: Value‑Open‑Input; loop reading records with Value‑Read‑Next; filter by va‑system “S”; format and write report lines; handle page breaks via Headings; close files; call SYSTEM.  
I/O: Value‑File (input), Print‑File (output).  
Outcomes: WS‑Term‑Code set to 0, report printed, program exits.  
[Seen in: Report1 section, Read‑Loop paragraph, Headings paragraph, End‑Report section.]

Path: Value File Open Failure  
Trigger: fs‑reply not zero after Value‑Open‑Input.  
Key steps: perform Value‑Close; display SL161; if caller not xl150 display SL003 and accept menu‑reply; go to Main‑Exit.  
I/O: Value‑File (input).  
Outcomes: program exits without generating a report.  
[Seen in: Report1 section.]

Path: Value File Read Error  
Trigger: fs‑reply not zero after Value‑Read‑Next.  
Key steps: display SL160 and Eval‑Msg; if caller not xl150 display SL003 and accept menu‑reply else set WS‑Term‑Code to 9; go to End‑Report.  
I/O: Value‑File (input).  
Outcomes: WS‑Term‑Code set to 9, report closed, program exits.  
[Seen in: Report1 section, Read‑Loop paragraph.]

Path: Group Header Path  
Trigger: va‑second = space and va‑gl = zero.  
Key steps: set l6‑type to “Group”; perform Headings; write blank line; increment line‑cnt.  
I/O: Print‑File (output).  
Outcomes: page heading printed.  
[Seen in: Report1 section, Read‑Loop paragraph.]

Path: Detail Line Path  
Trigger: va‑second not space or va‑gl not zero.  
Key steps: set l6‑type to “ Detail”; move group, desc, totals, percentages; write line‑6 to Print‑File; increment line‑cnt; check page break.  
I/O: Print‑File (output).  
Outcomes: report line written.  
[Seen in: Report1 section, Read‑Loop paragraph.]

5.4 Termination  
**End‑Report** closes the Print‑File and value file, calls the SYSTEM routine to print the report, and then **Main‑Exit** performs a GOBACK to terminate the program. [Seen in: End‑Report section.]  
The program may also exit early via **menu‑Exit** if an error occurs before report generation. [Seen in: menu‑Exit paragraph.]

---
## sl140
*[207/267]*

### Business/Functional Perspective
### Day Book Report  

**Program Purpose**  
This program produces a day‑book report that lists all customer invoices, receipts and credit notes for a specified date. It aggregates totals for goods, discounts, deductions, carriage, net, VAT and gross amounts and outputs a formatted print file (spool). The report supports audit trails and financial close processes by providing a clear, date‑specific summary of all sales activity.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *No data* – If the invoice file cannot be opened, the program stops and indicates that nothing can be processed.  
- *Customer unknown* – When an invoice refers to a customer not found in the sales file, the report marks the name with “!! CUSTOMER UNKNOWN” and notes the error.  
- *Missing sales records* – After processing, if any sales records were missing from the sales file, the program prints a warning on the report.  

**User Flow Summary**  
1. The user initiates the report for a chosen date.  
2. The program reads the invoice and sales files, filtering for day‑booked and applied entries.  
3. For each matching invoice, it looks up the customer name and calculates net, VAT and gross amounts, writing a line to the print file.  
4. After all records are processed, the program prints heading lines, a totals summary and any missing‑record warnings.  
5. The print file is sent to the system printer, and the program ends.  

**Program Linkages**  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in **init01**, setting up spool name, dates, and zeroing totals. [Seen in: init01.]  
**menu-return** displays the program title and date, then opens invoice and sales files, handling errors by displaying SL161 and exiting. [Seen in: menu-return.]  
The main processing **loop** reads invoice headers, filters by type and booking status, reads corresponding sales records, formats dates, calculates amounts, writes line items, and repeats until end of file. [Seen in: loop.]  
After all invoices are processed, **main-end** writes totals, closes files, and triggers the print report routine before returning. [Seen in: main-end.]  
The **headings** section prints page headers each time the line count exceeds the page limit. [Seen in: headings.]

5.2 Initialization  
**init01** moves spool name, program name, user, and date into screen fields, converts the date, and zeroes the line counter and totals. [Seen in: init01.]  
**menu-return** displays the program title, date, and opens the invoice and sales input files, checking for errors and displaying SL161 if either file fails to open. [Seen in: menu-return.]  
If file opens succeed, the print file is opened for output and the first page headings are printed by calling **headings**. [Seen in: menu-return.]

5.3 Core Processing  
Path: Invoice Processing Loop  
Trigger: **Invoice-Read-Next-Header** returns fs-reply not 10 (not end‑of‑file). [Seen in: loop.]  
Key steps: filter by item‑nos, invoice‑type, day‑booked/applied; read sales record; convert date; calculate amounts; update totals; write line‑5; increment line‑cnt; go to loop. [Seen in: loop.]  
I/O: invoice‑file (read), sales‑file (read), print‑file (write). [Seen in: loop.]  
Outcomes: line‑cnt incremented, totals updated, print‑file records added. [Seen in: loop.]

Path: Headings Refresh  
Trigger: line‑cnt > Page‑Lines. [Seen in: loop.]  
Key steps: perform **headings**. [Seen in: headings.]  
I/O: print‑file (write). [Seen in: headings.]  
Outcomes: new page header printed, line‑cnt reset to 2. [Seen in: headings.]

Path: Totals Printing  
Trigger: **main-end** after loop completes. [Seen in: main-end.]  
Key steps: perform **print-totals** 4 times, write totals lines, close print‑file, call SYSTEM to print. [Seen in: main-end.]  
I/O: print‑file (write), SYSTEM call. [Seen in: main-end.]  
Outcomes: totals displayed, report printed, program exits. [Seen in: main-end.]

Path: Sales Record Missing  
Trigger: **Sales-Read-Indexed** returns fs-reply 21. [Seen in: loop.]  
Key steps: set l5-name to "!! CUSTOMER UNKNOWN", set ws-error to 1. [Seen in: loop.]  
I/O: none. [Seen in: loop.]  
Outcomes: error flag set, unknown customer indicated on line. [Seen in: loop.]

Path: File Open Failure  
Trigger: fs-reply not zero after **Invoice-Open-Input** or **Sales-Open-Input**. [Seen in: menu-return.]  
Key steps: close any opened files, display SL161, goback. [Seen in: menu-return.]  
I/O: display. [Seen in: menu-return.]  
Outcomes: program exits with message. [Seen in: menu-return.]

Path: Date Conversion  
Trigger: **zz060-Convert-Date** called during processing. [Seen in: loop.]  
Key steps: convert binary date to string format. [Seen in: zz060-Convert-Date.]  
I/O: none. [Seen in: zz060-Convert-Date.]  
Outcomes: ws-date set for display. [Seen in: zz060-Convert-Date.]

5.4 Termination  
**main-end** closes the sales and invoice files, writes final totals, closes the print file, and calls the SYSTEM routine to print the report before gobacking. [Seen in: main-end.]  
**menu-call** simply performs a GOBACK to return control to the caller. [Seen in: menu-call.]

---
## sl160
*[208/267]*

### Business/Functional Perspective
### Customer Alphabetical Listing  

**Program Purpose**  
The program generates an alphabetically sorted list of customers for a specified period. It allows the user to filter by customer number, status (live, dormant, or all), credit period, invoice activity, average invoice value, overdue days, and the date the customer record was entered. The resulting report provides contact information, account status, credit limits, and any outstanding charges or letters. This helps the business review customer standing, manage credit risk, and plan follow‑up actions.

**Screen Interactions**  
1. **Screen Title** – “Customer File” displayed at the top.  
2. **Date Display** – Current date shown in the upper left corner.  
3. **Prompts** – The screen lists the following fields for user input:  
   - *Customer Number* (6 characters) – characters to match.  
   - *Status* (1 character) – `<L>` for live, `<D>` for dormant, or space for all.  
   - *Credit Period* – number of days followed by an operator (`<`, `>`, `=`).  
   - *Invoice Activity* – number of invoices with an operator.  
   - *Average Value* – invoice value with an operator.  
   - *Overdue A/Cs* – number of overdue days with an operator.  
   - *Date Entered* – a date in the current system format with an operator.  
4. **Navigation** – The screen accepts input and the user can press **Enter** to submit; the program detects Esc, Page‑Up, Page‑Down, and Print Screen keys for standard screen handling.  

**Messages and Errors**  
- If the date entered in the “Date Entered” field is not a valid calendar date, the program displays a clear “Invalid Date” message and returns to the input screen.  
- If a selected customer key cannot be found in the sales file, a “Record not found” notice is shown for that customer before continuing with the next record.  
- No other user‑visible error messages are produced.  

**User Flow Summary**  
The user launches the program and sees the “Customer File” screen. They enter any combination of the filter fields and press **Enter**. The program validates the date format and then scans the customer data, applying each filter in turn. For each customer that matches all criteria, the program prints a line of the report showing the customer’s name, address, telephone, fax, status, credit information, and any outstanding charges or letters. When a delivery address or notes are present, those are printed as additional lines beneath the customer’s main record. The report is paginated, with clear headings at the top of each page. When the scan completes, the printer output is finalized and the program exits.

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in init01, sets up dates, environment, and then calls Report1. [Seen in: init01 section.]  
Report1 opens the sales and delivery files, gathers user selection criteria, prepares report headings, and then enters the main report generation loop. [Seen in: Report1 section.]  
The report loop reads each customer record (either from a pre-sorted file or directly from the database), applies the selection filters, and prints matching records with optional delivery and notes details. [Seen in: Report-Produce section.]  
After all records are processed, Report1 closes files, finalizes the print spool, and exits the program. [Seen in: Report1 section.]

5.2 Initialization  
init01 moves the program name to the header, converts the current date to UK format, and stores it in the header line. [Seen in: init01 section.]  
It sets screen exception flags, initializes the print spool name and file key, and performs the initial report generation by calling Report1. [Seen in: init01 section.]

5.3 Core Processing  
Path: Report-Selection  
Trigger: User input via screen display.  
Key steps: display screen, accept input, validate fields, convert date if entered, set selection criteria.  
I/O: screen.  
Outcomes: selection variables populated, possible early exit if date invalid.  
[Seen in: Report-Selection section.]

Path: Read-Loop (Report-Produce)  
Trigger: Entered into report loop after headings.  
Key steps: read next record from sales-sort or sales file, apply selection tests, call Listing if record matches, loop until end.  
I/O: sales-sort file, sales file, print-file.  
Outcomes: records printed, line counter updated.  
[Seen in: Report-Produce section.]

Path: Sales-Read-Next-Sorted-By-Name  
Trigger: When FS-Cobol-Files-Used is false, perform Sales-Read-Next-Sorted-By-Name to get next record in order.  
Key steps: read next sorted record, check end-of-file, set WS-Sales-Key.  
I/O: sales file (RDB).  
Outcomes: WS-Sales-Key set, control passes to Read-Loop-Tests.  
[Seen in: Report-Produce section.]

Path: Sales-Read-Indexed  
Trigger: When using Cobol files, perform Sales-Read-Indexed to read the sales record by key.  
Key steps: read record by key, handle key not found error.  
I/O: sales file.  
Outcomes: sales record fields populated, error displayed if key missing.  
[Seen in: Report-Produce section.]

Path: Delivery-Print  
Trigger: After printing a customer record, if delivery-tag > 0, perform Delivery-Print.  
Key steps: set delivery key, read delivery record, handle missing record, format delivery details, write to print file.  
I/O: delivery file, print file.  
Outcomes: delivery details printed.  
[Seen in: Delivery-Print paragraph.]

Path: Notes-Print  
Trigger: After printing a customer record, if Notes-Tag > 0, perform Notes-Print.  
Key steps: set delivery key, read delivery record, format notes, write to print file.  
I/O: delivery file, print file.  
Outcomes: notes printed.  
[Seen in: Notes-Print paragraph.]

5.4 Termination  
Report1 closes the print file, sales-sort file, and any open sales or delivery files, then calls the SYSTEM routine to finalize printing. [Seen in: Report1 section.]  
If Cobol files were used, it opens and immediately closes the sales-sort file to create a null file, then exits the program via main-exit. [Seen in: Report1 section.]

---
## sl165
*[209/267]*

### Business/Functional Perspective
### Sales Ledger Alpha Sort  

**Program Purpose**  
The program reads an unsorted list of sales ledger customers and produces a new file that lists those customers in alphabetical order by name. This sorted list is used by other reporting and processing routines that require quick lookup of customer information. By ensuring the data is correctly ordered, the system avoids duplication errors, speeds up downstream look‑ups, and supports accurate reporting for compliance and audit purposes.  

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry or batch step and returns a sorted file to that context.  

**Messages and Errors**  
- If the required sales file cannot be opened, the program stops and reports a failure status.  
- If the input file is not found or is empty, the sort completes with no output records.  
- If the sort process encounters an internal error (e.g., file system or access error), the program terminates with an error status.  

**User Flow Summary**  
When the program is started, it first verifies that the environment is configured to use COBOL files. It then opens the source sales customer file, reads each record, and builds a sort record containing the customer key and name. A sort operation is performed on these records, arranging them in ascending alphabetical order by name. As each sorted record becomes available, it is written to an output file that becomes the new, alphabetically sorted customer list. Once all records have been processed, the program closes the files and exits, returning control to the calling routine.  

**Program Linkages**  
No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the procedure division, which immediately invokes the init01 section to verify file usage and prepare the sorting environment. [Seen in: init01 section.]  
The init01 section initiates a sort operation on the sort-file, directing the input procedure to input-to-sort and the output procedure to output-from-sort. [Seen in: init01 section.]  
After the sort completes, init01 closes the sales-sort file, performs Sales-Close to close the sales input file, and exits the program. [Seen in: init01 section.]

5.2 Initialization  
The init01 section first checks the FS-Cobol-Files-Used flag and returns with status 4 if files are not in use. [Seen in: init01 section.]  
It then performs Sales-Open-Input to open the sales input file and opens the sales-sort file for output. [Seen in: init01 section.]  
The sort-file is opened for sorting, with the input procedure set to input-to-sort and the output procedure set to output-from-sort. [Seen in: init01 section.]  
After sorting, the sales-sort file is closed and Sales-Close is performed to close the sales input file. [Seen in: init01 section.]

5.3 Core Processing  
Path: Init-Sequence  
Trigger: Entry into the procedure division.  
Key steps: perform Sales-Open-Input, open sales-sort, invoke sort on sort-file, close sales-sort, perform Sales-Close, exit program.  
I/O: sales input file, sort-file, sales-sort output file.  
Outcomes: sorted file created, program exits.  
[Seen in: init01 section.]

Path: Input-to-Sort  
Trigger: Sort-file input procedure calls input-to-sort section.  
Key steps: perform Sales-Read-Next, if end-of-file go to its-exit, move WS-sales-key to sort-key, move sales-name to sort-name, release sort-record, loop.  
I/O: sales input file, sort-file.  
Outcomes: sort-records released to sort-file for sorting.  
[Seen in: input-to-sort section.]

Path: Output-from-Sort  
Trigger: Sort-file output procedure calls output-from-sort section.  
Key steps: return sort-file at end, move sort-key to sales-sort-key, write sales-sort-record, loop.  
I/O: sort-file, sales-sort output file.  
Outcomes: sorted records written to sales-sort file.  
[Seen in: output-from-sort section.]

5.4 Termination  
After the sort completes, init01 closes the sales-sort file, performs Sales-Close to close the sales input file, and exits the program via end-program and exit program. [Seen in: init01 section.]  
No additional cleanup is performed beyond closing the files and returning control to the caller. [Seen in: init01 section.]

---
## sl170
*[210/267]*

### Business/Functional Perspective
### Sales Ledger Dump  

**Program Purpose**  
The program produces a printable sales ledger report that lists customer details and key sales metrics. It allows users to filter customers by number, status (Live/Dormant/All), credit period, invoice activity, average transaction value, and overdue days. The resulting report supports audit, compliance, and credit‑control decisions by giving a comprehensive view of each customer’s standing and activity.  

**Screen Interactions**  
1. **Customer File Screen** –  
   * *Title*: “Customer File”  
   * *Fields*:  
     - **Customer Number** – 6‑character code, optional wildcard.  
     - **Status** – single character: “L” for Live, “D” for Dormant, or blank for all.  
     - **Credit Period** – number of days and operator (L for less than, G for greater than, E for equal).  
     - **Invoice Activity** – number of invoices and operator.  
     - **Average Value** – invoice value and operator.  
     - **Overdue A/Cs** – number of days overdue and operator.  
   * *Instructions*: Each field is entered in the brackets; the screen repeats if an invalid value is supplied.  

**Messages and Errors**  
- If the sales file cannot be opened, the program terminates without a report.  
- Invalid input (status other than L/D/blank, or operator other than L/G/E/blank) prompts the user to re‑enter that field.  
- If no customer records match the criteria, the program produces no report.  
- On successful completion, a formatted report is sent to the print spool.  

**User Flow Summary**  
1. The user runs the program and is presented with the “Customer File” screen.  
2. The user enters any combination of filter criteria; leaving a field blank means “match all”.  
3. After pressing Enter, the program validates the entries and processes the sales ledger.  
4. For each customer that satisfies all criteria, the program writes a set of printed lines containing:  
   - Sales key, credit period, current balance, discount, last transaction date, address lines, late limits, turnover by quarter, delivery tag, activity level, late status, email usage, and other status flags.  
5. The report is paginated and printed; if fewer than three records are printed, the header repeats.  
6. When processing completes, the program closes the sales file, prints the report (if any records were found), and exits back to the calling context.  

**Program Linkages**  
- maps04  
- SYSTEM (Print‑Report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in **init01**, setting up environment, converting the current date, and displaying the initial screen. [Seen in: init01.]  
It then performs **report-1**, which orchestrates report selection, heading setup, and report production. [Seen in: report-1.]  
After report generation, control returns to **init01** which exits the program. [Seen in: init01.]

5.2 Initialization  
**init01** initializes program metadata, converts the current date to the desired format, and configures screen exception handling. [Seen in: init01.]  
It also sets the spool name, file key, and then invokes **report-1** to begin report processing. [Seen in: init01.]

5.3 Core Processing  
Path: **Report-Selection**  
Trigger: Called from **report-1** before heading setup.  
Key steps: Open sales input file, accept user criteria, validate status and operators, set defaults.  
I/O: Sales file (input).  
Outcomes: Sets criteria variables, prepares for report generation.  
[Seen in: report-selection.]

Path: **Produce-Report**  
Trigger: Called from **report-1** after heading setup.  
Key steps: Open print-file, write headings, read sales records in loop applying filters, call **listing** for matched records.  
I/O: Print-file (output), Sales file (input).  
Outcomes: Generates report lines, counts records, sets Rec-Cnt.  
[Seen in: produce-report.]

Path: **Test-Array**  
Trigger: Invoked during read-loop when customer-in not spaces to test key array.  
Key steps: Iterate array-l to compare with WS-Sales-Key, set truth flag.  
I/O: None.  
Outcomes: Determines if record matches key array; may skip record.  
[Seen in: test-array.]

Path: **Test-Num**  
Trigger: Invoked during read-loop for numeric criteria (credit, invoice, average, overdue).  
Key steps: Compare test-1 and test-2 using operator test-op, set truth flag.  
I/O: None.  
Outcomes: Determines if numeric filter passes; may skip record.  
[Seen in: test-num.]

Path: **Headings-1**  
Trigger: Called at start of produce-report and after every 3 records.  
Key steps: Increment page counter, write header lines, manage page breaks.  
I/O: Print-file.  
Outcomes: Maintains page formatting and header output.  
[Seen in: headings-1.]

Path: **Listing**  
Trigger: Called for each record that passes filters in produce-report.  
Key steps: Populate line-4 fields with sales data, write record lines, handle email info, manage record count and page breaks.  
I/O: Print-file.  
Outcomes: Outputs detailed customer record to report.  
[Seen in: listing.]

5.4 Termination  
After report generation, **end-report** closes the print file, closes the sales file, and invokes the external print routine if any records were printed. [Seen in: end-report.]  
Control then returns to **init01** which performs menu-exit and exits the program. [Seen in: init01.]

---
## sl180
*[211/267]*

### Business/Functional Perspective
### Sales Ledger Turnover Report

**Program Purpose**  
The program generates a printable Sales Ledger Turnover Report that summarizes each customer’s sales activity, credit limits, and payment status. It allows users to filter the report by customer number, status, credit period, invoice activity, average sale value, overdue accounts, and the date the account was entered. By presenting this information in a concise, paginated format, the report supports sales management and financial oversight, helping to identify delinquent accounts, evaluate credit terms, and monitor sales trends.

**Screen Interactions**  
1. **Criteria Entry Screen** –  
   - **Title:** “Customer File” and “Report Attributes” displayed at the top.  
   - **Fields (input):**  
     - *Customer Number* – six‑character field for a specific customer or blank for all.  
     - *Status* – single character: “L” for live, “D” for dormant, or blank for all.  
     - *Credit Period* – number of days with an operator: “L” (<), “G” (>), or “E” (=).  
     - *Invoice Activity* – number of invoices with an operator.  
     - *Average Value* – average invoice amount with an operator.  
     - *Overdue Accounts* – number of days overdue with an operator.  
     - *Date Entered* – date when the account was created, with an operator.  
   - **Instructions:** Prompts guide the user to enter values or leave blanks to include all records. The screen loops until all inputs are accepted.

**Messages and Errors**  
- If the date entered for “Date Entered” is not a valid calendar date, the user is informed that the date is invalid.  
- If any operator field contains an illegal character, the screen re‑prompts the user for correct input.  
- On successful completion, the program prints the report; otherwise, the user is returned to the criteria entry screen to correct inputs.

**User Flow Summary**  
The user starts by pressing the key that invokes the report program. The criteria entry screen appears, and the user supplies the desired filters. After confirming the input, the program reads the sales file, applying the criteria to each record. Matching records are formatted into report lines that include the customer number, name, credit terms, current balance, last invoice, and quarter sales totals. Each page begins with a header showing the report title, page number, user name, and the current date. Once all qualifying records are processed, the program finishes printing and returns control to the calling context.

**Program Linkages**  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts, performs initialization, opens the sales and print files, then displays the selection screen. [Seen in: init01 section.]  
User enters selection criteria; the program validates input and prepares filter variables. [Seen in: report-selection section.]  
The program then reads the sales file, applies the filters, prints qualifying records, and finally closes files and exits. [Seen in: produce-report section.]

5.2 Initialization  
The init01 section sets the program name, converts the current date to the appropriate format, and configures screen exception handling. [Seen in: init01 section.]  
It opens the sales input file and the print output file, then calls report-selection to gather user criteria. [Seen in: init01 section.]

5.3 Core Processing  
Path: Report Selection  
Trigger: User enters selection criteria on the screen.  
Key steps: initialize selection variables, display screen, accept data, validate date, set flags.  
I/O: screen only.  
Outcomes: sets selection criteria variables, prepares for produce-report.  
[Seen in: report-selection section.]

Path: Produce Report  
Trigger: After report-selection, perform produce-report.  
Key steps: open sales file, set key, read loop, filter records, call listing, manage page headings.  
I/O: sales-file (input), print-file (output).  
Outcomes: prints report, sets line-cnt, page count.  
[Seen in: produce-report section.]

Path: Read Loop  
Trigger: Inside produce-report, perform Sales-Read-Next.  
Key steps: read next sales record, check end-of-file, apply filters (status, credit, invoice, average, overdue, enter-date).  
I/O: sales-file.  
Outcomes: either skip record or call listing.  
[Seen in: read-loop paragraph.]

Path: Test-Num  
Trigger: Called from read-loop when a numeric filter is present.  
Key steps: convert operator to upper-case, evaluate comparison, set truth flag.  
I/O: none.  
Outcomes: truth flag indicates whether record passes filter.  
[Seen in: test-num paragraph.]

Path: Listing  
Trigger: Called when record passes all filters.  
Key steps: format fields into line-5, write to print-file, manage page headings.  
I/O: print-file.  
Outcomes: record printed, line-cnt incremented, page heading may be written.  
[Seen in: listing paragraph.]

5.4 Termination  
After the report is produced, the program closes the print file, closes the sales file, and invokes the SYSTEM routine to print the report. [Seen in: menu-exit, produce-report section.]  
The program then exits via GOBACK. [Seen in: menu-exit.]

---
## sl200
*[212/267]*

### Business/Functional Perspective
### Invoice Deletion Report

**Program Purpose**  
The program produces a printable report of all invoices that have been marked for deletion. It reads a file containing the invoice numbers, their dates, and customer numbers, formats the data, and prints it with standard headers and pagination. If no deletion records exist, the report notes that there is “None to Report.” The report assists audit and compliance teams by providing a clear record of deleted invoices and helps maintain accurate financial reporting.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **No Data** – If no deletion records are found, the report includes a “None to Report” line.  
- **File Access** – If the deletion file cannot be opened or read, the program stops without generating a report.  
- **Date Conversion** – Dates that cannot be parsed are left blank; the report still lists the invoice and customer information.

**User Flow Summary**  
The user initiates the report (typically via a batch job or menu selection). The program opens the file that holds invoice deletion entries and reads each record in turn. For each record, it converts the stored date to the user‑friendly format, writes the invoice number, date, and customer number to the print spool, and tracks page and line counts to insert headings where needed. If the file contains no records, the program outputs a single line stating that there is “None to Report.” After all records are processed, the program finalizes the print spool, closes files, and terminates.

**Program Linkages**  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **start-program**, opening the print file, initializing the header, and opening the deletion‑invoice‑nos file. [Seen in: start-program.]  
It then enters a loop at **main-read**, reading each deletion‑invoice record, converting dates, and writing formatted lines to the print file, with page breaks inserted via **Headings-1** when the line count exceeds 70. [Seen in: main-read.]  
When the input file is exhausted or an error occurs, control passes to **End-Program**, which finalizes the report, closes files, and invokes the spooler before exiting. [Seen in: End-Program.]

5.2 Initialization  
The **start-program** paragraph opens the print file, clears the print record, performs **Headings-1** to print the first header, and opens the deletion‑invoice‑nos file; if the file open fails, it jumps to **End-Program**. [Seen in: start-program.]  
The **Headings-1** paragraph sets up the page header, increments the page counter, writes the header lines, and resets the line counter to 4. [Seen in: Headings-1.]

5.3 Core Processing  
Path: Main‑Read Loop  
Trigger: Successful open of deletion‑invoice‑nos file and no end‑of‑file condition.  
Key steps: Read next record (**DelInvNos-Read-Next**), exit loop on fs‑reply = 10, convert binary date (**zz060-Convert-Date**), move data to print record fields, write record, increment line counter, trigger **Headings-1** if line‑cnt > 70, repeat.  
I/O: del‑inv‑nos file, print‑file.  
Outcomes: Lines printed for each invoice, page breaks inserted, loop terminates on EOF or error.  
[Seen in: main-read, DelInvNos-Read-Next, zz060-Convert-Date, Headings-1.]

Path: Headings‑1  
Trigger: Called from **start-program** and whenever line‑cnt > 70 during the main loop.  
Key steps: Clear header, increment page counter, set page number, convert current date (**zz070-Convert-Date**), populate header fields, write header lines, reset line counter to 4.  
I/O: print‑file.  
Outcomes: New page header printed, line counter reset.  
[Seen in: Headings-1, zz070-Convert-Date.]

Path: End‑Program  
Trigger: fs‑reply = 10 (EOF) or file‑open error after **start-program**.  
Key steps: If no records printed, write “None to Report”; close print file and deletion‑invoice‑nos file; set spool name; call SYSTEM to spool; exit program.  
I/O: print‑file, del‑inv‑nos file.  
Outcomes: Report finalized, spooler invoked, program terminated.  
[Seen in: End-Program, DelInvNos-Close.]

Path: zz060-Convert-Date  
Trigger: Called from **main-read** to convert binary date to printable format.  
Key steps: Call **maps04** to populate date fields, handle invalid dates, set UK/USA/Intl format based on Date‑Form, swap month/day for USA, or rearrange for Intl.  
I/O: none (uses working‑storage).  
Outcomes: ws‑date populated for print record.  
[Seen in: zz060-Convert-Date, maps04.]

Path: zz070-Convert-Date  
Trigger: Called from **Headings‑1** to format the current date for the header.  
Key steps: Similar to zz060‑Convert‑Date but uses to‑day input; handles Date‑Form and format swaps.  
I/O: none.  
Outcomes: ws‑date populated for header.  
[Seen in: zz070-Convert-Date.]

5.4 Termination  
The **End-Program** paragraph writes a “None to Report” line if no data was printed, closes both the print and deletion‑invoice‑nos files, sets the spool name, calls the SYSTEM routine to spool the report, and then exits the program. [Seen in: End-Program.]  
The **main-term** paragraph simply exits the program, completing the termination sequence. [Seen in: main-term.]

---
## sl800
*[213/267]*

### Business/Functional Perspective
### Recurring Invoice Menu  

**Program Purpose**  
The program provides a simple menu for managing recurring invoices. Users can create or amend recurring invoice templates, review them before posting, or post all pending recurring invoices. By consolidating these actions into a single menu, the system reduces the need for multiple separate screens and helps ensure that recurring billing is handled consistently and efficiently.  

**Screen Interactions**  
1. **Title screen** – Displays the program name and a heading that reads “Recurring (Autogen) Sales Invoicing Menu.”  
2. **Date display** – Shows the current date in the system‑preferred format.  
3. **Options** –  
   - (1) Enter / Amend Recurring Invoice  
   - (2) Proof Recurring Invoicing  
   - (3) Post Recurring Invoices  
   - (X) Return To System menu  
4. **Prompt** – The user is asked to select one of the numbered options or press X to exit.  

**Messages and Errors**  
- If the user enters a choice that is not 1, 2, 3, or X, the menu is redisplayed for a new entry.  
- Selecting an option launches the corresponding invoicing sub‑process; upon completion the user is either returned to the menu or sent back to the main system menu, depending on the chosen action.  

**User Flow Summary**  
When a user starts the recurring invoice menu, they first see the current date and a list of four actions. After typing the number or X, the system determines which sub‑process to run:  

- Choosing **1** opens the screen for creating or updating a recurring invoice template and then returns directly to the main system menu.  
- Choosing **2** launches a proof view of upcoming recurring invoices, then brings the user back to the menu for another action.  
- Choosing **3** posts all pending recurring invoices, then returns to the menu for additional work.  
- Typing **X** exits immediately to the overarching system menu.  

Throughout this interaction, the program keeps the user focused on the high‑level task of managing recurring invoices, ensuring that all necessary steps are completed in a clear, sequential manner.  

**Program Linkages**  
- sl810  
- sl820  
- sl830

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by initializing environment and converting the current date before displaying the recurring invoicing menu. [Seen in: init01 section.]  
The user is prompted to select an option, which is read from the screen and stored in Menu-Reply. [Seen in: Menu-Input.]  
Based on the selection, the program either loads a subprogram (sl810, sl820, or sl830) or exits back to the system menu. [Seen in: Loadit.]

5.2 Initialization  
Environment variables for screen exceptions and escape key are set, and the date conversion routine is performed to format to‑day into ws‑date. [Seen in: init01 section.]  
Caller and called identifiers are swapped and the menu header is displayed with the formatted date. [Seen in: Menu-Return.]

5.3 Core Processing  
Path: Enter/Amend Recurring Invoice  
Trigger: Menu‑Reply = 1  
Key steps: move Menu‑Reply to pass‑value, set ws‑called to "sl810", call subprogram, after call if Menu‑Reply = 1 then exit.  
I/O: sl810 subprogram.  
Outcomes: program may exit or return to menu.  
[Seen in: Menu‑Input, Loadit.]

Path: Proof Recurring Invoicing  
Trigger: Menu‑Reply = 2  
Key steps: move Menu‑Reply to pass‑value, set ws‑called to "sl820", call subprogram, return to menu.  
I/O: sl820 subprogram.  
Outcomes: return to menu.  
[Seen in: Menu‑Input, Loadit.]

Path: Post Recurring Invoices  
Trigger: Menu‑Reply = 3  
Key steps: move Menu‑Reply to pass‑value, set ws‑called to "sl830", call subprogram, return to menu.  
I/O: sl830 subprogram.  
Outcomes: return to menu.  
[Seen in: Menu‑Input, Loadit.]

Path: Exit to System Menu  
Trigger: Menu‑Reply = X  
Key steps: go to Menu‑Exit, reset pass‑value, swap caller/called, exit program.  
I/O: none.  
Outcomes: program terminates.  
[Seen in: Menu‑Input, Menu‑Exit, menu‑ex.]

Path: Convert Date  
Trigger: init01 section calls zz070‑Convert‑Date.  
Key steps: move to‑day to ws‑date, adjust based on Date‑Form, swap month/day if USA, else set intl format.  
I/O: none.  
Outcomes: ws‑date formatted.  
[Seen in: init01 section, zz070‑Convert‑Date.]

5.4 Termination  
When the user selects exit, the program resets the caller/called linkage and performs an exit program statement to return control to the system. [Seen in: Menu‑Exit, menu‑ex.]  
No additional cleanup is performed beyond the exit program. [Seen in: menu‑ex.]

---
## sl810
*[214/267]*

### Business/Functional Perspective
### Recurring Invoice Creation

**Program Purpose**  
The program lets users create, edit, or delete automated invoices for customers. It validates customer details, collects line‑item information, calculates totals and VAT, and writes the invoice record to the system. The process helps maintain accurate billing, ensures compliance with pricing and tax rules, and reduces manual data‑entry errors.

**Screen Interactions**  
1. **Recurring Invoicing Data Entry** – The main screen displays prompts for:  
   * Mode selection (Entry = F2, Update = F3, Delete = F4)  
   * Customer account number (with optional “New Customer” function)  
   * Repeat count, frequency, invoice date, reference, and type (only invoice type allowed)  
   * Delivery address display (if available)  

2. **Invoice Line Entry** – Depending on the system setting (stock linked or not), the screen shows a list of lines for each item:  
   * Product code / description, quantity, unit price, discount, VAT code, net, VAT amount, and gross amount.  
   * Line numbers and totals are updated as the user enters data.  

3. **Totals Confirmation** – After all line items are entered, a summary screen shows:  
   * Net, VAT, gross totals, late charges, extra fees, carriage, and final amount.  
   * A prompt asking “Invoice ok to Store (Y/N) ?” and “ESC to Quit”.

**Messages and Errors**  
- If the user enters an invalid mode or option, a short error message appears and the prompt repeats.  
- When a customer account number is not found, the screen informs “No such Customer” and asks for a new entry.  
- If required data (e.g., product code, quantity) is missing or invalid, the program shows an appropriate warning and re‑prompts.  
- When the system cannot find a required file (e.g., analysis or stock file), a file‑missing message is displayed and the user is asked to press Return to continue.  
- If writing or updating an invoice record fails, the program shows an error message, the record number, and lets the user retry or exit.  
- Escape key always aborts the current operation and returns to the previous screen or exits the program.

**User Flow Summary**  
1. The user starts the program and sees the “Recurring Invoicing Data Entry” screen.  
2. The user selects the desired mode (Entry, Update, or Delete).  
3. The user enters a customer account number. If the account is new, the program offers to create it.  
4. The program displays the customer’s address (delivery or regular).  
5. For entry mode, the user provides repeat count, frequency, date, reference, and type (only invoice type).  
6. The program then presents the line‑item screen, allowing the user to enter each product, quantity, price, discount, and VAT.  
7. After all lines are entered, a totals screen shows the cumulative amounts and asks for confirmation.  
8. Upon confirmation, the program writes the invoice (or updates/deletes it).  
9. The user can then choose to create additional invoices or exit the program.

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- SLautogen-Open-Output  
- SLautogen-Close  
- SLautogen-Open  
- SLautogen-Write  
- SLautogen-Read-Next  
- SLautogen-Delete-All  
- SLautogen-Delete  
- sl070  
- sl960  
- maps04  
- Stock-Open-Output  
- Stock-Open  
- Stock-Read-Indexed  
- Stock-Read-Next  
- Stock-Start  
- Delivery-Open-Output  
- Delivery-Open  
- Delivery-Read-Indexed  
- Analysis-Open  
- Analysis-Read-Indexed  
- Sales-Open  
- Sales-Read-Indexed

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by initializing the environment, opening required files, and displaying the invoice entry screen. [Seen in: init01, Program-Start, Invoice-Details.]  
The user selects a mode (Entry, Update, Delete) and supplies customer and invoice details, after which the program gathers line items through either Level‑1 or Level‑2 data entry paths. [Seen in: Invoice-Details, Get-Data-1, Get-Data-2.]  
Upon completion of line entry, the program calculates totals, confirms storage, writes the autogen record and its lines, and then returns to the main menu or exits. [Seen in: End-Totals, Total-Screen, Menu-Exit.]

5.2 Initialization  
The init01 section reads terminal line count, sets screen exception flags, and initializes line counters. [Seen in: init01.]  
Program-Start performs file existence checks, opens sales, delivery, analysis, and autogen files, and sets the next invoice number if the autogen file is newly created. [Seen in: Program-Start.]  
The screen is cleared and the invoice details screen is displayed, awaiting user input. [Seen in: Invoice-Details.]

5.3 Core Processing  
Path: Invoice-Details (Entry/Update/Delete)  
Trigger: User presses F2, F3, or F4 to set mode or enters a customer number.  
Key steps: display mode options, accept customer, read customer and delivery data, handle new customer or delete/amend, read or write header.  
I/O: sales-file, delivery-file, analysis-file, SLautogen-file.  
Outcomes: sets Entry-Mode/Update-Mode/Delete-Mode, loads header record, sets Escape-Code, moves to Data-Input.  
[Seen in: Invoice-Details, Customer-Input, Check-For-Delete-Amend.]

Path: Get-Data-1 (Level 1 item entry)  
Trigger: After header entry, user enters line items in Level 1 format.  
Key steps: display line prompts, accept PA code, net amount, VAT code, compute VAT, update running totals, loop until screen full or exit.  
I/O: SLautogen-file (write lines).  
Outcomes: populates sil-… arrays, updates sih-Net, sih-vat, increments i and j.  
[Seen in: Get-Data-1, Get-Code, Get-Net, Get-Vat-Code, Get-Vat-Rate, Running-Totals.]

Path: Get-Data-2 (Level 2 item entry)  
Trigger: After header entry, user enters line items in Level 2 format (stock linked or not).  
Key steps: accept product code, search stock, accept quantity, unit price, discount, VAT, compute net, update totals, loop.  
I/O: Stock-file, SLautogen-file.  
Outcomes: populates sil-… arrays, updates totals, sets WS-Service-Only flag.  
[Seen in: Get-Data-2, Get-Product, Get-Qty, Get-Unit, Get-Disc, Get-Vat-Code, Get-Vat-Rate, Running-Totals.]

Path: End-Totals (confirmation and write)  
Trigger: After all line items entered, user confirms to store.  
Key steps: display totals, accept Y/N, set status, write header and lines to SLautogen-file, handle errors.  
I/O: SLautogen-file.  
Outcomes: records written, status set to "P" or "A", updates sih-lines, sets Escape-Code.  
[Seen in: End-Totals, Total-Screen, Write-Details, SLautogen-Write, SLautogen-Rewrite.]

Path: Delete-Current-Record  
Trigger: User selects Delete mode and confirms deletion.  
Key steps: display confirmation, delete header and all line records from SLautogen-file.  
I/O: SLautogen-file.  
Outcomes: records removed, Escape-Code set to "C".  
[Seen in: Delete-Current-Record, SLautogen-Delete, SLautogen-Delete-All.]

Path: New-Customer  
Trigger: User presses F1 during customer input.  
Key steps: close current files, call sl960 to create customer, reopen files, return to Invoice-Details.  
I/O: sl960 program, sales-file, delivery-file, analysis-file, SLautogen-file.  
Outcomes: new customer record created, program returns to invoice entry.  
[Seen in: New-Customer, sl960 call.]

5.4 Termination  
The Menu-Exit paragraph closes all open files (sales, delivery, analysis, SLautogen, stock) and performs a GOBACK to terminate the program. [Seen in: Menu-Exit.]  
Any pending status flags are cleared before exit. [Seen in: Menu-Exit.]

---
## sl820
*[215/267]*

### Business/Functional Perspective
### Autogen Report Generation

**Program Purpose**  
The program creates a “Sales Autogen” report that summarizes all autogen transactions for a given period. It reads invoice, receipt, credit‑note, and pro‑forma entries, looks up customer details, calculates line‑item totals, VAT reconciliation, and totals by type, and sends the formatted report to the print spool. The report provides an audit trail for management and supports compliance with accounting and tax regulations. The program does not alter any source data.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If no autogen transactions are found, the user sees “No Autogen Transactions to report!” and is prompted to press return.  
- If the sales ledger file cannot be opened, the user sees “Sales Ledger file not found” and is prompted to press return.  
- When a transaction references a customer that does not exist in the sales file, the line displays “!! Customer Unknown” and the record is flagged as missing.  
- If expected sales records are missing, a warning “Warning Record/s Missing In Sales File” is printed.  
- In all cases the program completes and returns to the calling context.

**User Flow Summary**  
The user starts the program from the accounting menu. The program reads each autogen transaction, retrieves the associated customer record, formats dates, calculates amounts and VAT, and writes each formatted line to a print record. After processing all records, the program prints totals by transaction type and a VAT reconciliation section. The completed report is sent to the print spool and the program returns to the main menu. If a required file is missing or a customer record cannot be found, an informative message is displayed before returning.

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- SLautogen-Open-Input  
- SLautogen-Read-Next  
- SLautogen-Close  
- Sales-Open-Input  
- Sales-Read-Indexed  
- Sales-Close  
- SYSTEM  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01** section, initializing spool name, totals, and converting the current date before displaying the menu header. [Seen in: init01.]  
It then opens the sales ledger and the autogen report files, and enters a loop that reads each autogen record, processes customer and line item details, and writes formatted output to the print file. [Seen in: Get-Invoice-Record.]  
After all records are processed, the program prints totals and VAT reconciliation, closes files, and invokes the system print routine before exiting. [Seen in: Main-End.]

5.2 Initialization  
init01 sets the print spool name, initializes the Total-Group array, and assigns the program version to the header line. [Seen in: init01.]  
It converts the current date to the configured format, sets the file key number, and displays the program name, title, and date on the screen. [Seen in: init01, Menu-Return.]

5.3 Core Processing  
Path: Main-Processing-Loop  
Trigger: SLautogen-Read-Next returns fs-reply not equal to 10 (i.e., a record is available). [Seen in: Get-Invoice-Record.]  
Key steps: Read invoice record, lookup customer in sales file, compute totals and VAT, write main line (Line-5), invoke Analysis-Print for line items, invoke Extra-Analysis for additional details, and loop back to Get-Invoice-Record. [Seen in: Get-Invoice-Record, Analysis-Print, Extra-Analysis.]  
I/O: SLautogen file (read), Sales file (indexed read), print-file (write). [Seen in: Get-Invoice-Record, Sales-Read-Indexed, write statements.]  
Outcomes: updates cumulative totals (Total-gds, Total-dis, etc.), increments line counter, and prepares data for next record. [Seen in: Get-Invoice-Record.]

Path: Analysis-Print  
Trigger: Called from Main-Processing-Loop for each line item of an invoice. [Seen in: Analysis-Print.]  
Key steps: Read next autogen record, skip comment lines, write line item details to Line-5B, update VAT totals in Total-cvat. [Seen in: Analysis-Print.]  
I/O: SLautogen file (read), print-file (write). [Seen in: Analysis-Print.]  
Outcomes: outputs detailed line items and accumulates VAT per rate. [Seen in: Analysis-Print.]

Path: Extra-Analysis  
Trigger: Called after Analysis-Print to output any pending extra line details (lb, lc, ld, le). [Seen in: Extra-Analysis.]  
Key steps: For each non-empty lb, lc, ld, le record, write the corresponding line (Line-b, Line-c, Line-d, Line-e) and reset the field. [Seen in: Extra-Analysis.]  
I/O: print-file (write). [Seen in: Extra-Analysis.]  
Outcomes: ensures all supplemental line items are printed. [Seen in: Extra-Analysis.]

Path: Main-End  
Trigger: Loop terminates when fs-reply = 10 (no more records). [Seen in: Main-End.]  
Key steps: Close sales and autogen files, print totals per type, VAT reconciliation, close print file, and call SYSTEM to print. [Seen in: Main-End.]  
I/O: Sales file (close), SLautogen file (close), print-file (write and close). [Seen in: Main-End.]  
Outcomes: final report is printed and program exits. [Seen in: Main-End.]

Path: Headings-1 / Main12  
Trigger: When line counter exceeds page limit (Page-Lines - 2 or -4). [Seen in: Headings-1, Main12.]  
Key steps: Write header lines (Line-1, Line-2, Line-4, Line-4B), reset line counter, and increment page number. [Seen in: Headings-1, Main12.]  
I/O: print-file (write). [Seen in: Headings-1, Main12.]  
Outcomes: new page header is printed and line counter reset. [Seen in: Headings-1, Main12.]

5.4 Termination  
The program closes the sales and autogen input files, writes any remaining totals and VAT reconciliation, closes the print file, and invokes the system print routine before returning control. [Seen in: Main-End.]  
It then exits via GOBACK or Menu-Call, leaving the spool ready for printing. [Seen in: Menu-Call.]

---
## sl830
*[216/267]*

### Business/Functional Perspective
### Autogen Invoice Generation  

**Program Purpose**  
This program automatically processes scheduled (autogen) records, generates invoice entries, updates related analysis and stock audit information, and prepares the next billing cycle. By ensuring that autogen invoices are created and scheduled correctly, it helps maintain accurate financial records, supports compliance, and reduces the risk of missed or duplicate invoices. The job runs unattended, providing a status screen and error reporting to keep users informed of any problems.  

**Screen Interactions**  
1. **Status Screen** – When started, the program displays:  
   - Program name and version (`SL830 (3.02.00)`) at the top.  
   - Title “Autogen Posting”.  
   - Current run date in the user’s locale format.  
   - A “Running…” message while the job processes records.  
   No user input is required; the screen is purely informational.  

**Messages and Errors**  
- **Rewrite Failure** – “Failure to Rewrite Autogen record” indicates the autogen record could not be updated after processing.  
- **Delete Failure** – “Failure to Delete Autogen record” occurs when a processed autogen record cannot be removed.  
- **Invoice Write Failure** – “Failure to Write Invoice record” appears when a single invoice cannot be stored.  
- **General Write Failure** – “There has been failures writing Invoices” is shown if any invoice write error occurs during the job.  
- When an invoice write error occurs, the invoice key is displayed so the user can identify the problematic record.  

**User Flow Summary**  
The user initiates the background job, which opens all required files (autogen, invoice, analysis, stock audit, and stock). The program scans autogen records that are due within a configurable date range, builds one invoice header and multiple line‑item invoices from each record, and writes them to the invoice file. For each line item it updates analysis and, if stock linkage is enabled, updates stock audit and stock quantity/value records. After all line items are written, the program calculates the next due date for the autogen record, rewrites the autogen header with this new date, and deletes the record if it has reached its final recurrence. Once processing is complete, all files are closed and the status screen is cleared. Any errors encountered during rewriting, deleting, or writing are reported to the user on the same screen.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- sl070  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa000-Main, checks the SL‑Autogen flag and exits if not active. [Seen in: aa000-Main.]  
It then sets screen exception handling, converts the current date, displays status information, and opens all required files before entering the main processing loop. [Seen in: aa000-Main.]  
After processing all Autogen records, any invoice‑write errors are reported, the files are closed, and the program terminates. [Seen in: aa000-Main.]

5.2 Initialization  
The entry point aa000-Main verifies that SL‑Autogen is “Y”; otherwise it performs a GOBACK. [Seen in: aa000-Main.]  
Screen exception flags are enabled, the current date is converted to local display format, and the program displays its name, a title, the run date, and a “Running…” message before opening files. [Seen in: aa000-Main.]

5.3 Core Processing  
Path: Process-Autogen  
Trigger: Entry to ba000-Process-Autogen after files are opened.  
Key steps: Accepts the current date, calculates binary minimum and maximum dates, then loops reading Autogen records with SLautogen‑Read‑Next, generating invoices when a header and its lines are accumulated, and checking for write errors.  
I/O: SLautogen (input), Invoice (output), Stock‑Audit (output), Analysis (output).  
Outcomes: Invoice records are written, Autogen dates are updated, and any write errors set WS‑Invoice‑Errors.  
[Seen in: ba000-Process-Autogen.]

Path: Generate-Invoice  
Trigger: Called from ba010‑Read‑Autogen when a complete header and its lines are ready.  
Key steps: Deletes recurring records if repeat count is zero, writes a header and each line to the Invoice file, updates analysis via zz045‑Update‑Analysis, calculates the next Autogen date, rewrites the Autogen header, and handles errors.  
I/O: SLautogen (rewrite), Invoice (write), Stock‑Audit (write), Analysis (write).  
Outcomes: New invoice records created, Autogen header updated, and any errors flagged in WS‑Invoice‑Write‑Error‑Flag.  
[Seen in: zz040-Generate-Invoice.]

Path: Update-Analysis  
Trigger: Invoked from zz040‑Generate‑Invoice for each line item.  
Key steps: If stock linkage is active and the item type is an invoice, it builds a Stock‑Audit record, reads the corresponding Stock record, updates quantity and value, rewrites the Stock record, and writes the Stock‑Audit record if enabled.  
I/O: Stock‑Audit (write), Stock (read/write).  
Outcomes: Stock quantities and values are adjusted, audit history is recorded, and the Stock‑Audit flag is set if required.  
[Seen in: zz045-Update-Analysis.]

Path: Get-A-Deleted-Invoice  
Trigger: Called from zz040‑Generate‑Invoice to obtain an available invoice number.  
Key steps: If a deleted invoice number exists in Del‑Inv‑Nos, it is retrieved and deleted; otherwise the next invoice number is used.  
I/O: Del‑Inv‑Nos (read/delete).  
Outcomes: WS‑Active‑Invoice‑No is set for use in the new invoice record.  
[Seen in: zz030-get-a-deleted-invoice.]

Path: Open-Files  
Trigger: Executed from aa000‑Main before processing.  
Key steps: Checks for existence of each required file, creates missing ones, and opens all files for input or output as appropriate.  
I/O: SLautogen, Analysis, Invoice, Stock‑Audit, Value, Del‑Inv‑Nos.  
Outcomes: All necessary files are open and ready for processing; missing files are created.  
[Seen in: zz010-Open-Files.]

Path: Close-All-Files  
Trigger: Executed after processing completes in aa000‑Main.  
Key steps: Closes all files opened during the run.  
I/O: SLautogen, Invoice, Stock‑Audit, Analysis, Value, Del‑Inv‑Nos.  
Outcomes: All files are properly closed before program exit.  
[Seen in: zz020-Close-All-Files.]

5.4 Termination  
The program performs a final file close via zz020‑Close‑All‑Files and then executes GOBACK to terminate. [Seen in: aa000-Main.]  
Any invoice‑write errors are displayed before exit, ensuring that the caller is aware of failures. [Seen in: aa000-Main.]

---
## sl900
*[217/267]*

### Business/Functional Perspective
### Invoice Management Menu  

**Program Purpose**  
The program presents users with a centralized menu for all invoicing functions, from entering new invoices to printing reports and documents. It lets users view or change fixed invoicing settings, launch specific invoice‑related tasks, and ensure that key parameters such as dates, account codes and stock links are entered consistently. By guiding users through validated screens, the system reduces errors, supports audit requirements and speeds up day‑to‑day invoicing operations.  

**Screen Interactions**  
1. **Invoicing Menu Screen** –  
   *Title and header*: Program name, “Invoicing Menu” and the current date.  
   *Prompts*: “Select one of the following by number – [ ]” followed by a numbered list of options (1 to 9, A, X).  
   *Inputs*: The user types a single character (number or letter) and presses ENTER.  
   *Outputs*: The chosen option is stored and used to decide the next step.  

2. **Invoicing Fixed Data Screen** –  
   *Title and header*: Program name, “Invoicing Fixed Data” and the current date.  
   *Prompts and fields* (each with a labelled box for input):  
   - Next Invoice number  
   - Extra Charge/Discount Description  
   - Extra Charge/Discount Type (C/D)  
   - Print Extra on Invoices (N/Y)  
   - Extra Charge/Discount Percentage  
   - Invoice Entry Level (1, 2)  
   - Invoice to Stock Link (N/Y)  
   - Invoice to Stock Audit (N/Y)  
   - Vat Account (if GL or IRS is active)  
   - Proforma Retention In Days  
   - Confirmation of details (“Details Ok To File (Y/N)”).  
   *Inputs*: Users type or edit each field; the screen updates the corresponding values.  
   *Outputs*: After confirmation, the fixed data values are written to the system.  

**Messages and Errors**  
- **Invalid menu selection** – If the user chooses an option that is not available (e.g., “3” or “7” when invoicing is not active), a brief notice appears and the user is prompted to try again.  
- **Incorrect data entry** – If a field receives a value outside the allowed set (e.g., a type other than C or D, or a Y/N field with any other letter), the screen re‑prompts the user until a valid entry is entered.  
- **Confirmation required** – After all fields are entered, the screen asks “Details Ok To File (Y/N)”. Choosing “N” returns the user to the data entry screen; choosing “Y” commits the data.  

**User Flow Summary**  
A user starts the program and immediately sees the Invoicing Menu. The menu shows the current date and a list of numbered and lettered options. By typing the desired code, the user either:

- Enters “1” to view or edit the fixed invoicing parameters on the Fixed‑Data screen, where they can set the next invoice number, discount/charge details, stock linkage, VAT account, and retention days. Once the user confirms, the new settings are stored.  
- Chooses “2” or “3” to launch the main invoice entry routine (sl910) for single or batch invoice creation.  
- Uses “4” to amend existing invoices (sl920), “5” to delete invoices (sl940), or “6” to produce an invoice deletion report (sl200).  
- Selects “7” or “8” to print delivery notes/picking lists (sl950) or printed invoices (sl930).  
- Selects “9” for recurring invoice processing (sl800) or “A” for BO reporting and amendments (sl970).  
After completing the chosen task, control returns to the menu for further action or the user can press “X” to exit back to the system menu.  

**Program Linkages**  
- sl920  
- sl940  
- sl200  
- sl950  
- sl930  
- sl910  
- sl800  
- sl970

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in **init01**, setting screen exception flags, converting the current date, and displaying the main invoicing menu. [Seen in: init01.]  
User input is accepted in **menu-input**; the reply determines which subroutine (e.g., Fixed‑Data, sl910, sl920, etc.) is called via **loadit**. [Seen in: menu-input.]  
After the called module completes, control returns to **menu-return** to redisplay the menu and await another selection until the user chooses X to exit. [Seen in: menu-return.]

5.2 Initialization  
**init01** sets environment variables for screen exceptions and escape key detection, then performs date conversion and initializes caller/del‑link fields. [Seen in: init01.]  
If the next‑invoice value is zero, **init01** performs **fixed-data** to load defaults before displaying the menu. [Seen in: init01.]

5.3 Core Processing  
Path: Menu Dispatch  
Trigger: User menu reply in **menu-input**.  
Key steps: accept reply, evaluate reply, set **ws-called** and **pass-value**, call **loadit**, then return to **menu-return**.  
I/O: display/accept screen fields, call to external modules (sl200, sl910, sl920, sl940, sl950, sl800, sl970).  
Outcomes: determines which module is invoked and updates caller/del‑link for return.  
[Seen in: menu-input, loadit.]

Path: Fixed‑Data Entry  
Trigger: Menu reply 1 or direct call to **Fixed‑Data**.  
Key steps: display fixed‑data screen, accept entries for next‑invoice, extra charge/discount details, invoicer, stock link/audit, VAT account, retention, and confirmation.  
I/O: display/accept screen fields.  
Outcomes: updates global variables (next‑invoice, Extra‑Desc, Extra‑Type, Extra‑Print, Extra‑Rate, Invoicer, SL‑Stock‑Link, SL‑Stock‑Audit, VAT‑AC, pf‑retention).  
[Seen in: Fixed‑Data, Data-Entry.]

Path: Loadit Call  
Trigger: **menu-input** sets **ws-called** and **pass-value**.  
Key steps: call the module specified in **ws-called** with parameters, then return to **menu-return**.  
I/O: call to external modules.  
Outcomes: module may modify data; control returns to menu.  
[Seen in: loadit.]

Path: Confirmation  
Trigger: After data entry in **Data-Entry**.  
Key steps: accept confirmation reply, loop back to data‑entry if reply is not Y, otherwise exit main‑exit.  
I/O: accept reply.  
Outcomes: sets **ws-reply** and determines whether to repeat entry or proceed.  
[Seen in: Confirmation.]

Path: Exit  
Trigger: Menu reply X in **menu-input**.  
Key steps: set **pass-value** to zero, restore **ws-caller** and **ws-del-link**, then exit program via **menu-ex**.  
I/O: exit.  
Outcomes: program terminates.  
[Seen in: menu-exit, menu-ex.]

5.4 Termination  
The program exits via **menu-ex**, which performs a GOBACK after resetting **pass-value** and restoring caller/del‑link. [Seen in: menu-ex.]  
No explicit file or database close statements are present in this file; cleanup is delegated to the modules invoked through **loadit**. [Seen in: menu-ex.]

---
## sl910
*[218/267]*

### Business/Functional Perspective
### Invoice Data Entry

---

#### Program Purpose  
SL910 is the interactive entry and maintenance module for customer invoices. It validates customer and invoice details, gathers item‑level information, updates stock and audit records, and either stores the invoice or sends it immediately to the print routine. The program ensures data integrity, keeps inventory levels consistent, and records back‑order information when needed, thereby supporting accurate financial reporting and inventory control.

---

#### Screen Interactions  

| Screen | Title / Prompt | Inputs | Outputs / Display | Options |
|--------|----------------|--------|--------------------|---------|
| 1 | **Invoicing Data Entry** | *Date* (UK format), *A/C Nos* (customer number), *Reference*, *Invoice*, *Order*, *Type* (1‑Receipt, 2‑Account, 3‑Credit Note, 4‑Pro‑Forma) | Field values, current date, “F1 = Setup new Customer”, “F8 = Only Show delivery details” | F1 – New customer; F8 – Show delivery address |
| 2 | **Invoice Line Entry** (item rows) | *Product code* (or abbreviated key), *Description*, *Quantity*, *Unit price*, *Discount*, *VAT code* (S/R/Z), *Net* amount | Calculated net, VAT, gross, running totals, stock held display | F2/F3 – Next/previous stock record, F5 – Search by description, F6 – Skip current order |
| 3 | **Totals / Confirmation** | – | Net total, VAT, gross total, days, extra charges, carriage, deductions, final total | “Enter Y/N to Store / Print” |
| 4 | **Credit Note Entry** | *Invoice to Credit* | Validation of posted invoice, display of outstanding balance, late‑charge handling | – |
| 5 | **Back‑Order Processing** | – | Prompt: “Process Back Orders?”; list of items that can be invoiced; prompt to force date‑ordered processing | Y/N to continue, Y/N to view list, Y/N to force date‑ordered mode |

---

#### Messages and Errors  
| Category | Typical User Impact |
|----------|---------------------|
| **Invalid input** | Prompts to re‑enter missing or incorrectly formatted fields (e.g., wrong customer number, invalid date). |
| **Missing data** | Alerts when a required record is not found (e.g., customer, stock, or invoice). |
| **Operation success/failure** | Confirmation that the invoice was written, or error messages such as “Error on writing audit record”, “Error on stock record rewrite”, or “Error on invoice record write”. |
| **Back‑order handling** | Messages indicating that back‑order records were created, skipped, or deleted, and warnings when the BO table is full or stock‑held is insufficient. |
| **Credit‑note checks** | Alerts if the invoice to credit does not exist, is paid, or belongs to a different customer. |

---

#### User Flow Summary  
1. **Start** – The user launches SL910. The program displays the Invoicing Data Entry screen with the current date.  
2. **Customer / Invoice Identification** – The user enters the customer number, reference, invoice number, order number, and type. Pressing **F1** can start a new customer entry. The program validates the customer and pre‑populates address and reference fields.  
3. **Line‑Item Entry** – For each invoice line, the user enters the product code (or navigates through stock records), description, quantity, unit price, discount, and VAT code. The program calculates net, VAT, and gross amounts and updates running totals on the screen. If stock is linked, quantity is checked against stock held and back‑orders are flagged.  
4. **Review Totals** – After all lines are entered, the program shows a totals screen where the user can view net, VAT, gross, days, extra charges, carriage, and deductions.  
5. **Confirm and Store/Print** – The user chooses to store the invoice or to print immediately. If printing, the program calls the print routine.  
6. **Stock / Audit Updates** – On successful write, the program updates stock held and value, records an audit entry, and removes any processed back‑order records.  
7. **Completion** – The program closes all files and exits, returning control to the calling batch or terminal.

---

#### Program Linkages  
- `sl070`  
- `sl930`  
- `sl960`  
- `CBL_CHECK_FILE_EXIST`  
- `CBL_DELETE_FILE`  
- `maps04`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by initializing environment, screen and variables in **Init01 section.**, then opens required files and checks for analysis defaults in **Program-Start section.** [Seen in: Init01 section., Program-Start section.]  
If back‑order data is present, **zz200‑Build‑From‑BO** is automatically performed to prepare BO tables before normal invoice entry. [Seen in: zz200-Build-From-BO section.]  
The main user interaction occurs in **Main**, which calls **Invoice-Details** to capture header information, then loops through **Data-Input** and **Get-Data-2** to accept line items. [Seen in: Main., Invoice-Details section., Data-Input., Get-Data-2 section.]  
After all lines are entered, **End-Totals** calculates totals and **Total-Screen** displays them, prompting the user to confirm printing or storing the invoice. [Seen in: End-Totals section., Total-Screen section.]  
Depending on the choice, the program writes the invoice header and details, updates stock and audit records, and either prints the invoice via sl930 or exits. [Seen in: Write-Details section., Update-Stock-n-Audit section., ET-Print section.]

5.2 Initialization  
**Init01** sets screen exception flags, converts the current date, and initializes line counters and file keys. [Seen in: Init01 section.]  
**Program-Start** opens Sales, Delivery, Analysis, Stock, Stock‑Audit, Invoice, ITM3, and DelInvNos files, creating them if missing, and loads analysis defaults if required. [Seen in: Program-Start section.]  
If BO processing is enabled, BO‑Stk‑Itm‑File is opened in I‑O mode and any missing BO records are prepared. [Seen in: Program-Start section.]  
The program also initializes the invoice header and body tables to zero before entering the main loop. [Seen in: Init01 section.]

5.3 Core Processing  

Path: **Back‑Order Processing (zz200‑Build‑From‑BO)**  
Trigger: **WS‑BO‑Used** flag set to “Y” and BO‑Stk‑Itm‑File contains records with Arrived‑Flag = “Y”. [Seen in: zz200-Build-From-BO section.]  
Key steps: Load all arriving BO records into BO‑Table, sort by item and customer, build Item‑Table of total ordered quantities, determine if processing should be by date or customer/item, prompt the user to confirm processing, then for each BO record create an invoice header, generate a new invoice number, accept line items (using BO price or stock price), write invoice lines, delete the BO record, and update stock and audit. [Seen in: zz200-Build-From-BO section., zz210-Delete-BO-Records section., Write-Details section., Update-Stock-n-Audit section.]  
I/O: BO‑Stk‑Itm‑File, Stock‑File, Invoice‑File, ITM3, Stock‑Audit‑File. [Seen in: zz200-Build-From-BO section., zz210-Delete-BO-Records section.]  
Outcomes: New invoices are created for back‑orders, BO records are removed, stock quantities are adjusted, audit entries are written, and the program returns to the main invoice entry loop. [Seen in: zz200-Build-From-BO section., zz210-Delete-BO-Records section.]

Path: **Invoice Entry (Main → Invoice-Details → Get-inv → Data-Input)**  
Trigger: User selects a customer and enters an invoice number (or a new one is generated). [Seen in: Main., Invoice-Details section., Get-inv.]  
Key steps: Validate customer, read or generate invoice number, display header, accept reference and order numbers, accept invoice type, then loop through Data-Input to accept each line item via Get-Data-2, calculate running totals, and after all items are entered, prompt for confirmation. [Seen in: Invoice-Details section., Get-inv., Data-Input., Get-Data-2 section.]  
I/O: Sales‑File, Invoice‑File, ITM3, Stock‑File, Stock‑Audit‑File. [Seen in: Invoice-Details section., Get-inv., Get-Data-2 section.]  
Outcomes: Invoice header and body records are written to the Invoice file, stock is updated, audit records are created, and the invoice is either stored or printed. [Seen in: Write-Details section., Update-Stock-n-Audit section.]

Path: **Totals and Confirmation (End-Totals → Total-Screen)**  
Trigger: User finishes entering all line items or chooses not to add more invoices. [Seen in: End-Totals section., Total-Screen section.]  
Key steps: Sum net, VAT, and other totals, display them on the screen, ask the user to confirm printing or storing, and if confirmed, write the invoice header and details, then close files and optionally call sl930 for printing. [Seen in: End-Totals section., Total-Screen section., Write-Details section., ET-Print section.]  
I/O: Invoice‑File, ITM3, Stock‑File, Stock‑Audit‑File, Delivery‑File, Analysis‑File. [Seen in: End-Totals section., Total-Screen section., Write-Details section.]  
Outcomes: Final invoice record is persisted, stock and audit are updated, and the program exits or prints the invoice. [Seen in: End-Totals section., Total-Screen section.]

Path: **System Setup (Program-Start)**  
Trigger: Program start. [Seen in: Program-Start section.]  
Key steps: Open all required files, check for existence of analysis file and create defaults if missing, set up screen parameters, and prepare BO processing if enabled. [Seen in: Program-Start section.]  
I/O: Analysis‑File, Stock‑File, Stock‑Audit‑File, Invoice‑File, ITM3, DelInvNos‑File, BO‑Stk‑Itm‑File. [Seen in: Program-Start section.]  
Outcomes: All files are ready for processing, defaults are loaded, and the program is ready to accept user input. [Seen in: Program-Start section.]

Path: **BO Record Deletion (zz210‑Delete‑BO‑Records)**  
Trigger: After an invoice has been written for a BO record. [Seen in: zz210-Delete-BO-Records section.]  
Key steps: Loop through BO‑Invoiced‑Table and delete each corresponding BO‑Stk‑Itm‑File record, handling errors. [Seen in: zz210-Delete-BO-Records section.]  
I/O: BO‑Stk‑Itm‑File. [Seen in: zz210-Delete-BO-Records section.]  
Outcomes: BO records are removed from the file, freeing space for future BO entries. [Seen in: zz210-Delete-BO-Records section.]

5.4 Termination  
When the user chooses to exit or after printing, **Menu-Exit** performs **zz080-Close-All-Files** to close all open files and then exits the program. [Seen in: Menu-Exit., zz080-Close-All-Files section.]  
The program ends with a GOBACK/STOP RUN, leaving all resources released. [Seen in: Menu-Exit., zz080-Close-All-Files section.]

---
## sl920
*[219/267]*

### Business/Functional Perspective
### Invoice Amendments

**Program Purpose**  
The program lets users amend invoices, receipts, credit notes and pro‑forma entries. It validates the entered record, updates totals, performs any required stock and audit adjustments, and stores the revised data. The process protects business integrity by ensuring only authorised changes are applied, preventing over‑crediting or incorrect stock levels, and keeping the audit trail accurate.

**Screen Interactions**  
1. **Invoice Entry Screen** –  
   *Title*: “Invoicing Data Amend”  
   *Inputs*: Invoice number, date, customer account, reference, order number, type (1‑Receipt, 2‑Account, 3‑Credit Note, 4‑Pro‑Forma).  
   *Options*: Press ESC to abort, F8 to request delivery details for the customer.

2. **Credit Note Screen** –  
   *Title*: “Invoice To Credit”  
   *Inputs*: Invoice number to credit.  
   *Outputs*: Shows the amount outstanding, late charges, and credit status.  
   *Options*: ESC to abort.

3. **Invoice Details Screen – Level 1 (no stock link)** –  
   *Title*: “Level 1”  
   *Displays*: Line‑item fields – Net amount, VAT, Vat amount, Gross amount.  
   *Inputs*: For each line, net amount, VAT rate, VAT amount, gross amount.  
   *Options*: ESC to abort, move between lines with arrow keys.

4. **Invoice Details Screen – Level 2 (stock linked)** –  
   *Title*: “Stock Linked”  
   *Displays*: Product code, description, quantity, unit price, discount, VAT.  
   *Inputs*: Product code (searchable), quantity, unit price, discount, VAT rate.  
   *Options*: ESC to abort, F3/F2 to browse stock, F6/F5 to browse by description.

5. **Totals & Confirmation Screen** –  
   *Title*: “Total‑Screen” (displayed after line entry)  
   *Displays*: Sub‑totals, VAT totals, late charges, deductions, overall totals.  
   *Outputs*: Prompt “Invoice Ok To Store? (Y/N)”.  
   *Options*: Y to save, N to cancel.

6. **Amend Further Prompt** –  
   *Displays*: “Amend Further Invoices? (Y/N) [Y]”.  
   *Options*: Y to repeat entry, N to exit.

**Messages and Errors**  
- **Validation** – If a mandatory field (invoice number, date, customer, type) is missing, the user is prompted to correct it.  
- **Record not found** – If the entered invoice number, customer, or product does not exist, an explanatory message is shown.  
- **Credit restrictions** – When an account invoice is entered, the program warns if the customer balance is overdue, exceeds the credit limit, or the account is inactive.  
- **Stock errors** – If a product code cannot be located or the requested quantity exceeds on‑hand stock (when stock is linked), the user receives an error and must adjust the entry.  
- **Audit / Stock write‑fail** – Should a stock or audit record fail to write, the program displays an “error on write” message and aborts the current amend.  
- **System messages** – “Hit Return To Continue” and “Note Details & Hit Return to continue” are shown for informational purposes and require user acknowledgement.  

**User Flow Summary**  
The user starts the program and enters an invoice number. After the record is located, the user supplies the date, customer, reference, order number, and selects the record type. If the type is an account invoice, the system displays any credit‑limit or balance warnings. The program then moves to the line‑item screen, where the user enters each line’s product details, amounts, discounts and VAT. For stock‑linked invoices, product lookup and quantity checks are performed automatically. When all lines are entered, the program calculates totals, displays a summary screen, and asks the user to confirm storage. If confirmed, the amended invoice is written to the database, any related stock and audit records are updated, and the program returns to the prompt for further amendments or exits.

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- sl070  
- Invoice-Open-Output  
- Invoice-Close  
- OTM3-Open-Output  
- OTM3-Close  
- Stock-Open-Output  
- Stock-Close  
- Stock-Open  
- Stock-Audit-Open-Output  
- Stock-Audit-Open-Extend  
- Invoice-Open  
- OTM3-Open-Input  
- Sales-Open-Input  
- Delivery-Open-Input  
- Analysis-Open-Input  
- maps04  
- auditMT  
- stockMT  
- salesMT  
- deliveryMT  
- analMT  
- invoiceMT  
- otm3MT

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **init01 section**, performing environment setup, screen configuration, and file existence checks before opening all required files. [Seen in: init01 section.]  
After initialization, the **main** paragraph repeatedly invokes **invoice-details** to gather invoice header information, then proceeds to the line‑editing phase (**inv-level-1** or **inv-level-2**) based on the invoice type. [Seen in: main.]  
Once line editing is complete, **End-Totals** displays the totals, confirms storage, writes the updated invoice and line records, and updates stock and audit tables before looping back to allow amendment of additional invoices or exiting via **menu-exit**. [Seen in: End-Totals.]

5.2 Initialization  
The **init01 section** accepts screen line count, configures screen exception handling, converts the current date, sets the file key number, and calls **Program-Start** to verify and create necessary files. [Seen in: init01 section.]  
**Program-Start** checks for the existence of analysis, invoice, ITM3, sales, delivery, and (if linked) stock and stock‑audit files, opening them as needed and initializing the program name and date display. [Seen in: Program-Start.]

5.3 Core Processing  

Path: Invoice Entry  
Trigger: User enters an invoice number in **invoice-enter**.  
Key steps: Read the invoice record, load header into **SInvoice-Header**, read line items into **Invoice-Lines**, and display the invoice header fields.  
I/O: Invoice file (read indexed), Invoice-Record.  
Outcomes: Sets up the invoice data structures for editing.  
[Seen in: invoice-enter.]

Path: Customer Input  
Trigger: User enters a customer number in **customer-Input**.  
Key steps: Read the sales record, optionally read the delivery record if F8 is pressed, and display the customer address.  
I/O: Sales file, Delivery file.  
Outcomes: Populates customer and address fields for the invoice header.  
[Seen in: customer-Input.]

Path: Line Item Editing (Stock Linked)  
Trigger: User edits line items in **inv-level-2** when stock linkage is enabled.  
Key steps: Display outline, accept product code, retrieve stock record, accept quantity, unit price, discount, VAT, and compute totals; update **CIT-A** and **CIT-D** tables for audit.  
I/O: Stock file (read indexed), Invoice file (rewrite/write), Stock‑Audit file (write).  
Outcomes: Modifies line items, updates stock quantities, and records audit changes.  
[Seen in: inv-level-2.]

Path: Credit Note Processing  
Trigger: User selects to credit an invoice in **cr-note**.  
Key steps: Read the OTM3 record, validate that it is a posted invoice, compute amounts owed, and display the outstanding balance.  
I/O: OTM3 file (read indexed).  
Outcomes: Prepares credit note data and displays the amount to be credited.  
[Seen in: cr-note.]

Path: End Totals and Confirmation  
Trigger: User confirms storage after editing in **End-Totals**.  
Key steps: Display totals, prompt for confirmation, rewrite the invoice header, write all line details, invoke **Update-Stock-And-Audit**, and set status flags.  
I/O: Invoice file (rewrite/write), Stock file (rewrite), Stock‑Audit file (write).  
Outcomes: Persists the amended invoice and updates stock and audit records.  
[Seen in: End-Totals.]

Path: Program Exit  
Trigger: User chooses to exit via **menu-exit**.  
Key steps: Close all open files (sales, delivery, analysis, invoice, OTM3, stock, stock‑audit) and perform a GOBACK.  
I/O: All open files.  
Outcomes: Cleans up resources and terminates the program.  
[Seen in: menu-exit.]

5.4 Termination  
Upon exit, **menu-exit** performs a series of close operations for all files, including sales, delivery, analysis, invoice, OTM3, and, if linked, stock and stock‑audit, then exits the program. [Seen in: menu-exit.]  
The program sets the final status flag to indicate successful completion before performing the GOBACK. [Seen in: menu-exit.]

---
## sl930
*[220/267]*

### Business/Functional Perspective
### Invoice Print & Email  

**Program Purpose**  
This program generates and delivers customer invoices. It prints invoices to a printer or spool file, and can also send each invoice as an email attachment. It ensures that invoices are only printed once unless a re‑print is requested, updates the invoice status to indicate printing, and supports batch or single‑invoice printing. By providing the invoice in both printed and electronic form it improves record‑keeping, compliance, and customer service while reducing manual effort.  

**Screen Interactions**  

1. **Initial Prompt** – Displays the program title, current date, and a warning if output is directed to a file.  
   - **Input:** User selects “Print” (P) or “Re‑Print” (R).  
   - **Options:** Default is P.  

2. **Re‑Print Confirmation** – When “Re‑Print” is chosen, the program shows the invoice number and asks whether to re‑print it.  
   - **Input:** Y or N (default Y).  

3. **Amended Invoices Inquiry** – After printing a batch, the program asks whether any amended invoices exist.  
   - **Input:** Y or N (default N).  

4. **Invoice Range Selection** – If a new batch is to be printed, the user enters the lowest invoice number to start from.  
   - **Input:** Numeric invoice number.  

5. **Continuation Prompt** – After each invoice, the program asks whether more invoices should be printed.  
   - **Input:** Y or N (default Y).  

**Messages and Errors**  
- The program notifies the user if an email file cannot be created and stops the operation.  
- If the user chooses to abort a re‑print, the program exits after displaying a simple abort message.  
- When an invoice has already been printed, the user is prompted to confirm a re‑print; choosing “No” skips that invoice.  
- If an email is to be sent but the system reports a failure, a concise error message is shown.  

**User Flow Summary**  
1. The user starts the program from a menu or command line.  
2. The screen displays the program name, current date, and any spool‑file warnings.  
3. The user selects whether to print new invoices or re‑print existing ones.  
4. For each invoice, the program reads the record, prints the invoice (or opens it for printing), updates the printed status, and optionally creates an email attachment.  
5. If printing is to a file, the file is spooled; if printing to a printer, the invoice is sent directly to the printer.  
6. After each invoice the user is asked whether more invoices remain to be processed.  
7. When all selected invoices are processed, the program closes all files, sends any queued emails, and exits.  

**Program Linkages**  
- SYSTEM  
- C$SLEEP  
- CBL_DELETE_FILE  
- maps04  
- C$JUSTIFY

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts with init01 performing environment setup and checks for invoicing enabled. [Seen in: init01.]  
It displays a menu and opens invoice, sales, delivery, and print files before determining whether to print a single invoice or enter batch mode. [Seen in: menu-return.]  
In batch mode, invoices are processed sequentially, each printed via Print‑Routine, with optional email generation. [Seen in: all-print-start, Print‑Routine.]  
After all invoices are processed, the program closes files, optionally sends emails, and exits. [Seen in: main-end.]

5.2 Initialization  
init01 checks the full‑invoicing flag and sets screen exception environment variables. [Seen in: init01.]  
It initializes date conversion, company details, and opens the print spool file, preparing for subsequent processing. [Seen in: init01, zz070‑Convert‑Date, zz080‑Setup‑Company‑Details.]

5.3 Core Processing  

Path: Batch Print  
Trigger: User selects 'P' at the print path prompt in all‑print‑start. [Seen in: all-print-start.]  
Key steps: Reads next invoice header, checks print status, prompts for reprint if needed, then calls Print‑Routine for each invoice. [Seen in: all-print, Print‑Routine.]  
I/O: Reads from Invoice‑File, Sales‑File, Delivery‑File; writes to Print‑File and temporary Email‑Print‑File. [Seen in: all-print, Print‑Routine.]  
Outcomes: Invoice records marked printed, email files created if enabled, and status flags updated. [Seen in: Print‑Routine.]

Path: Single Invoice Print  
Trigger: User requests a single invoice via menu‑return when pass‑value not equal 3. [Seen in: menu-return, all-print-start.]  
Key steps: Decrements next‑invoice to get invoice number, reads invoice header, prompts for reprint, then calls Print‑Routine. [Seen in: menu-return, Print‑Routine.]  
I/O: Reads from Invoice‑File; writes to Print‑File and Email‑Print‑File. [Seen in: menu-return, Print‑Routine.]  
Outcomes: Single invoice printed and status updated. [Seen in: Print‑Routine.]

Path: Print‑Routine  
Trigger: Invoked from batch or single invoice processing. [Seen in: all-print, Print‑Routine.]  
Key steps: Loads invoice lines, formats header and customer details, writes line items to Email‑Print‑File, then copies to Print‑File, optionally sends email via zz090‑Issue‑Email. [Seen in: Print‑Routine, Headings‑1, zz090‑Issue‑Email.]  
I/O: Reads Invoice‑File lines; writes to Email‑Print‑File and Print‑File. [Seen in: Print‑Routine.]  
Outcomes: Invoice printed, status flags set, email sent if configured. [Seen in: Print‑Routine.]

Path: Email Sending  
Trigger: WS‑Send‑Emails flag set and Sales‑Email present after Print‑Routine. [Seen in: Print‑Routine.]  
Key steps: Calls zz090‑Issue‑Email to construct mail command and invoke system mailx. [Seen in: Print‑Routine, zz090‑Issue‑Email.]  
I/O: No file I/O, uses system call. [Seen in: zz090‑Issue‑Email.]  
Outcomes: Email sent, WS‑Email‑Sent flag set. [Seen in: zz090‑Issue‑Email.]

Path: Company Details Setup  
Trigger: Program start during init01. [Seen in: init01, zz080‑Setup‑Company‑Details.]  
Key steps: Loads company address fields, justifies them, and prepares lines for header printing. [Seen in: zz080‑Setup‑Company‑Details.]  
I/O: None. [Seen in: zz080‑Setup‑Company‑Details.]  
Outcomes: Company header lines available for Headings‑1. [Seen in: Headings‑1.]

5.4 Termination  
main-end performs Invoice‑Close, Sales‑Close, Delivery‑Close, and closes the Print‑File, then optionally calls SYSTEM to spool the report. [Seen in: main-end.]  
It waits for email sending to complete, deletes temporary email files, and exits the program. [Seen in: main-end.]

---
## sl940
*[221/267]*

### Business/Functional Perspective
### Invoice Deletion  

**Program Purpose**  
This program lets authorized staff remove an unposted invoice from the accounting system. When an invoice is deleted, the quantities that were allocated to it are returned to the appropriate stock items, audit records are written to maintain a reliable trail, and the deletion is logged for future reference. The process protects inventory accuracy, keeps the sales ledger consistent, and provides a clear audit trail to support compliance and risk management.  

**Screen Interactions**  

1. **Start Screen** – Shows the program title “Invoice Deletion” and the current date.  
   - **Input**: Invoice number to be deleted (enter “0” to quit).  
   - **Output**: Prompts “Zero invoice to quit” and “Delete Further Invoices (Y/N) ? [Y]” after each deletion.  

2. **Invoice Details Screen** – Displays the selected invoice’s customer name, address, date, order number, and type.  
   - **Input**: Confirmation to delete (“Y” to delete, any other key to cancel).  

3. **Confirmation Prompt** – Asks “Invoice To Be Deleted (Y/N) - [ ]”.  

No other user‑directed screens are present.  

**Messages and Errors**  
- **Invoice Not Found** – Informs the user that the requested invoice does not exist.  
- **Invoice Already Posted** – Alerts that the invoice has already been passed to the sales ledger and cannot be deleted.  
- **Missing Invoice File** – Indicates that the invoice file is not present on the system.  
- **Stock Update Error** – Signals a problem updating the inventory record when returning quantities.  
- **Audit Record Error** – Signals a failure to write the audit trail for the deletion.  
- **General Failure** – Any other operational error is reported with a brief description.  

All messages are displayed in a user‑friendly manner; technical response codes are not shown.  

**User Flow Summary**  
1. The user starts the program; the title screen displays the current date and prompts for an invoice number.  
2. The user enters the invoice number. If the number is zero, the program exits.  
3. The program looks up the invoice. If it cannot find the record or the invoice has already been posted, an error message is shown and the user is returned to the start screen.  
4. If the invoice is valid and unposted, its details (customer, address, date, order, type) are shown. The user confirms whether to delete the invoice.  
5. Upon confirmation, the program reads each line item of the invoice, updates the corresponding stock quantities and audit records, deletes the invoice header and all its line items, and records the deletion in a separate log file.  
6. The program then prompts whether the user wishes to delete another invoice. The loop continues until the user chooses not to or enters “0” at the start screen, after which the program closes all files and exits.  

**Program Linkages**  

- CBL_CHECK_FILE_EXIST  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins by executing **init01** which sets environment, opens all required files, and displays the invoice deletion menu. [Seen in: init01]  
The user is prompted to enter an invoice number; upon entry, the program reads the invoice header, displays details, and asks for confirmation to delete. [Seen in: invoice-enter]  
If confirmed, the program reads all line items, updates stock and audit records for each line, deletes the invoice header and lines, records the deletion, and then returns to the prompt for another invoice or exits. [Seen in: Read-Details, Update-Stock-n-Audit, Delete-Details, invoice-enter]

5.2 Initialization  
init01 performs environment setup, checks for the existence of the invoice file, and opens invoice, sales, delivery, DelInvNos, stock, stock audit, and analysis files. [Seen in: init01, Program-Start]  
It then initializes working storage, displays the program title and current date, and prepares for user interaction. [Seen in: init01, Program-Start]

5.3 Core Processing  
Path: **Invoice Deletion**  
Trigger: User enters an invoice number and confirms deletion.  
Key steps: Read invoice header (Invoice-Read-Indexed), display details, confirm Y, perform Read-Details to load all line items, perform Update-Stock-n-Audit for each line, delete header (Invoice-Delete) and lines (Delete-Details), write deletion record (DelInvNos-Write).  
I/O: Invoice file, Sales file, Delivery file, Stock file, Stock-Audit file, DelInvNos file.  
Outcomes: Stock quantities and values adjusted, audit trail created, invoice removed, deletion logged. [Seen in: invoice-enter, Read-Details, Update-Stock-n-Audit, Delete-Details, DelInvNos-Write]

Path: **Read-Details**  
Trigger: Called during invoice deletion to load all line items.  
Key steps: Loop over sih-lines, set invoice-nos and item-nos, perform Invoice-Read-Next, store line in Invoice-Lines, call Update-Stock-n-Audit.  
I/O: Invoice file (read next).  
Outcomes: Invoice-Lines table populated, stock and audit updated for each line. [Seen in: Read-Details]

Path: **Update-Stock-n-Audit**  
Trigger: Invoked for each line during Read-Details.  
Key steps: Verify stock link and type, create audit record, read stock record (Stock-Read-Indexed), adjust stock held and value, update period totals, rewrite stock record, write audit record if used.  
I/O: Stock file, Stock-Audit file.  
Outcomes: Stock record rewritten, audit record written, status flags set. [Seen in: Update-Stock-n-Audit]

Path: **Delete-Details**  
Trigger: Called after Read-Details when invoice is confirmed for deletion.  
Key steps: Loop over sih-lines, set invoice-nos and item-nos, perform Invoice-Delete to delete each line.  
I/O: Invoice file.  
Outcomes: All line items deleted from invoice file. [Seen in: Delete-Details]

Path: **Program-Start**  
Trigger: Executed during init01.  
Key steps: Check if invoice file exists using CBL_CHECK_FILE_EXIST; if not, display error and exit.  
I/O: Invoice file.  
Outcomes: Program terminates early if file missing. [Seen in: Program-Start]

5.4 Termination  
Upon user quitting or after processing all invoices, main-exit closes all opened files and exits the program. [Seen in: main-exit]  
The program ensures that all resources are released before returning control to the operating system. [Seen in: main-exit]

---
## sl950
*[222/267]*

### Business/Functional Perspective
### Delivery Note Printing

**Program Purpose**  
SL950 is a printing tool that produces delivery and picking notes (packing slips) for customer orders. It pulls the relevant order, customer, and stock details and outputs a formatted printout that can be sent to the dispatcher or clerk. The program ensures that each note is only printed once and updates the system to record that a note has been produced, helping prevent duplicate paperwork and maintain accurate shipping records.

**Screen Interactions**  
1. **Startup screen** – Displays the program name, the title “Delivery / Picking Note Print,” and the current date.  
2. **Print / Re‑Print prompt** – “Print Or Re‑Print.............  (P/R) ? - [P]” allowing the user to choose a new print or re‑print of existing notes.  
3. **Amended‑invoices prompt** – “Any Amended Invoices In This Batch? [N]” to determine whether amended orders should be processed.  
4. **Invoice number prompt** – “Give Lowest Invoice No. [        ]” when re‑printing, to specify the starting invoice number.  
5. **Re‑print confirmation** – For each invoice that has already been printed, the screen shows “Already Produced!.....Re-Print  (Y/N) ? - [Y]” to confirm a re‑print.  
6. **Continuation prompt** – “More To Print? [Y]” after each batch, letting the user continue printing or exit.

**Messages and Errors**  
- The program notifies the user when an invoice’s picking note has already been printed and asks whether a re‑print is desired.  
- It prompts the user for necessary input (P/R, Y/N, invoice numbers) and accepts only the expected responses.  
- If a required record cannot be located or a file cannot be opened, the program stops without further output, indicating a missing or corrupted data issue.  
- Successful prints update an internal status flag to record that the note has been produced.

**User Flow Summary**  
The user starts SL950, which displays a header with the current date and a prompt to print or re‑print packing slips. After selecting “P” for a new print, the program cycles through all pending orders, generating a delivery note for each: the note lists the customer’s address, the order number, the items with quantities and storage locations, and a total item count. For orders that have already had a note printed, the program asks whether to re‑print. The user can also choose to re‑print from a specific invoice number or to include amended invoices. After each batch, the program asks if more notes should be printed, allowing the user to continue or finish. Once completed, the program updates the status flags for the processed orders and exits, returning control to the surrounding environment.

**Program Linkages**  
- maps04  
- SYSTEM  
- C$JUSTIFY

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts with the init01 section performing startup checks and environment setup before displaying the menu. [Seen in: init01 section.]  
The user is prompted to choose printing or reprinting of packing notes, which directs execution to either All-Print-start or All-Print-get-inv. [Seen in: menu-return.]  
The selected path iterates over invoice records, invokes print-routine for each, and finally performs cleanup and exits. [Seen in: All-Print, main-end.]

5.2 Initialization  
init01 checks the full-invoicing flag, sets screen exception handling, assigns the spool name, and converts the current date. [Seen in: init01 section.]  
It also opens the invoice, stock, sales, delivery files and the print output file. [Seen in: menu-return.]

5.3 Core Processing  

Path: Auto‑run Trigger  
Trigger: pass‑value = 3  
Key steps: skip All‑Print‑start, read next invoice header, if pending invoke print‑routine.  
I/O: invoice-file, print-file.  
Outcomes: prints pick list if pending, updates sih-status-P.  
[Seen in: menu-return, All-Print.]

Path: User Print Path  
Trigger: user selects “P” at the print‑path prompt.  
Key steps: All‑Print‑go sets up invoice start, All‑Print reads next header, checks conditions, calls print‑routine.  
I/O: invoice-file, stock-file, sales-file, delivery-file, print-file.  
Outcomes: prints all pending pick lists, updates status flags.  
[Seen in: All-Print-start, All-Print-go, All-Print, print-routine.]

Path: User Reprint Path  
Trigger: user selects “R” at the print‑path prompt.  
Key steps: All‑Print‑get‑inv prompts for lowest invoice number, sets invoice‑nos, goes to All‑Print‑go, then loops All‑Print.  
I/O: invoice-file, print-file.  
Outcomes: reprints selected invoice(s).  
[Seen in: All-Print-start, All-Print-get-inv, All-Print-go, All-Print.]

Path: Print Routine  
Trigger: called from print‑routine section.  
Key steps: loop over invoice lines, write line‑8 records, compute totals, update status.  
I/O: invoice-file, stock-file, print-file.  
Outcomes: prints invoice lines, sets sih-status-P to “P”.  
[Seen in: print-routine.]

Path: Header & Company Details  
Trigger: headings‑1 section called from print‑routine.  
Key steps: write company header, date, invoice details.  
I/O: none external.  
Outcomes: prints header lines.  
[Seen in: headings-1.]

5.4 Termination  
main‑end performs close operations on all files and calls SYSTEM to flush the print spool. [Seen in: main-end.]  
The program then exits with exit program. [Seen in: main-end.]

---
## sl960
*[223/267]*

### Business/Functional Perspective
### Sales Ledger Customer Creation  

**Program Purpose**  
The program lets a user create or update a customer record used for invoice entry. It gathers key customer details—such as name, addresses, contact information, credit limits, and late‑charge rules—and validates the data before writing it to the sales ledger. The system ensures that a customer does not already exist and that all required fields are entered correctly, thereby maintaining data integrity and supporting accurate billing and credit control.

**Screen Interactions**  
1. **Customer Information Screen**  
   - **Inputs**:  
     - *Customer Nos* – customer number (with check‑digit).  
     - *Customer Name* – up to 30 characters.  
     - *Address* – two lines (up to 48 characters each).  
     - *Delivery name* – up to 30 characters.  
     - *Delivery address* – two lines (up to 48 characters each).  
     - *BO Allowed* – Y or N flag for partial shipping.  
     - *Telephone*, *Ext*, *Fax*, *Email Sales* – contact fields.  
     - *Late charges* – Y or N flag.  
     - *Minimum balance before late charge* – numeric.  
     - *Maximum late charge* – numeric.  
     - *Late letters* – Y or N flag.  
     - *Credit period* – numeric days.  
     - *Credit limit* – numeric amount.  
     - *Discount* – percentage (e.g., 5.50).  
   - **Options**:  
     - *<B>* – go back to edit fields.  
     - *<S>* – save the record.  
     - *<Q>* – quit without saving.  
   - **Status Displays**:  
     - Current balance and last invoice/payment placeholders (filled by the system).  
     - Escape code field shows the last command entered.  

**Messages and Errors**  
- **Missing or invalid Y/N responses**: prompts “Response must be (Y or N)”.  
- **Duplicate customer**: “Customer Record Already Exists”.  
- **Address validation errors**: “Addr Err” shown next to the offending address line.  
- **Other field errors**: generic “Error” messages for invalid late‑charge or late‑letter responses, and for an incorrectly entered BO flag.  
- **Blank customer number** ends entry without error.

**User Flow Summary**  
The user starts the screen and enters a customer number. If the number is new, the screen presents default values; if it already exists, the system loads the existing record. The user fills in or edits all required fields. For each Y/N field the system checks the response; if an invalid entry is made, a prompt appears asking for a correct Y or N. Address lines are validated for length and format; errors highlight the specific line. After all data is entered correctly, the user presses <S> to save; the program writes the customer record and, if a delivery address is supplied, writes a delivery record. The user may return to edit fields with <B> or exit with <Q>. Throughout the process, clear error messages guide corrections and confirm successful saves.

**Program Linkages**  
- `maps09`   *(called to verify and retrieve customer data)*

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in init01 section, sets screen environment, accepts terminal lines, displays the program name, opens sales and delivery files, and then calls Setup-Customers. [Seen in: init01]  
Setup-Customers repeatedly prompts for a customer number, validates it via maps09, reads or creates a sales record, and then enters the customer details entry flow. [Seen in: Setup-Customers, customer-input, customer-accept, customer-details]  
After writing the sales and optional delivery records, the program closes the files and exits. [Seen in: main-end, Sales-Close, Delivery-Close]

5.2 Initialization  
init01 sets screen exception flags, reads terminal line count, displays the program name, and opens the sales and delivery files. [Seen in: init01]  
It then performs Setup-Customers and finally closes the files before exiting. [Seen in: init01, Setup-Customers, Sales-Close, Delivery-Close]

5.3 Core Processing  

Path: Customer Input Loop  
Trigger: User enters a customer number at the prompt.  
Key steps: display customer screen, accept input, exit if blank, uppercase, call maps09, check reply, read sales record, if not found go to details else display error.  
I/O: sales-file, maps09.  
Outcomes: sets WS-Sales-Key, sets delivery-tag, may loop back.  
[Seen in: customer-input, customer-accept, maps09, Sales-Read-Indexed]

Path: Customer Details Entry  
Trigger: After a new or existing sales record is identified.  
Key steps: initialize records, set defaults, call customer-data to accept details, set escape-code, test-escape, write sales record, write delivery record if delivery-tag set.  
I/O: sales-file, delivery-file.  
Outcomes: records written, may loop back for more details.  
[Seen in: customer-details, get-details, main-output, Sales-Write, Delivery-Write]

Path: Escape Code Handling  
Trigger: User presses a key during data entry.  
Key steps: display escape-code, accept input, convert to upper case, loop until B, S, or Q.  
I/O: screen.  
Outcomes: sets escape-code used to control flow.  
[Seen in: test-escape, get-escape]

Path: Address Validation  
Trigger: Called from customer-data when validating sales or delivery address.  
Key steps: count delimiters, check count ranges, set truth flag.  
I/O: none.  
Outcomes: truth flag indicates validity, may set error-flag.  
[Seen in: validate-address]

Path: Response Validation  
Trigger: Called from customer-data for Y/N prompts.  
Key steps: uppercase reply, set z, set truth, display error if invalid.  
I/O: none.  
Outcomes: z set to 1 or 0, truth flag, may set error-flag.  
[Seen in: validate-response]

5.4 Termination  
main-end exits the Setup-Customers section and control returns to init01, which then closes files and exits the program. [Seen in: main-end, init01]  
The program terminates with a GOBACK from menu-end. [Seen in: menu-end]

---
## sl970
*[224/267]*

### Business/Functional Perspective
### Back Order Reporting  

**Program Purpose**  
The Back Order Reporting program lets users view and manage back‑order records. It generates printed lists of back orders by customer or by item and permits the user to add new records, amend existing quantities or prices, or delete records entirely. By ensuring that back‑order data is accurate and up‑to‑date, the program supports inventory control, billing integrity, and audit readiness.  

**Screen Interactions**  

1. **Main Menu Screen** – *Title*: “BO Reporting and Amendments Menu”  
   * Displays: menu prompt “Select one of the following by number – [ ]” with options:  
     1. Report All Back Orders by Customer And by Item  
     2. Report BO by Customers  
     3. Report BO by Stock Items  
     4. Amend or Delete Back Orders  
     X. Return To System menu  
   * Inputs: one‑character key selection.  

2. **Amend/Delete Input Screen** – *Title*: “BO Reporting – Edit”  
   * Prompts:  
     - “Mode – [ ]” (I = Input, A = Amend, D = Delete)  
     - “Customer No” – field for entering customer number.  
     - “Item No” – field for entering item number.  
   * Displays:  
     - Customer name and item description (retrieved from sales and stock records).  
     - Existing back‑order details: PO, quantity, dates, price, arrival flag, invoice type.  
   * Inputs:  
     - For Input/Amend: PO, quantity, order date, estimated date, invoice type, price (if applicable).  
     - For Delete: confirmation “Y/N”.  

**Messages and Errors**  

- **File Availability** – If the back‑order data file is missing or empty, the program notifies the user that no data is available and exits.  
- **Invalid Selection** – Choosing a menu option other than 1‑4 or X prompts an “Invalid mode” notice.  
- **Record Not Found** – When a specified customer/item combination is not found in the back‑order file, the program alerts the user and allows a retry.  
- **Invalid Dates** – Dates entered in an incorrect format are rejected, with a message indicating the proper format.  
- **Price Change Warning** – If the current price differs from the stock price during an amendment, a warning is shown.  
- **Deletion Confirmation** – The program requires a “Y/N” confirmation before deleting a record; any other input repeats the prompt.  
- **Write/Read Failures** – Any error when reading, rewriting, or deleting a record results in an error message describing the failure and an option to continue.  

**User Flow Summary**  

1. **Launch** – The user starts the program and is presented with the main menu screen.  
2. **Choose Operation** –  
   * For a report, the user selects options 1‑3; the program reads the back‑order file, formats the data, and sends it to the printer, displaying page breaks as needed.  
   * For amendments or deletions, the user selects option 4.  
3. **Edit Mode** – The edit screen prompts for a mode (Input, Amend, Delete).  
4. **Key Entry** – The user supplies a customer number and an item number. The program looks up the record and shows the current back‑order details.  
5. **Action** –  
   * **Input**: The user enters PO, quantity, dates, invoice type, and price (if applicable). The program validates the data and writes a new back‑order record.  
   * **Amend**: The user may change quantity, dates, invoice type, or price (subject to validation). The updated record is rewritten.  
   * **Delete**: The program asks for confirmation; upon “Y”, the record is removed.  
6. **Repeat or Exit** – After completing an action, the user returns to the menu. Choosing “X” ends the program.  

**Program Linkages**  

- CBL_CHECK_FILE_EXIST  
- SYSTEM  
- maps04  

---

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program starts at aa000-Main, performing environment setup, checking for the BO data file, and initializing screen and date header. [Seen in: aa000-Main.]  
The user is presented with a menu (aa010-Menu) and selects an action; input is handled in aa020-Menu-Input which dispatches to reporting or amend/delete routines. [Seen in: aa010-Menu, aa020-Menu-Input.]  
Reporting actions invoke ba000-Reports which opens the BO-Stk-Itm-File and generates either customer‑by‑customer, item‑by‑item, or combined reports using ba020-Cust-Report and ba030-Item-Report. [Seen in: ba000-Reports, ba020-Cust-Report, ba030-Item-Report.]  
Amend or delete actions are processed by CA000-Amend, which opens the BO file, obtains mode, key, and confirmation, then writes or deletes records accordingly. [Seen in: CA000-Amend, CA020-Get-Mode, CA030-Get-Key, CA040-Get-Confirm-Delete, CA080-Price.]  
After completing the chosen operation, the program returns to the menu or exits, closing any open files and resetting printer status. [Seen in: aa000-Menu-Exit, ca998-Exit.]

5.2 Initialization  
The program accepts environment lines, sets screen exception flags, and records the current time. [Seen in: aa000-Main.]  
It verifies that the BO data file exists and is non‑empty, displaying an error and terminating if not found. [Seen in: aa000-Main.]  
Header information such as program name, user, and current date is prepared, and the accept‑numeric routine is initialized for later use. [Seen in: aa000-Main.]

5.3 Core Processing  
Path: Menu Dispatch  
Trigger: User selects a menu option (Menu-Reply).  
Key steps: Perform aa020-Menu-Input to read selection, then dispatch to ba000-Reports for reporting or CA000-Amend for amend/delete.  
I/O: BO-Stk-Itm-File, Print-File.  
Outcomes: Sets WS-Printer-Status, opens files, and routes to appropriate processing.  
[Seen in: aa020-Menu-Input.]

Path: Reporting  
Trigger: Menu-Reply 1, 2, or 3.  
Key steps: Open Print-File if not already open, call ba020-Cust-Report and/or ba030-Item-Report to generate reports, then return to menu.  
I/O: BO-Stk-Itm-File, Print-File.  
Outcomes: Prints back‑order reports and updates WS-Printer-Status.  
[Seen in: ba000-Reports.]

Path: Customer Report  
Trigger: Part of Reporting path (ba020-Cust-Report).  
Key steps: Open BO-Stk-Itm-File, read sequentially, call ba110-Move-Cust for each record to format and write report lines.  
I/O: BO-Stk-Itm-File, Print-Record.  
Outcomes: Generates customer‑by‑customer report lines.  
[Seen in: ba020-Cust-Report.]

Path: Item Report  
Trigger: Part of Reporting path (ba030-Item-Report).  
Key steps: Open BO-Stk-Itm-File, read sequentially, call ba120-Move-Item for each record to format and write report lines.  
I/O: BO-Stk-Itm-File, Print-Record.  
Outcomes: Generates item‑by‑item report lines.  
[Seen in: ba030-Item-Report.]

Path: Amend/Delete  
Trigger: Menu-Reply 4.  
Key steps: Open BO-Stk-Itm-File, obtain mode (Input/Amend/Delete), read key record, confirm delete if needed, write or delete record, and loop back to mode selection.  
I/O: BO-Stk-Itm-File, Print-File.  
Outcomes: Updates or removes back‑order records, sets flags, and may display confirmation messages.  
[Seen in: CA000-Amend.]

Path: Exit  
Trigger: User selects X or after amend loop completes.  
Key steps: Close any open files (BO, Sales, Stock, Print), reset WS-Printer-Status, and perform GOBACK.  
I/O: BO-Stk-Itm-File, Print-File.  
Outcomes: Program terminates cleanly.  
[Seen in: aa000-Menu-Exit.]

5.4 Termination  
When the user chooses to return to the system menu, aa000-Menu-Exit performs a GOBACK, closing any open files and resetting the printer status. [Seen in: aa000-Menu-Exit.]  
The ca998-Exit paragraph ensures that the BO file and any sales or stock files are closed before the program exits. [Seen in: ca998-Exit.]  
The program ends with a GOBACK or STOP RUN after all cleanup. [Seen in: aa000-Menu-Exit.]

---
## slautogenLD
*[225/267]*

### Business/Functional Perspective
### SL Autogen Table Load

**Program Purpose**  
The program copies records from the SLautogen file into the MySQL database table used by the accounting system. It reads system configuration, verifies that the database is ready, then iterates through each file record, inserting it into the table. Duplicate entries are detected and logged without stopping the load, and a summary of how many records were processed and written is reported. This process keeps the table current, supports reporting and compliance, and reduces manual data‑entry errors.

**Screen Interactions**  
No direct screens. This program is run from a command line or batch environment and returns status information via log messages.

**Messages and Errors**  
- **Missing or unreadable system file** – aborts with an error message and exit code 128.  
- **Missing SLautogen file** – displays “Terminating nothing to do” and exits.  
- **Database connection or table errors** – aborts after reporting the problem and exit code 16.  
- **Duplicate key errors** – records are skipped, a notice is logged, and the program continues.  
- **Other database or file errors** – logs the error details and terminates with exit code 16.  
- **Successful completion** – shows a final count of records read, written, and rewritten, followed by an “EOJ – Load SLautogen Table” message.

**User Flow Summary**  
A user launches the program with optional command‑line arguments. The program first reads the system configuration file to obtain database credentials. It then checks that the SLautogen file exists; if not, it reports the issue and stops. If the file is present, the program opens it and begins processing each record. For each record it attempts to insert the data into the MySQL table. Duplicate records are noted and skipped. After all records are processed, the program prints a summary of how many records were read, written, and rewritten, and then exits cleanly, closing any open files and database connections.

**Program Linkages**  
- acas004  
- acas-get-params  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **aa000-main-start**, where it processes command‑line arguments, opens the system file, and loads database parameters before opening the SLautogen input file and the RDB output table. [Seen in: aa000-main-start.]  
After successful file openings, control transfers to **aa010-Read**, which loops over each record in the SLautogen file, writing them to the RDB table and handling duplicates or errors as they occur. [Seen in: aa010-Read.]  
When the end of the SLautogen file is reached or an unrecoverable error occurs, execution jumps to **aa999-Finish**, which logs summary statistics, closes all files, and exits the program. [Seen in: aa999-Finish.]

5.2 Initialization  
The **aa000-main-start** paragraph performs argument parsing, sets logging parameters, opens the system file, reads the system record, and loads RDB connection details via *acas-get-params* if necessary. [Seen in: aa000-main-start.]  
It then opens the SLautogen input file with **acas004-Open-Input**, checks for file‑open errors, opens the RDB output table with **acas004-Open-Output**, and initializes control flags before proceeding to the record‑processing loop. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: Record Processing Loop  
Trigger: Entry to **aa010-Read** after file openings.  
Key steps: Read next record from SLautogen file; on EOF go to finish; on read error log and finish; otherwise write record to RDB, increment input counter, and handle duplicate or write errors.  
I/O: SLautogen file (input), RDB table (output).  
Outcomes: Input and output record counters updated; duplicate rewrites counted; errors logged and may terminate the loop.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: SQL-State = "23000" or FS-Reply = 22/99 or SQL-Err = "1062"/"1022" after a write attempt.  
Key steps: Reset FS-Reply and WE-Error to zero, perform a rewrite of the record in the RDB, increment the rewrite counter, and continue the read loop.  
I/O: RDB table (rewrite).  
Outcomes: Duplicate record is rewritten, rewrite counter incremented, processing continues.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: Any FS-Reply not zero after a read or write operation (checked in **aa010-Read** and **aa100-Check-4-Errors**).  
Key steps: Log detailed error messages, optionally perform a rollback via **aa020-Rollback**, set a non‑zero return code, and jump to finish.  
I/O: Logging output (SO-Print).  
Outcomes: Program exits with an error status, no further records processed.  
[Seen in: aa100-Check-4-Errors.]

Path: Finish/Termination  
Trigger: **aa999-Finish** invoked after EOF or error.  
Key steps: Log record counts and log‑file statistics, close the RDB and SLautogen files, close the system file, and perform a GOBACK.  
I/O: System file, SLautogen file, RDB table.  
Outcomes: All resources released, program terminates cleanly.  
[Seen in: aa999-Finish.]

5.4 Termination  
Upon completion, **aa999-Finish** logs the total records processed, closes the RDB and SLautogen files, and exits with a GOBACK. [Seen in: aa999-Finish.]  
The program sets a final status code (return-code) before exiting, ensuring that the caller can detect success or failure. [Seen in: aa999-Finish.]

---
## slautogenMT
*[226/267]*

### Business/Functional Perspective
### Sales Invoice Database Handler  

**Program Purpose**  
The module manages the persistence of sales invoices and their line items in a relational database. It supports creating, reading, updating and deleting both invoice headers and individual line items, ensuring that each record is uniquely identified and that the data remains consistent. By abstracting database access, it allows higher‑level application modules to work with invoice data without dealing with SQL directly, thereby reducing risk of data corruption and simplifying audit and troubleshooting processes.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – The requested operation completed without issue.  
- **No Data / End of File** – No records were found for the requested key or the end of a data set has been reached.  
- **Duplicate Key** – An attempt was made to insert a record that already exists.  
- **Invalid Key / Record Not Found** – The supplied key does not exist in the database.  
- **Access / Permission Error** – The requested database operation was not permitted.  
- **Database Connection Failure** – The system could not establish or maintain a connection to the database.  
- **Unexpected Error** – An unexpected condition occurred (e.g., internal logic or SQL error) that prevented completion of the request.  

**User Flow Summary**  
A user or calling application supplies a sales invoice record (header plus optional line items) to this module. Depending on the requested function—create, read, update, delete, or delete‑all—the module validates the input, constructs the appropriate SQL command, and executes it against the database. For read operations, the module returns the header record followed by each line item in sequence, allowing the caller to display the complete invoice. After execution, the module returns a status code and a descriptive message that the caller can present to the user, indicating success or the nature of any error that occurred.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_query  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
On entry, the program initializes environment and sets up logging, then evaluates the File-Function to dispatch to the appropriate operation paragraph. [Seen in: ba-ACAS-DAL-Process]  
The operation paragraphs perform database actions such as opening/closing connections, reading headers or lines, writing, updating, or deleting records, often using pre‑compiled SQL commands and handling cursor state. [Seen in: ba020-Process-Open, ba030-Process-Close, ba040-Process-Read-Next, ba050-Process-Read-Indexed, ba060-Process-Start, ba070-Process-Write, ba080-Process-Delete, ba085-Process-Delete-All, ba090-Process-Rewrite]  
After executing the requested action, the program logs any errors, frees cursors if needed, and exits with status codes indicating success or failure. [Seen in: ba999-end, ba998-Free, Ca-Process-Logs]

5.2 Initialization  
The program accepts screen lines, sets screen exception handling, and initializes working‑storage variables such as SQL state, error messages, and counters. [Seen in: ba010-Initialise]  
It then opens the MySQL connection by performing MYSQL‑1000‑OPEN and sets cursor state to inactive. [Seen in: ba020-Process-Open]

5.3 Core Processing  

Path: Open  
Trigger: File‑Function = 1  
Key steps: Perform MYSQL‑1000‑OPEN, set cursor inactive, set file key string, set FS‑Reply to 0.  
I/O: MySQL connection.  
Outcomes: connection established, cursor inactive, FS‑Reply 0.  
[Seen in: ba020-Process-Open]  

Path: Read‑Next  
Trigger: File‑Function = 34  
Key steps: If cursor inactive, build WHERE clause for first key, perform SELECT on SAAUTOGEN‑REC, store result, set cursor active, handle no rows, then fetch next record via ba041‑Reread.  
I/O: SAAUTOGEN‑REC table, MySQL SELECT, MySQL FETCH.  
Outcomes: header record loaded into WS‑Invoice‑Record, cursor active, FS‑Reply 0 or 10 if EOF.  
[Seen in: ba040-Process-Read-Next, ba041-Reread]  

Path: Read‑Indexed  
Trigger: File‑Function = 4  
Key steps: If key test not zero, delegate to RG read; else build WHERE clause for key, perform SELECT, fetch record, load into WS‑Invoice‑Record.  
I/O: SAAUTOGEN‑REC table, MySQL SELECT, MySQL FETCH.  
Outcomes: record loaded, FS‑Reply 0 or 23 if not found.  
[Seen in: ba050-Process-Read-Indexed]  

Path: Write  
Trigger: File‑Function = 5  
Key steps: If WS‑Sih‑Test not zero, delegate to RG write; else load host variables, build INSERT statement, perform MySQL insert, handle duplicate key errors.  
I/O: SAAUTOGEN‑REC table, MySQL INSERT.  
Outcomes: record inserted, FS‑Reply 0 or 22 if duplicate.  
[Seen in: ba070-Process-Write, bc070-Process-Write]  

Path: Delete‑All  
Trigger: File‑Function = 6  
Key steps: Delete all lines for invoice key via RG delete‑all, then delete header record.  
I/O: SAAUTOGEN‑LINES‑REC and SAAUTOGEN‑REC tables, MySQL DELETE.  
Outcomes: all lines and header deleted, FS‑Reply 0 or 99 if error.  
[Seen in: ba085-Process-Delete-All, bc085-Process-Delete-ALL]  

5.4 Termination  
The program frees any active cursors, logs the operation, and sets the FS‑Reply and WE‑Error status before exiting. [Seen in: ba999-end, ba998-Free, Ca-Process-Logs]  
It then performs GOBACK (exit program) to return control to the caller. [Seen in: ba999-exit]

---
## slautogenRES
*[227/267]*

### Business/Functional Perspective
### Slautogen File Restore  

**Program Purpose**  
The program re‑creates the active SLAUTOGEN ISAM data file from a backup sequential file (`slautogen.seq`). It copies every record from the backup into the target ISAM file, thereby restoring the accounting ledger to a known state. This ensures data integrity after a crash or for scheduled backups, supporting compliance and audit readiness while minimizing downtime.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the backup file cannot be opened, a log entry stating “No slautogen file to process” is written.  
- When a record cannot be read, the program logs the read error and aborts the restore.  
- If a write to the target file fails, a “write error on .dat file” message is logged and the operation stops.  
- General environment setup problems are reported as an “Environment variables not yet set up” message.  

**User Flow Summary**  
A user initiates the restore by running the program (typically from a command line or automated job). The program attempts to open the backup sequential file and, if successful, begins copying each record into the ISAM file. Throughout the process, progress and any errors are recorded in `SYS-DISPLAY.log`. Once all records are processed, a final log entry reports the number of records read and written. If any step fails, the program logs the issue and terminates, allowing the user to review the log for troubleshooting.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments, configuring logging, and writing an initial status message. [Seen in: aa000-Main-Start.]  
It then opens the source sequential file for reading and the destination file for writing, handling any open‑file errors by logging and exiting. [Seen in: aa000-Main-Start.]  
A loop reads each record from the source, writes it to the destination, counts records, and on completion or error closes both files, logs a summary, and exits. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs a call to retrieve program arguments and sets logging parameters for the system. [Seen in: aa000-Main-Start.]  
It opens the input file, checks the status reply, and if the file is missing logs a message and terminates. [Seen in: aa000-Main-Start.]  
It opens the output file, verifies the status reply, and on failure logs an error and terminates. [Seen in: aa000-Main-Start.]  
Record counters are initialized to zero before processing begins. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read and Write Records  
Trigger: The infinite loop in paragraph aa010-Read-Recs.  
Key steps: Read next record from Agen‑Invoice‑File‑Seq; if end‑of‑file, go to Finish‑Off; if read error, log and go to Finish‑Off; increment input counter; write record to Agen‑Invoice‑File; if write error, log and go to Finish‑Off; increment output counter.  
I/O: Agen‑Invoice‑File‑Seq, Agen‑Invoice‑File.  
Outcomes: Counters updated, error status may cause early termination.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: End‑of‑file or any error during read/write.  
Key steps: Close both input and output files; build a summary string with record counts; log the summary; log a "CLOSE" message; set Return‑Code to zero; exit with GOBACK.  
I/O: Agen‑Invoice‑File‑Seq, Agen‑Invoice‑File.  
Outcomes: Program terminates cleanly, files closed, final status logged.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both the input and output files, logs a final summary of records processed, sets the return code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]

---
## slautogenUNL
*[228/267]*

### Business/Functional Perspective
### Slautogen Backup Utility  

**Program Purpose**  
The program creates a sequential backup copy of the current slautogen data file. It reads the original ISAM file and writes each record to a `.seq` file for use in recovery. By preserving a portable backup, the program helps maintain data integrity and supports compliance and audit requirements. It logs progress and any errors to a system log, ensuring that administrators can verify the backup. This lightweight utility runs automatically when required, reducing manual risk.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Missing input file** – Indicates that no slautogen file is available to process.  
- **Read error** – Reports a problem while reading the slautogen file.  
- **Write error** – Reports a problem while writing records to the sequential backup file.  
- **Success** – Confirms the number of records read and written, and logs the completion of the backup.  

**User Flow Summary**  
When the utility is invoked, it first checks for the presence of the slautogen data file. If the file exists, the program reads each record and writes it to a new sequential file named `slautogen.seq`. Throughout the process, messages are written to a log file, allowing the administrator to confirm that the backup was performed and to see the total number of records handled. If any errors occur, the log contains a clear notification of the issue. Once all records have been processed, the program closes the files, logs the final counts, and terminates.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa000-Main-Start, performing argument retrieval and logging initialization before attempting to open the source file. It then opens the sequential output file and enters aa010-Read-Recs, where it reads each record from the source, writes it to the output, and tracks counts. Upon reaching end-of-file or encountering an error, control transfers to aa020-Finish-Off, which closes files, reports totals, and exits. [Seen in: aa000-Main-Start, aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command-line parameters and sets logging system identifiers. It initializes working-storage counters to zero, prepares a message buffer, and opens the input file; if the file cannot be opened, it logs an error and aborts. [Seen in: aa000-Main-Start, zz020-Get-Program-Args.]  
The output file is then opened; any failure in opening the output file would be handled similarly, though the code assumes success. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Read/Write Loop  
Trigger: Successful open of both input and output files.  
Key steps: Read each record from Agen-Invoice-File; on success, increment input counter, write the record to Agen-Invoice-File-Seq, and increment output counter; repeat until end-of-file.  
I/O: Agen-Invoice-File, Agen-Invoice-File-Seq.  
Outcomes: ws-Rec-Cnt-In and ws-Rec-Cnt-Out reflect processed counts; any read or write error causes early exit to aa020-Finish-Off. [Seen in: aa010-Read-Recs.]  

Path: Input File Not Found  
Trigger: FS-Reply non-zero after attempting to open Agen-Invoice-File.  
Key steps: Log “No slautogen file to process”, close the input file, and goback.  
I/O: Agen-Invoice-File.  
Outcomes: Program terminates without creating an output file. [Seen in: aa000-Main-Start.]  

Path: Read Error During Processing  
Trigger: FS-Reply non-zero during a read operation in aa010-Read-Recs.  
Key steps: Log error message with SY003 and FS-Reply, then go to aa020-Finish-Off.  
I/O: Agen-Invoice-File.  
Outcomes: Processing stops, counts reflect records read before error. [Seen in: aa010-Read-Recs.]  

Path: Write Error During Processing  
Trigger: FS-Reply non-zero after a write to Agen-Invoice-File-Seq.  
Key steps: Log SY006, then go to aa020-Finish-Off.  
I/O: Agen-Invoice-File-Seq.  
Outcomes: Processing stops, counts reflect records written before error. [Seen in: aa010-Read-Recs.]  

Path: Finish-Off  
Trigger: End-of-file or any error path.  
Key steps: Close both files, log record counts, set Return-Code to zero, and goback.  
I/O: Agen-Invoice-File, Agen-Invoice-File-Seq.  
Outcomes: Program exits cleanly with zero return code. [Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs a final “CLOSE” message, sets Return-Code to zero, and performs a goback to terminate. [Seen in: aa020-Finish-Off.]  
No additional cleanup beyond file closure is performed. [Seen in: aa020-Finish-Off.]

---
## sldelinvnosLD
*[229/267]*

### Business/Functional Perspective
### Load DelInvNos Table  

#### Program Purpose  
This program transfers all records from the DelInvNos file into the MySQL **DelInvNos** table. It guarantees that each record is inserted only once, handles duplicate entries gracefully, and logs the outcome of each operation. The process ensures the ledger database stays current, supports audit trails, and reduces the risk of data inconsistencies that could affect financial reporting.  

#### Screen Interactions  
No direct screens. This program is run as a background job (e.g., via a script or command line) and writes its output to the system log.  

#### Messages and Errors  
- **File missing** – The DelInvNos file could not be found, so no data is loaded.  
- **Database not configured** – System parameters for the MySQL connection are missing or invalid, causing the job to abort.  
- **Duplicate key encountered** – A record already exists in the table; the program skips the duplicate and continues, counting the occurrence.  
- **Write error** – A problem prevented a record from being written; the job stops and reports the error.  
- **General failure** – Any other unexpected problem during file reading, writing, or database communication results in an error message and termination of the job.  
- **Completion summary** – At the end of the run, the program reports the number of records read, the number successfully written, the number of duplicates that were ignored, and the total number of log entries created.  

#### User Flow Summary  
1. The user initiates the program (usually from a batch scheduler or command line).  
2. The program reads system parameters to obtain MySQL connection details.  
3. It attempts to open the DelInvNos input file. If the file is absent, a notice is logged and the job ends.  
4. If the file is available, the program loops through each record. For each record:  
   - It tries to insert the record into the MySQL table.  
   - If the record is a duplicate, it is skipped and counted.  
   - If the insert succeeds, the record count increases.  
   - Any insertion error stops the job and writes an error message.  
5. After processing all records, the program writes a summary of totals to the log and closes the database and file connections.  
6. The job completes, leaving a clear audit trail of what was loaded and any issues that occurred.  

#### Program Linkages  
- acas-get-params  
- acas017  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-main-start, parses command line arguments, initializes logging, and opens the system parameter file. [Seen in: aa000-main-start.]  
It then loads database connection details, opens the Delinvnos input file, and opens the target MySQL table via acas017 routines. [Seen in: aa010-Proc-Override.]  
The main loop in aa010-Read reads each record, writes it to the database, handles duplicates or errors, and continues until EOF, after which aa999-Finish reports counts and closes resources. [Seen in: aa010-Read.]

5.2 Initialization  
The program verifies that the system file can be opened and read; any failure causes an error message and immediate exit. [Seen in: aa000-main-start.]  
It sets up environment variables, logging parameters, and database connection parameters, then prepares the input and output file handles via acas017-Open-Input and acas017-Open. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: System File Read Failure  
Trigger: FS-Reply not zero after opening System-File.  
Key steps: display error messages, close System-File, set return-code 128, goback.  
I/O: System-File.  
Outcomes: program terminates before processing.  
[Seen in: aa000-main-start.]

Path: Delinvnos File Not Found  
Trigger: FS-Reply = 35 after acas017-Open-Input.  
Key steps: log message “SL097 Terminating nothing to do”, close System-File, close Delinvnos file, goback.  
I/O: Delinvnos file, System-File.  
Outcomes: program exits with no records processed.  
[Seen in: aa010-Proc-Override.]

Path: Normal Record Load  
Trigger: fs-reply = 0 after acas017-Read-Next and acas017-Write.  
Key steps: increment input and output counters, write record to RDB, loop to next record.  
I/O: Delinvnos file, MySQL table.  
Outcomes: records transferred, counters updated.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: SQL-State = “23000” or fs-reply = 22 or 99 or SQL-Err 1062/1022 after write.  
Key steps: reset fs-reply and WE-Error, perform acas017-Rewrite, increment rewrite counter, continue loop.  
I/O: Delinvnos file, MySQL table.  
Outcomes: duplicate records rewritten, rewrite counter incremented.  
[Seen in: aa010-Read.]

Path: General Write Error  
Trigger: fs-reply not zero after write (other than duplicate).  
Key steps: log error details, set return-code 16, go to finish.  
I/O: Delinvnos file, MySQL table.  
Outcomes: program terminates with error status.  
[Seen in: aa010-Read.]

5.4 Termination  
aa999-Finish prints summary of records processed, closes the RDB and Delinvnos files, and logs an end‑of‑job message before gobacking. [Seen in: aa999-Finish.]  
No explicit commit or rollback is performed; any pending transaction is left to the database or handled by the called MySQL_rollback/commit routines if invoked. [Seen in: aa020-Rollback, aa030-Commit.]

---
## sldelinvnosMT
*[230/267]*

### Business/Functional Perspective
### Deleted Invoice Number Handler

**Program Purpose**  
This program manages the list of deleted invoice numbers used by the sales module. It guarantees that each deleted invoice number is stored uniquely, can be retrieved in sequence or by key, and can be added, updated, or removed as needed. The handler ensures data integrity and provides a reliable interface for other parts of the application to access or modify the record set. By centralising all file and database operations, it reduces the risk of data corruption and simplifies audit trails for deleted invoices.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Success** – The requested operation completes and the system reports a normal reply code.  
- **No Data / End of File** – When a read operation finds no records, the program signals that the list is empty or that the cursor has reached the end.  
- **Duplicate Key** – Attempts to add a deleted invoice number that already exists are rejected and reported to the caller.  
- **Key Not Found** – Read or delete operations that reference a non‑existent invoice number return a “not found” status.  
- **Deletion Failure** – If a delete or delete‑all request cannot be completed, the program returns an error status.  
- **Database Connection or SQL Error** – Any problems with connecting to or querying the database result in an error status that includes the database error description for troubleshooting.

**User Flow Summary**  
When a user (or calling module) wants to manage deleted invoice numbers, it first opens the record set. The user can then:
1. **Read** the next available number in sequence or **search** for a specific number.  
2. **Add** a new deleted invoice number; the system checks for uniqueness and confirms success or reports a duplicate.  
3. **Update** an existing record if needed.  
4. **Delete** a specific number or clear the entire list.  
After each operation, the program returns a status indicating success or the type of failure, and it logs the action for audit purposes. The caller can use this information to display messages to the end user or to drive further business logic.

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts in ba-ACAS-DAL-Process, performs environment setup and then evaluates File-Function to dispatch to one of the process paragraphs. [Seen in: ba-ACAS-DAL-Process.]  
Each process paragraph performs the requested database operation (open, close, read, write, delete, etc.) using MySQL pre‑SQL calls and sets FS-Reply, WE-Error, and SQL status fields accordingly. [Seen in: ba020-Process-Open, ba030-Process-Close, ba040-Process-Read-Next, ba050-Process-Read-Indexed, ba060-Process-Start, ba070-Process-Write, ba080-Process-Delete, ba085-Process-Delete-ALL, ba090-Process-Rewrite.]  
After the operation, the program logs any activity if testing is enabled, frees any active cursor, and exits via ba999-end. [Seen in: ba999-end.]

5.2 Initialization  
In ba010-Initialise, the program clears error and status fields and sets up screen exception handling before proceeding. [Seen in: ba010-Initialise.]  
The program also accepts the number of environment lines and ensures a minimum of 24 lines for screen handling. [Seen in: ba010-Initialise.]

5.3 Core Processing  

Path: Process-Open  
Trigger: File-Function = 1  
Key steps: Build MySQL connection parameters from linkage areas, perform MYSQL-1000-OPEN, set cursor inactive, set FS-Reply to 0.  
I/O: None (just opens DB).  
Outcomes: FS-Reply set to 0 if success, else go to ba999-end.  
[Seen in: ba020-Process-Open.]

Path: Process-Start  
Trigger: File-Function = 9  
Key steps: Validate access-type, clear active cursor, build WHERE clause based on key and relation, execute SELECT, set cursor active if rows found, set FS-Reply and WE-Error accordingly.  
I/O: SELECT from SADELINV-REC.  
Outcomes: FS-Reply 0 on success, 21 on key not found, WE-Error set for SQL errors.  
[Seen in: ba060-Process-Start.]

Path: Process-Write  
Trigger: File-Function = 5  
Key steps: Load host variables from record, build INSERT command, execute, check row count, set FS-Reply and WE-Error for duplicate key or other errors.  
I/O: INSERT into SADELINV-REC.  
Outcomes: FS-Reply 0 on success, 22 on duplicate key, 99 on other errors.  
[Seen in: ba070-Process-Write.]

Path: Process-Delete  
Trigger: File-Function = 8  
Key steps: Build WHERE clause for key, execute DELETE, check row count, set FS-Reply and WE-Error.  
I/O: DELETE from SADELINV-REC.  
Outcomes: FS-Reply 0 on success, 99 on error.  
[Seen in: ba080-Process-Delete.]

Path: Process-Delete-ALL  
Trigger: File-Function = 6  
Key steps: Set key to max value, build WHERE clause, execute DELETE, check row count, set FS-Reply and WE-Error.  
I/O: DELETE from SADELINV-REC.  
Outcomes: FS-Reply 0 on success, 99 on error.  
[Seen in: ba085-Process-Delete-ALL.]

Path: Process-Rewrite  
Trigger: File-Function = 7  
Key steps: Load host variables, build WHERE clause, execute UPDATE, check row count, set FS-Reply and WE-Error.  
I/O: UPDATE SADELINV-REC.  
Outcomes: FS-Reply 0 on success, 99 on error.  
[Seen in: ba090-Process-Rewrite.]

5.4 Termination  
The program performs any pending logging via Ca-Process-Logs if testing is enabled, then frees any active cursor and exits through ba999-end. [Seen in: ba999-end.]  
The exit paragraph ba999-exit simply exits the program. [Seen in: ba999-exit.]

---
## sldelinvnosRES
*[231/267]*

### Business/Functional Perspective
### Delinvnos File Restore

**Program Purpose**  
The program restores the `delinvnos` database by copying records from a backup sequential file (`delinvnos.seq`) into the primary ISAM file. It ensures that deleted inventory numbers are correctly re‑created in the system, preserving data integrity for inventory tracking and financial reporting. By verifying and logging each record, the program supports audit trails and reduces the risk of lost or corrupted data during system recovery.

**Screen Interactions**  
No direct screens. This program is invoked from the command line or batch environment and writes its status messages to the log file `SYS-DISPLAY.log`.

**Messages and Errors**  
- *File not found*: “No sldelinvnos file to process” when the backup file is missing.  
- *Open error*: “Failed on open sldelinvnos file = …” if the program cannot open the target ISAM file.  
- *Read error*: A problem reading the sequential file triggers a message indicating the issue.  
- *Write error*: If a record cannot be written to the ISAM file, a message signals the failure.  
- *Argument or environment issue*: If the program is started with incorrect parameters or required environment variables are missing, it logs an appropriate notice.  
- *Completion notice*: The program reports the total number of records read and written.

**User Flow Summary**  
A user or automated job runs the restore program with the backup file `delinvnos.seq` already present. The program logs its start, opens the backup file, and then sequentially reads each record. Each record is written to the live `delinvnos` database, and a running count of processed records is kept. If any error occurs—such as a missing file, a read failure, or a write failure—the program logs a descriptive message and stops processing. Upon successful completion, the program logs the total number of records that were read and written, closes the files, and exits cleanly.

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **aa000-Main-Start**, where it parses command‑line arguments, initializes logging, and opens the input sequential file **Del-Inv-Nos-File-Seq**. [Seen in: aa000-Main-Start.]  
It then opens the output file **Del-Inv-Nos-File** and enters a read‑write loop that copies each record from the input to the output while counting records, handling any read or write errors. [Seen in: aa010-Read-Recs.]  
Upon reaching end‑of‑file or encountering an error, the program executes **aa020-Finish-Off**, closing both files, logging totals, setting the return code, and exiting. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to capture command‑line parameters. [Seen in: aa000-Main-Start.]  
It sets logging parameters **WS-Log-System** and **WS-Log-File-no**, writes a header via **Call-Sysout**, and opens **Del-Inv-Nos-File-Seq**, verifying **FS-Reply** and aborting if the file cannot be opened. [Seen in: aa000-Main-Start.]  
It then opens **Del-Inv-Nos-File** for output, again checking **FS-Reply** and aborting on failure. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal-Processing  
Trigger: Successful opening of both input and output files.  
Key steps: Enter a loop that reads each record from **Del-Inv-Nos-File-Seq**, writes it to **Del-Inv-Nos-File**, increments record counters, and checks **FS-Reply** after each operation.  
I/O: Del-Inv-Nos-File-Seq, Del-Inv-Nos-File.  
Outcomes: **WS-Rec-Cnt-In**, **WS-Rec-Cnt-Out** are updated; any error causes transition to finish.  
[Seen in: aa010-Read-Recs.]

Path: Input-File-Not-Found  
Trigger: **FS-Reply** non‑zero after opening **Del-Inv-Nos-File-Seq**.  
Key steps: Log error message, close the input file, and perform **goback**.  
I/O: Del-Inv-Nos-File-Seq.  
Outcomes: Program exits immediately.  
[Seen in: aa000-Main-Start.]

Path: Output-Open-Error  
Trigger: **FS-Reply** non‑zero after opening **Del-Inv-Nos-File**.  
Key steps: Log error message and perform **goback**.  
I/O: Del-Inv-Nos-File.  
Outcomes: Program exits immediately.  
[Seen in: aa000-Main-Start.]

Path: Read-Error  
Trigger: **FS-Reply** non‑zero during a read from **Del-Inv-Nos-File-Seq**.  
Key steps: Log error message and jump to **aa020-Finish-Off**.  
I/O: Del-Inv-Nos-File-Seq.  
Outcomes: Program proceeds to finish and exit.  
[Seen in: aa010-Read-Recs.]

Path: Write-Error  
Trigger: **FS-Reply** non‑zero during a write to **Del-Inv-Nos-File**.  
Key steps: Log error message and jump to **aa020-Finish-Off**.  
I/O: Del-Inv-Nos-File.  
Outcomes: Program proceeds to finish and exit.  
[Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: End‑of‑file or any error causing exit from the read loop.  
Key steps: Close both files, log record totals, set **Return-Code** to zero, and perform **goback**.  
I/O: Del-Inv-Nos-File-Seq, Del-Inv-Nos-File.  
Outcomes: Program terminates cleanly.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both input and output files, logs a close message, sets **Return-Code** to zero, and exits via **goback**. [Seen in: aa020-Finish-Off.]  
Any errors encountered during file operations result in an immediate log message followed by **goback** to terminate the program. [Seen in: aa000-Main-Start.]

---
## sldelinvnosUNL
*[232/267]*

### Business/Functional Perspective
### Invoice Numbers Backup Export  

**Program Purpose**  
The program creates a sequential backup of the *sldelinvnos* data file. It copies every record from the source file to a new file named `delinvnos.seq`, providing a reliable archive that can be used for recovery or system migration. The process is automated, requires no user interaction, and logs all activity so that operators can verify success or diagnose problems. By ensuring the data can be restored even if the original ISAM file becomes corrupted or incompatible, the program supports data integrity and auditability.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Missing source file** – “No sldelinvnos file to process.”  
- **Read error** – “Problem reading sldelinvnos file = …” (the system reply code is appended).  
- **Write error** – “Write error on .seq file.”  
- **Incorrect arguments** – “Program arguments incorrect: ….”  
- **Environment not set** – “Environment variables not yet set up : ABORTING.”  
- **Note message** – “Note message & Hit return” (used when a manual acknowledgment is required).  

All messages are written to a log file via the ACAS‑Sysout routine; the program halts on any of these errors.  

**User Flow Summary**  
The operator starts the program from a command line. Immediately a status message is logged indicating the program name and the files involved. The program attempts to open the original `sldelinvnos` file. If the file is absent or unreadable, a descriptive error is logged and the program exits. Otherwise, it reads each record, writes it to `delinvnos.seq`, and counts the records transferred. After all records are processed, the program logs a summary showing the number of records read and written, then closes the files and exits normally. The operator can review the generated log file to confirm that the backup completed successfully or to investigate any issues.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-Main-Start, retrieves command line arguments, sets logging parameters, and logs a startup message. [Seen in: aa000-Main-Start.]  
It opens the source file Del-Inv-Nos-File, checks for existence, and if missing logs an error and exits. [Seen in: aa000-Main-Start.]  
If the source file exists, it opens the destination sequential file Del-Inv-Nos-File-Seq and enters a loop in aa010-Read-Recs to copy each record, handling errors and counting records, then finalizes in aa020-Finish-Off. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments and initializes logging system identifiers WS-Log-System and WS-Log-File-no. [Seen in: aa000-Main-Start, zz020-Get-Program-Args.]  
It logs a message indicating the COBOL files in use and opens the input file Del-Inv-Nos-File, verifying FS-Reply before proceeding. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: File Not Found  
Trigger: FS-Reply not zero after opening Del-Inv-Nos-File.  
Key steps: log “No sldelinvnos file to process”, close input file, log “CLOSE”, goback.  
I/O: Del-Inv-Nos-File.  
Outcomes: program exits without processing.  
[Seen in: aa000-Main-Start.]  

Path: Read and Write Records  
Trigger: start of aa010-Read-Recs loop.  
Key steps: read next record, check FS-Reply, write to Del-Inv-Nos-File-Seq, increment counters, handle write errors, exit loop on end‑of‑file or error.  
I/O: Del-Inv-Nos-File, Del-Inv-Nos-File-Seq.  
Outcomes: record counts updated, errors logged, program proceeds to finish.  
[Seen in: aa010-Read-Recs.]

5.4 Termination  
In aa020-Finish-Off, the program closes both files, logs the total records processed, and logs a “CLOSE” message. [Seen in: aa020-Finish-Off.]  
It sets Return-Code to zero and performs goback to terminate the program. [Seen in: aa020-Finish-Off.]

---
## slinvoiceLD
*[233/267]*

### Business/Functional Perspective
### Invoice Table Load  

**Program Purpose**  
The program imports invoices from the SL Invoice file into the MySQL database. It reads configuration data, verifies that the database is ready, and then copies each invoice record into the appropriate table. Duplicate entries are detected and either ignored or rewritten, and any failures are logged for review. The process ensures that the accounting system’s invoice records are current and consistent, supporting accurate reporting and compliance.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the system configuration file cannot be read, the program stops and reports a configuration error.  
- If the invoice file is missing, a “no data” message is shown and the load ends.  
- When a duplicate invoice is found, the record is ignored or rewritten and a note is logged.  
- Any database write failure (e.g., connection or permission problems) causes the program to abort and report the error.  
- General operational failures—such as unexpected file or database errors—are displayed and terminate the process.  
- On successful completion the program shows how many records were processed, written, and rewritten.  

**User Flow Summary**  
The user runs the program (typically via a script or scheduler). The program reads the system configuration to obtain database connection details. If the database is not set up, it aborts with an informative message. It then attempts to open the SL Invoice file. If the file is empty or missing, it reports this and ends. Otherwise, it reads each invoice record, attempts to insert it into the MySQL table, and handles duplicates according to the defined logic. Throughout the run, any problems are logged and displayed. After all records have been processed, the program prints a summary of records loaded, rewritten, and any errors encountered, then exits.  

**Program Linkages**  
- acas016  
- acas-get-params  
- ACAS-Sysout  
- MySQL_rollback  
- MySQL_commit

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by performing argument parsing, logging initialization, and opening the system parameter file to obtain database configuration. [Seen in: aa000-main-start.]  
It then opens the COBOL invoice input file and the MySQL invoice table via the acas016 interface, handling any file or database open errors. [Seen in: aa010-Proc-Override.]  
The main loop reads each invoice record, writes it to the database, and handles duplicate key or write errors by rewriting or skipping records, accumulating counts. [Seen in: aa010-Read.]  
After all records are processed, the program outputs summary statistics, closes both files, and exits. [Seen in: aa999-Finish.]

5.2 Initialization  
The program performs argument validation, sets logging system and file numbers, and calls Call‑Sysout to log the start message. [Seen in: aa000-main-start.]  
It opens the system file, reads the first record to load RDBMS parameters, and if necessary invokes acas‑get‑params to obtain missing database settings. [Seen in: aa000-main-start.]  
If the database name is not set or COBOL files are in use, the program logs the issue and aborts. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Setup (aa010-Proc-Override)  
Trigger: Successful read of system parameters and determination that RDBMS is available.  
Key steps: Set file usage flags, open input COBOL invoice file via acas016‑Open‑Input, open output MySQL table via acas016‑Open‑Output, then branch to aa010‑Read.  
I/O: System‑File (read), acas016 input file, acas016 output table.  
Outcomes: File‑System‑Used flags set; any open errors cause abort; otherwise proceed to reading loop.  
[Seen in: aa010-Proc-Override.]  

Path: Record Read & Write Loop (aa010-Read)  
Trigger: Each successful acas016‑Read‑Next call.  
Key steps: Increment input count, write record via acas016‑Write, handle duplicate key (SQL‑State 23000, fs‑reply 22 or 99, or SQL‑Err 1062/1022) by rewriting or skipping, increment rewrite count, handle other errors by logging and aborting, increment output count, loop.  
I/O: acas016 input file, acas016 output table.  
Outcomes: Counts of records read, written, rewritten; errors logged; loop continues until EOF or error.  
[Seen in: aa010-Read.]  

Path: Duplicate Key Handling (within aa010-Read)  
Trigger: Duplicate key detected during write.  
Key steps: Reset FS‑Reply and WE‑Error, clear SQL‑State and SQL‑Err, perform acas016‑Rewrite, log success or error, increment rewrite count, continue loop.  
I/O: acas016 output table.  
Outcomes: Duplicate records are rewritten; rewrite count updated; processing continues.  
[Seen in: aa010-Read.]  

Path: Error Handling (aa100-Check-4-Errors)  
Trigger: Any FS‑Reply not zero after a database operation.  
Key steps: Log error details, perform rollback (MySQL_rollback), abort processing.  
I/O: None (logging only).  
Outcomes: Program terminates with error status.  
[Seen in: aa100-Check-4-Errors.]  

Path: Finish (aa999-Finish)  
Trigger: EOF reached or error abort.  
Key steps: Log summary counts, close output table, close system file, close input file, log end message, goback.  
I/O: acas016 output table, System-File, acas016 input file.  
Outcomes: Program exits cleanly with counts logged.  
[Seen in: aa999-Finish.]  

5.4 Termination  
The program logs final record counts, closes the MySQL table and the system file, then closes the COBOL invoice file before returning control. [Seen in: aa999-Finish.]  
It then writes an end‑of‑job message and exits with a GOBACK. [Seen in: aa999-Finish.]

---
## slinvoiceMT
*[234/267]*

### Business/Functional Perspective
### Sales Invoice Processing  

**Program Purpose**  
The program provides the data‑access layer for sales invoices.  It opens the invoice table, reads or writes invoice header and line records, deletes individual invoices or all lines for a given invoice, and rewrites records.  The system guarantees that every invoice and line is correctly persisted, that duplicate keys are prevented, and that any database errors are reported for audit and troubleshooting.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
* Successful operation – the requested read, write, delete, or rewrite completes without issue.  
* End of data – the caller has reached the last record in the invoice file.  
* Record not found – the requested key or line does not exist.  
* Duplicate key – an attempt was made to insert an invoice or line that already exists.  
* Database error – any SQL or connection error (e.g., loss of database link, lock timeout).  
* Invalid request – the caller supplied an unsupported function or access type.  
* Unknown error – an unexpected condition that prevents completion of the operation.  

**User Flow Summary**  
When a user or calling application wants to work with sales invoices, it first opens the invoice data set.  The program then allows the user to:  

1. **Read an invoice** – retrieve the header and, if needed, each line sequentially or by specific key.  
2. **Write a new invoice** – add a header record and optionally add line items.  
3. **Delete an invoice or all of its lines** – remove a header record or purge all associated lines.  
4. **Rewrite an invoice** – update the header or a line with new values.  

After each operation the program returns a status that indicates success or the type of failure, and the caller can display an appropriate message to the user.  

**Program Linkages**  
* MySQL_errno  
* MySQL_sqlstate  
* MySQL_error  
* MySQL_fetch_record  
* MySQL_query  
* fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the **ba-ACAS-DAL-Process** paragraph, where it accepts linkage areas and sets screen‑exception handling.  
It then evaluates the **File‑Function** value to dispatch to the appropriate processing paragraph (open, close, read‑next, read‑indexed, write, delete‑all, rewrite, delete, start or bad‑function).  
After the selected paragraph completes, control returns to **ba999‑end** or **ba999‑exit** for cleanup and termination. [Seen in: ba-ACAS-DAL-Process.]

5.2 Initialization  
During **ba010‑Initialise** the program clears the SQL state, error messages, and sets the initial reply and error codes to zero or spaces.  
It also accepts the number of screen lines, adjusts the line count, and enables screen‑exception detection. [Seen in: ba010‑Initialise.]

5.3 Core Processing  

Path: **Open**  
Trigger: File‑Function = 1  
Key steps: Build connection strings, perform MYSQL‑1000‑OPEN, set cursor inactive, and set file‑key to “OPEN SL INVOICE”.  
I/O: MySQL connection (no table).  
Outcomes: fs‑reply set to 0 on success or error code on failure; WE‑Error remains 0. [Seen in: ba020‑Process‑Open.]

Path: **Close**  
Trigger: File‑Function = 2  
Key steps: If a cursor is active, free it via **ba998‑Free**; perform MYSQL‑1980‑CLOSE; set file‑key to “CLOSE SL INVOICE”.  
I/O: MySQL connection.  
Outcomes: fs‑reply set to 0 on success; WE‑Error remains 0. [Seen in: ba030‑Process‑Close.]

Path: **Read‑Next**  
Trigger: File‑Function = 34 (special read‑next‑header)  
Key steps: If no cursor active, construct a SELECT for all rows with key ≥ “0000000000”, execute, store result, and activate cursor.  
I/O: SAINVOICE‑REC table.  
Outcomes: fs‑reply = 10 if no data, else cursor active and record loaded into WS‑Invoice‑Record. [Seen in: ba040‑Process‑Read‑Next.]

Path: **Read‑Indexed**  
Trigger: File‑Function = 4  
Key steps: If WS‑Sih‑Test ≠ 0, delegate to RG read; otherwise build a SELECT on SAINVOICE‑REC for the exact key, fetch the record, and load into WS‑Invoice‑Record.  
I/O: SAINVOICE‑REC table.  
Outcomes: fs‑reply = 23 if not found; otherwise record loaded and fs‑reply = 0. [Seen in: ba050‑Process‑Read‑Indexed.]

Path: **Write**  
Trigger: File‑Function = 5  
Key steps: If WS‑Sih‑Test ≠ 0, delegate to RG write; otherwise load host variables, build an INSERT into SAINVOICE‑REC, execute, and check row count.  
I/O: SAINVOICE‑REC table.  
Outcomes: fs‑reply = 22 on duplicate key, 99 on other errors, otherwise 0. [Seen in: ba070‑Process‑Write.]

Path: **Delete‑All**  
Trigger: File‑Function = 6  
Key steps: Delete all rows from SAINVOICE‑REC for the invoice key, then delete all rows from SAINV‑LINES‑REC for the same key via RG delete‑all.  
I/O: SAINVOICE‑REC and SAINV‑LINES‑REC tables.  
Outcomes: fs‑reply = 99 on error, otherwise 0. [Seen in: ba085‑Process‑Delete‑All.]

5.4 Termination  
The **ba999‑end** paragraph performs optional logging via **Ca‑Process‑Logs** if Testing‑1 is set, then exits the program.  
The **ba999‑exit** paragraph simply exits the program. [Seen in: ba999‑end, ba999‑exit.]

---
## slinvoiceRES
*[235/267]*

### Business/Functional Perspective
### Invoice File Restore  

**Program Purpose**  
This program recovers invoice records from a sequential backup file and restores them into the live database. By copying each record and logging the process, it ensures the data set remains complete and consistent, especially after a database corruption or migration. The operation produces a simple audit trail of the number of records processed, helping the business maintain accurate financial records.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- When the source file is missing, the program logs “No Invoice file to process.”  
- If the output file cannot be opened, a message indicating the failure is written.  
- During reading, any error causes a “Problem reading .seq file” message.  
- Write errors produce a “Write error on .dat file” message.  
- At completion, a log entry displays the total records read and written.  

**User Flow Summary**  
A user initiates the restore by executing the program while a correctly named `invoice.seq` file is available. The program reads each record from that file, writes it to the target database file, and counts how many records it processes. Throughout, it logs progress and any errors to a system log file. After the run, the user can review the log to confirm that the expected number of invoices has been restored and to verify that no read or write errors occurred.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins by retrieving command line arguments, initializing logging parameters, and outputting a start message. [Seen in: aa000-Main-Start.]  
It then opens the source sequential invoice file for input, checks for errors, and opens a target file for output, aborting if either open fails. [Seen in: aa000-Main-Start.]  
The main loop reads each record from the source, writes it to the target file, updates counters, and on completion or error, closes files, logs totals, and exits. [Seen in: aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs Get-Program-Args, sets logging system and file numbers, and logs a header message. [Seen in: aa000-Main-Start.]  
It opens the input invoice file, verifies the status, then opens the output file, resetting record counters to zero before entering the processing loop. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read Loop  
Trigger: Successful read of a record from Invoice-File-Seq until end-of-file or error. [Seen in: aa010-Read-Recs.]  
Key steps: Read record, check FS-Reply, write to Invoice-File, check FS-Reply, increment input and output counters.  
I/O: Invoice-File-Seq (input), Invoice-File (output).  
Outcomes: updated counters, possible error messages leading to finish. [Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: End of file reached or any error during read/write causes jump to aa020-Finish-Off. [Seen in: aa020-Finish-Off.]  
Key steps: Close both files, log total records processed, set Return-Code to zero, and goback to terminate.  
I/O: close Invoice-File-Seq and Invoice-File.  
Outcomes: program termination with status zero. [Seen in: aa020-Finish-Off.]

5.4 Termination  
After closing files, the program logs a final message indicating the number of records read and written. [Seen in: aa020-Finish-Off.]  
It then sets the Return-Code to zero and performs a GOBACK to exit. [Seen in: aa020-Finish-Off.]

---
## slinvoiceUNL
*[236/267]*

### Business/Functional Perspective
### Invoice Unload Utility  

**Program Purpose**  
This program creates a backup of the current invoice data by copying all records from the existing invoice database file to a new sequential file named *invoice.seq*. It ensures that a reliable, portable copy of the invoice records is available for recovery, archival, or migration purposes. The backup operation logs progress and any problems to a system display log, providing traceability for audit and compliance needs.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
* Missing or unreadable source file – the program reports that no invoice file is available for processing.  
* Read error on the source file – the program logs the specific read problem and stops the backup.  
* Write error on the backup file – the program reports a failure to write the sequential file and stops.  
* Successful completion – the program reports the number of records read and written, followed by a final summary message.  
* System housekeeping messages such as “CLOSE” are also logged for completeness.  

**User Flow Summary**  
When the user runs the program, it begins by verifying the presence of the source invoice file. If the file exists, the program opens a new sequential file and iterates through each invoice record, writing it to the backup file. Throughout the process, the program records progress and any issues to the system display log. Once all records have been processed or an error occurs, the program closes both files, outputs a summary of records processed, and terminates.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins in **aa000-Main-Start**, retrieving command line arguments and initializing logging parameters. [Seen in: aa000-Main-Start.]  
It opens the source Invoice file for input, handling the case where the file is missing by logging a message and exiting. [Seen in: aa000-Main-Start.]  
The main processing loop in **aa010-Read-Recs** reads each record, writes it to a sequential output file, and tracks record counts, terminating when end‑of‑file or an error occurs. [Seen in: aa010-Read-Recs.]  
After the loop, **aa020-Finish-Off** closes both files, logs the total records processed, sets the return code, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to capture command line parameters and sets logging system and file numbers. [Seen in: aa000-Main-Start.]  
Working‑storage variables such as record counters and status flags are initialized to zero, and a message header is prepared for logging. [Seen in: aa000-Main-Start.]  
The input Invoice file is opened; if the status indicates the file does not exist, a log message is written and the program terminates early. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: **Read-Records**  
Trigger: Successful opening of input file and entering the read loop in **aa010-Read-Recs**.  
Key steps: Read each record, increment input counter, write to output file, increment output counter, check status after read and write.  
I/O: Invoice-File (input), Invoice-File-Seq (output).  
Outcomes: Record counts updated; on error, error message logged and loop exits to finish. [Seen in: aa010-Read-Recs.]

Path: **Read-Error**  
Trigger: FS-Reply non‑zero after a read operation in **aa010-Read-Recs**.  
Key steps: Construct error message with SY003 and FS-Reply, log via Call‑Sysout, exit loop to finish.  
I/O: Invoice-File.  
Outcomes: Error logged, processing stops, control goes to aa020-Finish-Off. [Seen in: aa010-Read-Recs.]

Path: **Write-Error**  
Trigger: FS-Reply non‑zero after a write operation in **aa010-Read-Recs**.  
Key steps: Set SO-Print to SY006, log via Call‑Sysout, exit loop to finish.  
I/O: Invoice-File-Seq.  
Outcomes: Error logged, processing stops, control goes to aa020-Finish-Off. [Seen in: aa010-Read-Recs.]

Path: **Input-File-Not-Found**  
Trigger: FS-Reply non‑zero immediately after opening Invoice-File in **aa000-Main-Start**.  
Key steps: Log "No Invoice file to process", close file, log close message, goback.  
I/O: Invoice-File.  
Outcomes: Program terminates without processing any records. [Seen in: aa000-Main-Start.]

Path: **Finish-Off**  
Trigger: End of file or any error causes go to **aa020-Finish-Off**.  
Key steps: Close both files, build summary message with record counts, log summary and close messages, set Return-Code to zero, goback.  
I/O: Invoice-File-Seq, Invoice-File.  
Outcomes: Files closed, counts reported, program exits cleanly. [Seen in: aa020-Finish-Off.]

5.4 Termination  
The program ensures both input and output files are closed, logs a final summary of records processed, and sets Return-Code to zero before exiting. [Seen in: aa020-Finish-Off.]  
The exit is performed via a GOBACK statement, returning control to the caller. [Seen in: aa020-Finish-Off.]

---
## slpostingLD
*[237/267]*

### Business/Functional Perspective
### SL Posting Table Load

**Program Purpose**  
The program loads the IRS Special/Letter (SL) Posting file into a MySQL database, creating the posting table used for later reporting. It reads the system configuration to obtain database credentials, then processes each record in the posting file, inserting it into the table or updating duplicates as required. The process is automated, ensuring the posting data is accurate and up‑to‑date for compliance and audit purposes. If any error occurs—such as missing files, database connection problems, or data conflicts—the program stops and reports the issue to the operator. When finished it prints a summary of records processed and any duplicates rewritten.

**Screen Interactions**  
No direct screens. This program is invoked after a separate data‑entry or batch step and returns its results to that context.

**Messages and Errors**  
- Failure to read the system configuration file.  
- Posting file not found or cannot be opened.  
- Problem reading the posting file (corrupt or incomplete data).  
- Error writing a record to the database.  
- Duplicate key detected – the record is skipped or rewritten.  
- General database error – program aborts.  
- Completion summary showing the number of records read, written, and rewritten.

**User Flow Summary**  
An operator launches the program (optionally with command‑line arguments). The program first obtains database connection details from a system configuration file. It then opens the SL posting file and begins processing each record. For every record, the program attempts to insert it into the MySQL table. If a duplicate key is encountered, it rewrites the existing record and counts it as a rewrite. Any read or write errors are reported immediately, and the program terminates if a critical error occurs. After all records are processed, the program prints a final message summarizing how many records were read, written, and rewritten, and it closes the database and posting files.

**Program Linkages**  
- acas-get-params  
- acas008  
- ACAS-Sysout  
- MySQL_rollback  
- MySQL_commit

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph **aa000-main-start**, performing argument parsing and initial logging. [Seen in: aa000-main-start.]  
It opens the system parameter file, reads the first record, and loads RDB configuration, invoking **acas-get-params** if necessary. [Seen in: aa000-main-start.]  
After configuration, it opens the COBOL posting file and the RDB via **acas008**, then enters the main read‑write loop in **aa010-Read**. [Seen in: aa010-Proc-Override.]

5.2 Initialization  
The program performs **zz020-Get-Program-Args** to capture command line arguments and logs the program name via **Call‑Sysout**. [Seen in: aa000-main-start.]  
It opens the system parameter file, reads the first record, and validates the RDB configuration, invoking **acas-get-params** if the RDB fields are missing. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: **File Open and RDB Initialization**  
Trigger: start of program after system file read.  
Key steps: set file‑system flags, call **acas008-Open-Input** to open the posting file, handle FS‑Reply 35 (no file), call **acas008-Open** to open the RDB, then go to **aa010-Read**.  
I/O: System‑File, posting file (via acas008‑Open‑Input), RDB (via acas008‑Open).  
Outcomes: sets File‑System‑Used flags, prepares for processing.  
[Seen in: aa010-Proc-Override.]

Path: **Main Record Processing Loop**  
Trigger: **aa010-Read** loop.  
Key steps: read next posting record, if EOF go to **aa999-Finish**, else write to RDB, handle duplicate key, increment counters, loop.  
I/O: posting file read, RDB write.  
Outcomes: counters updated, duplicates rewritten, errors handled.  
[Seen in: aa010-Read.]

Path: **Duplicate Key Handling**  
Trigger: SQL‑State = "23000" or FS‑Reply 22 or 99 or SQL‑Err 1062/1022.  
Key steps: reset FS‑Reply and WE‑Error, rewrite record via **acas008-Rewrite**, increment rewrite counter, continue loop.  
I/O: RDB rewrite.  
Outcomes: duplicate records rewritten, counters updated.  
[Seen in: aa010-Read.]

Path: **Error Handling and Rollback**  
Trigger: fs‑reply not zero after write.  
Key steps: log error messages, call **MySQL_rollback**, set return‑code, finish.  
I/O: RDB write error, rollback call.  
Outcomes: error logged, program exits.  
[Seen in: aa010-Read, aa020-Rollback.]

Path: **Program Termination**  
Trigger: **aa999-Finish**.  
Key steps: log final record counts, close RDB, close system file, close posting file, log EOJ, goback.  
I/O: system file close, posting file close, RDB close.  
Outcomes: program ends.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program logs final record counts, closes the RDB and system files, and exits via goback. [Seen in: aa999-Finish.]  
A final EOJ message is printed and the program terminates. [Seen in: aa999-Finish.]

---
## slpostingMT
*[238/267]*

### Business/Functional Perspective
### IRS Posting Database Handler  

**Program Purpose**  
The program provides a secure, database‑centric interface for creating, reading, updating and deleting IRS posting records. It guarantees that each record is valid, uniquely identified and properly logged, supporting audit trails and regulatory compliance for the ACAS accounting system. By handling all file‑access logic internally, it reduces the risk of data corruption and ensures consistent behaviour across modules that rely on the postings table.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – The requested operation completes without issue.  
- **No data / end of file** – When a read returns no rows, an “end‑of‑file” status is returned.  
- **Record not found** – If a requested key does not exist, a “not found” status is returned.  
- **Duplicate key** – Attempts to insert a record with an existing key result in a duplicate‑key status.  
- **Invalid key or key range** – Supplying a key outside the defined range produces an invalid‑key status.  
- **Database error** – Any SQL or connection error returns a generic error status with details supplied by the database.  
- **Bad function or parameter** – Calling the program with an unsupported function or bad parameters yields an error status.  

**User Flow Summary**  
A calling module supplies an IRS posting record and indicates the desired action through the *File‑Function* parameter: open, close, read next, read by key, write, delete, delete‑all or rewrite. The handler interacts with the underlying database, performing the requested operation. It then places the resulting record (if any) back into the caller’s data buffer and sets status codes that indicate success, end‑of‑file, record not found, duplicate key, or a database error. The calling module can then decide how to present the result or error to the end user.  

**Program Linkages**  
- MySQL_errno  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in the entry paragraph **ba-ACAS-DAL-Process**, where it routes the request to one of several processing paragraphs based on the **File-Function** value. After performing the requested database operation (open, close, read, write, delete, etc.), control returns to **ba999-End** for final cleanup and exit. The exit paragraph **ba999-Exit** terminates the program with an `EXIT PROGRAM`. [Seen in: ba-ACAS-DAL-Process.]

5.2 Initialization  
The **ba010-Initialise** paragraph sets up screen exception handling, clears error and status fields, and prepares environment variables for logging. It also performs an initial `PERFORM MYSQL-1000-OPEN` to establish the database connection when the open function is requested. [Seen in: ba010-Initialise.]  
The **ba020-Process-Open** paragraph constructs the database connection parameters, calls the MySQL open routine, and records the file key for logging. [Seen in: ba020-Process-Open.]

5.3 Core Processing  

Path: Process-Open  
Trigger: File-Function = 1  
Key steps: Build connection strings, perform `MYSQL-1000-OPEN`, set `WS-File-Key` to "OPEN SLIRSPOSTING".  
I/O: MySQL connection (no table).  
Outcomes: `FS-Reply` set to 0 on success; `WS-File-Key` logged. [Seen in: ba020-Process-Open.]

Path: Process-Read-Next  
Trigger: File-Function = 3 (Read-Next) and no active cursor.  
Key steps: Build SELECT query with key >= "0000000000", execute `MYSQL-1210-COMMAND`, store result, fetch first row, unload HVs to record.  
I/O: PSIRSPOST-REC table.  
Outcomes: `FS-Reply` 0, `WE-Error` 0, `WS-File-Key` set to record key; cursor active (`Most-Cursor-Set` = 1). [Seen in: ba040-Process-Read-Next.]

Path: Process-Read-Indexed  
Trigger: File-Function = 4 (Read-Indexed).  
Key steps: Build SELECT query for exact key, execute, fetch row, unload HVs.  
I/O: PSIRSPOST-REC table.  
Outcomes: `FS-Reply` 0, `WE-Error` 0, `WS-File-Key` set; if no row, `FS-Reply` 21 and cursor freed. [Seen in: ba050-Process-Read-Indexed.]

Path: Process-Write  
Trigger: File-Function = 5 (Write).  
Key steps: Load HVs from record, build INSERT statement, execute `MYSQL-1210-COMMAND`, check row count, handle duplicate key error.  
I/O: PSIRSPOST-REC table.  
Outcomes: `FS-Reply` 0 on success, 22 on duplicate key, `WE-Error` 99 on other SQL error. [Seen in: ba070-Process-Write.]

Path: Process-Delete  
Trigger: File-Function = 8 (Delete).  
Key steps: Build DELETE WHERE key = value, execute, check affected rows, set status.  
I/O: PSIRSPOST-REC table.  
Outcomes: `FS-Reply` 0 on success, 99 on error, `WE-Error` 995 on SQL error. [Seen in: ba080-Process-Delete.]

Path: Process-Delete-ALL  
Trigger: File-Function = 6 (Delete-ALL).  
Key steps: Build DELETE WHERE key < keyvalue, execute, handle errors, log.  
I/O: PSIRSPOST-REC table.  
Outcomes: `FS-Reply` 0 on success, 99 on error, `WE-Error` 995 on SQL error. [Seen in: ba085-Process-Delete-ALL.]

5.4 Termination  
The **ba998-Free** paragraph frees any active MySQL result set and resets cursor state.  
The **ba999-End** paragraph performs optional logging via `Ca-Process-Logs` and then transfers control to **ba999-Exit**, which terminates the program with `EXIT PROGRAM`. [Seen in: ba998-Free, ba999-End, ba999-Exit.]

---
## slpostingRES
*[239/267]*

### Business/Functional Perspective
### Posting File Restore  

**Program Purpose**  
This utility restores posting records to the main data file from a sequential backup file. It reads each record from the backup, writes it into the database file, and reports the number of records processed. The process ensures that a missing or corrupted backup is detected early, allowing the user to correct the issue before the database is rebuilt. By recording progress and any failures, the program supports auditability and reduces the risk of data loss.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the backup file cannot be found or opened, a message stating “No slposting file to process” is issued.  
- If the main posting file cannot be opened for writing, a message describing the failure is logged.  
- During processing, any read or write error triggers a brief notification (e.g., “Problem reading slposting file” or “Write error on .dat file”).  
- If required environment variables are missing, the program aborts with a notice that the environment is not set up.  

**User Flow Summary**  
The user runs the restore utility from a command line or job scheduler. The program first checks for the existence of the backup file “postings2irs.seq”. If it is absent, the user receives a notice that there is nothing to process. If present, the program opens the backup for reading and the target posting file for writing. It then reads each record from the backup, writes it to the target file, and keeps a running count of records processed. Any error encountered stops the process and logs an explanatory message. When all records are handled or an error occurs, the program logs a final summary of records read and written, closes both files, and exits.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command line arguments and initializing logging parameters before opening the input postings file. [Seen in: aa000-Main-Start.]  
It then opens the output file for writing and enters a loop that reads each record from the input file, writes it to the output file, and updates record counters. [Seen in: aa010-Read-Recs.]  
Upon reaching the end of the input file or encountering an error, the program closes both files, logs a summary of records processed, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs a call to zz020-Get-Program-Args to capture command line arguments and sets logging system identifiers. [Seen in: aa000-Main-Start.]  
It initializes working storage counters to zero and prepares a message string for logging. [Seen in: aa000-Main-Start.]  
The input file IRS-Post-File-Seq is opened for input; if the open fails, an error message is logged and the program terminates. [Seen in: aa000-Main-Start.]  
The output file IRS-Post-File is opened for output; a failure results in an error message and program termination. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Input File Open  
Trigger: Program start before reading records.  
Key steps: open input file, check FS-Reply, log error if not zero, close file, goback.  
I/O: IRS-Post-File-Seq  
Outcomes: program exits if open fails.  
[Seen in: aa000-Main-Start.]

Path: Output File Open  
Trigger: After successful input file open.  
Key steps: open output file, check FS-Reply, log error if not zero, close file, goback.  
I/O: IRS-Post-File  
Outcomes: program exits if open fails.  
[Seen in: aa000-Main-Start.]

Path: Record Transfer Loop  
Trigger: Each iteration of aa010-Read-Recs.  
Key steps: read next record, check FS-Reply, write record to output, check FS-Reply, increment counters, loop until end or error.  
I/O: IRS-Post-File-Seq, IRS-Post-File  
Outcomes: counters updated, possible early exit on error.  
[Seen in: aa010-Read-Recs.]

Path: Finish Off  
Trigger: go to aa020-Finish-Off after loop or error.  
Key steps: close both files, build summary string, log summary, set Return-Code to zero, goback.  
I/O: IRS-Post-File-Seq, IRS-Post-File  
Outcomes: program terminates normally.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes both the input and output files, logs a summary of records processed, sets the return code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]  
Any earlier error causes the program to log an error message, close any opened files, and exit immediately. [Seen in: aa000-Main-Start.]

---
## slpostingUNL
*[240/267]*

### Business/Functional Perspective
### SL Posting File Backup  

**Program Purpose**  
This program creates a backup copy of the SL posting ISAM file by exporting all its records into a sequential file named *postings2irs.seq*. It logs each step of the process, including any read or write errors, and reports the total number of records handled. The backup ensures that posting data can be recovered or transported easily, supporting audit trails and data integrity.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the source SL posting file is missing or cannot be opened, the program logs “No slposting file to process.”  
- When a record cannot be read, the program logs “Problem reading slposting file = [error description].”  
- If a record cannot be written to the backup file, the program logs “Write error on .seq file.”  
- Upon successful completion it logs the total number of records read and written.  

**User Flow Summary**  
The user initiates the program (typically via a command line or job scheduler). The program scans the SL posting ISAM file, copies each record sequentially into the backup file, and writes status messages to the system log. If any file‑access issue arises, a descriptive message is logged and the program stops. After completion, the log shows how many records were processed, allowing the user to verify that the backup was created successfully.  

**Program Linkages**  
- ACAS‑Sysout  

---

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts at aa000-Main-Start, retrieves command line arguments and logs a start message. [Seen in: aa000-Main-Start.]  
It opens the source slposting file for input, verifies accessibility, then opens a sequential output file for writing. [Seen in: aa000-Main-Start.]  
The program enters a loop that reads each record from the input file, writes it to the output file, and tracks record counts until EOF or an error occurs. [Seen in: aa010-Read-Recs.]  
Upon completion or error, it closes both files, logs a summary of records processed, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture command line arguments. [Seen in: aa000-Main-Start.]  
It sets logging parameters (WS-Log-System and WS-Log-File-no) and writes an initial message via Call-Sysout. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read and Write Records  
Trigger: Entry to aa010-Read-Recs loop. [Seen in: aa010-Read-Recs.]  
Key steps: Read next record from IRS-Post-File; if FS-Reply indicates error, log and exit; increment input counter; write record to IRS-Post-File-Seq; if write error, log and exit; increment output counter; repeat until end of file. [Seen in: aa010-Read-Recs.]  
I/O: IRS-Post-File (input), IRS-Post-File-Seq (output). [Seen in: aa010-Read-Recs.]  
Outcomes: ws-Rec-Cnt-In and ws-Rec-Cnt-Out updated; potential error messages logged; on error or EOF, control transfers to aa020-Finish-Off. [Seen in: aa010-Read-Recs.]

Path: Finish-Off  
Trigger: Exit from aa010-Read-Recs due to EOF or error. [Seen in: aa020-Finish-Off.]  
Key steps: Close IRS-Post-File-Seq and IRS-Post-File; build summary string with record counts; log summary via Call-Sysout; set Return-Code to zero; goback. [Seen in: aa020-Finish-Off.]  
I/O: None (file handles already closed). [Seen in: aa020-Finish-Off.]  
Outcomes: Program terminates with Return-Code zero and logs completion. [Seen in: aa020-Finish-Off.]

Path: Get Program Args  
Trigger: Initial perform of zz020-Get-Program-Args. [Seen in: aa000-Main-Start.]  
Key steps: Capture command line arguments into Arg-Vals and Arg-Test. [Seen in: aa000-Main-Start.]  
I/O: None. [Seen in: aa000-Main-Start.]  
Outcomes: Arg-Vals populated for later use. [Seen in: aa000-Main-Start.]

Path: Call-Sysout  
Trigger: Any perform Call-Sysout. [Seen in: aa000-Main-Start, aa020-Finish-Off.]  
Key steps: Call external routine ACAS-Sysout with SO-Print. [Seen in: Call-Sysout.]  
I/O: None. [Seen in: Call-Sysout.]  
Outcomes: Message written to SYS-DISPLAY.log. [Seen in: Call-Sysout.]

5.4 Termination  
The program closes the sequential output file and the input file, logs a final message, sets Return-Code to zero, and performs goback to terminate. [Seen in: aa020-Finish-Off.]

---
## st000
*[241/267]*

### Business/Functional Perspective
### Stock Control Start Of Day

**Program Purpose**  
This program prepares the stock control system for a new business day by collecting the current date and time from the operator. It verifies that the supplied date is valid, converts it into a standard internal format, and stores the information for use by subsequent inventory and accounting processes. Accurate date entry is essential for daily inventory reconciliation, financial reporting, and compliance with audit requirements.

**Screen Interactions**  
1. **Header Screen** – Displays:  
   - “Client –” followed by the client identifier.  
   - The operator’s user name.  
   - Program name “ST000 (3.02.04)”.  
   - Title “Stock Control - Start Of Day”.  
   - A serial number from `maps-ser-xx`.  
2. **Date Prompt** – Shows one of the following prompts at the same screen location:  
   - “Enter todays date as dd/mm/yyyy - [          ]” (UK format).  
   - “Enter todays date as mm/dd/yyyy - [          ]” (USA format).  
   - “Enter todays date as yyyy/mm/dd - [          ]” (International format).  
   The operator types the date into the highlighted field.  
3. **Time Display** – If a current time is supplied, it appears as “at hh:mm:ss” just below the date entry.

**Messages and Errors**  
- If the entered date cannot be validated, the message “ST005 Invalid Date” is shown, and the program returns to the date entry prompt.  
- No other user‑visible error messages are produced by this program.

**User Flow Summary**  
The operator launches the Stock Control Start‑of‑Day routine and is presented with a screen that identifies the client, user, and program. The operator then enters the current date in the format appropriate for the system’s configuration. The program validates the date; if it is invalid, an error message appears and the operator is prompted to re‑enter the date. Once a valid date is accepted, the routine records the date and time and proceeds to the next stage of the stock control process (not shown in this program). The operator is then returned to the surrounding application with the new start‑of‑day information available.

**Program Linkages**  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins execution in paragraph aa010‑main, where it initializes the screen environment, receives the system date and time, and displays the header information. [Seen in: aa010-main.]  
It then transfers control to paragraph aa020‑Date‑Entry to prompt the user for today’s date, perform format conversion, validate the date, and handle any errors. [Seen in: aa020-Date-Entry.]  
Upon successful validation the program bypasses security checks, sets run‑date and other control variables, and finally exits via paragraph aa999‑Exit. [Seen in: aa030-Chain-Menu.]

5.2 Initialization  
Paragraph aa010‑main sets screen exception flags, moves the incoming date to the working‑storage date field, and accepts the current system date and time from the host. [Seen in: aa010-main.]  
It displays the client, program name, and stock control banner, then accepts the user‑entered date and time, converting them into the internal format before proceeding. [Seen in: aa010-main.]

5.3 Core Processing  
Path: Date Entry & Validation  
Trigger: User enters a date at paragraph aa020‑Date‑Entry.  
Key steps: Accept the date, convert between UK/USA/Intl formats, call the external routine maps04 to validate the date, and display an error message if validation fails.  
I/O: Uses the working‑storage fields u‑date and u‑bin; no external files are accessed.  
Outcomes: Sets u‑bin to zero on failure (causing a repeat of the date entry) or leaves u‑bin non‑zero to continue. [Seen in: aa020-Date-Entry.]

Path: Security Bypass  
Trigger: Successful date validation leads to a direct jump to paragraph aa030‑Chain‑Menu.  
Key steps: Assign u‑bin to run‑date, copy u‑date to to‑day, and reset ws‑term‑code.  
I/O: No external I/O; only internal variable assignments.  
Outcomes: Prepares control variables for the next phase and bypasses the commented‑out security routine. [Seen in: aa030-Chain-Menu.]

Path: Chain Menu  
Trigger: Execution reaches paragraph aa030‑Chain‑Menu.  
Key steps: Re‑establish run‑date, to‑day, and ws‑term‑code values, then immediately transfer control to the exit paragraph.  
I/O: None.  
Outcomes: Finalizes control variables before program termination. [Seen in: aa030-Chain-Menu.]

Path: Exit  
Trigger: Paragraph aa999‑Exit is invoked.  
Key steps: Execute the `EXIT PROGRAM` statement to terminate the program.  
I/O: None.  
Outcomes: Program ends cleanly with the current state of all working‑storage variables. [Seen in: aa999-Exit.]

5.4 Termination  
The program concludes by executing the `EXIT PROGRAM` statement in paragraph aa999‑Exit, which terminates the process and returns control to the host environment. [Seen in: aa999-Exit.]

---
## st010
*[242/267]*

### Business/Functional Perspective
### Stock Item File Maintenance  

**Program Purpose**  
The program manages the stock item file for a business. It lets users create, amend, delete, renumber, view, and print stock records. By validating all entered data—including supplier codes, dates, and pricing—the program ensures that stock records are accurate and complete, which supports inventory control, accurate reporting, and compliance with accounting rules.  

**Screen Interactions**  

1. **Main Function Menu** – Displays options:  
   - (1) Set‑up Stock records  
   - (2) Amend Stock records  
   - (3) Delete Stock records  
   - (4) Renumber Stock records  
   - (5) Display Stock records  
   - (6) Print Stock records  
   - (9) Return to System Menu  

2. **Stock Record Entry/Edit Screen (Display‑01)** – Inputs for:  
   - Stock Number, PL Fast key, Description, Stock Location  
   - Supplier 1–3, Stock Qty, Qty Ordered, Re‑Order Point, Back Ordered, Re‑Order Qty, Sales Orders O/S  
   - Sales Anal. Code, Purch Anal. Code, Services‑Only flag, Date Ordered, Date Due  
   - Escape functions: B = Back, S = Save, Q = Quit; F3 launches supplier setup  

3. **Price Input Screen (Display‑01B)** – Enter Retail Price, Cost Price, and Stock Value (used when prices change).  

4. **Price Display Screen (Display‑01C)** – Shows Retail Price, Cost Price, and Stock Value (no input).  

5. **Work‑In‑Progress Screen (Display‑02)** – Optional data for items in construction: Construct Bundle, Construction, Work‑In‑Progress, Construct Item.  

6. **Stock Display Screen (Display‑F1‑Display)** – Enter a stock number (or “*” for all) and view the corresponding record(s). Navigation: N = Next, S = Show.  

7. **Delete Confirmation Prompt** – Asks for Y/N before deleting a record.  

**Messages and Errors**  

- **Invalid or missing data** – prompts for required fields, correct dates, and valid supplier or analysis codes.  
- **Duplicate or non‑existent records** – alerts when a stock number or abbreviation already exists or cannot be found.  
- **Operation failures** – reports problems writing to or deleting from the stock file, or errors with the purchase ledger or analysis tables.  
- **System errors** – notifies if the stock file is missing or cannot be accessed.  
- **Success notices** – confirms that a record was created, updated, deleted, renumbered, displayed, or printed.  
- **Confirmation prompts** – asks the user to confirm destructive actions (e.g., delete, renumber).  

**User Flow Summary**  

A user starts by selecting a function from the main menu.  
- *Set‑up* prompts for all required stock details, validates each field, and writes a new record.  
- *Amend* retrieves an existing record, lets the user modify any field (with the same validation), and rewrites it.  
- *Delete* shows the record, checks that no dependent quantities exist, and, after confirmation, removes it.  
- *Renumber* allows changing the stock number and abbreviation, then updates the file and deletes the old entry.  
- *Display* lets the user view one or all stock records sequentially, with navigation controls.  
- *Print* generates a formatted report that is sent to the print spool, and the user receives a notification when printing starts.  

Throughout, the program ensures that supplier codes exist in the purchase ledger, that analysis codes are valid, and that dates are properly formatted. It prevents changes that would leave the record inconsistent, and it provides clear feedback for every success or failure.  

**Program Linkages**  

- maps04  
- maps09  
- pl010  
- sl070  
- CBL_CHECK_FILE_EXIST  
- CBL_DELETE_FILE  
- scr_dump  
- scr_restore  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program begins in aa000-Core, initializing environment variables, screen exception handling, and setting up the print spool name and temporary screen file. [Seen in: aa000-Core.]  
It then displays the main menu in aa010-Menu-Return and accepts the user's choice in aa020-Menu-Input. [Seen in: aa010-Menu-Return, aa020-Menu-Input.]  
Depending on the selection, control transfers to one of the operation sections (ba000-Setup-Stock, ca000-Amend-Stock, da000-Delete-Stock, ga000-Renumber-Stock, fa000-Display-Stock, or ea000-Report-Stock) which perform the requested stock maintenance task. [Seen in: ba000-Setup-Stock, ca000-Amend-Stock, da000-Delete-Stock, ga000-Renumber-Stock, fa000-Display-Stock, ea000-Report-Stock.]  
After completing an operation, the program returns to aa010-Menu-Return to allow another action or exits via aa999-Exit when the user selects return to system menu. [Seen in: aa010-Menu-Return, aa999-Exit.]

5.2 Initialization  
The program accepts environment line count, sets screen exception flags, and initializes the print spool name and temporary screen file path. [Seen in: aa000-Core.]  
It checks whether the stock file exists using CBL_CHECK_FILE_EXIST; if the file is missing, it forces a setup of stock data by performing ba000-Setup-Stock. [Seen in: aa000-Core.]  
No other files are opened at startup; file access is deferred to the specific operation sections. [Seen in: aa000-Core.]

5.3 Core Processing  
Path: Setup Stock Records  
Trigger: User selects menu option 1.  
Key steps: Open purchase, stock, and analysis files; check stock file existence; set Stock-Control; display headings; accept stock key and abbreviation; verify uniqueness; accept data fields; validate dates; write new record; loop for additional entries.  
I/O: Stock-File, Purch-File, Anal-File.  
Outcomes: New stock record created, stock file updated, status flags set.  
[Seen in: ba000-Setup-Stock, ba020-Stock-Item-Accept, ba030-Stock-Abrev-Item-Accept, ba040-Accept-Block, ba050-Main-Output.]

Path: Amend Stock Records  
Trigger: User selects menu option 2.  
Key steps: Open purchase, stock, and analysis files; read existing record; display current values; accept updated data; validate dates; rewrite record; loop for additional amendments.  
I/O: Stock-File, Purch-File, Anal-File.  
Outcomes: Existing stock record updated, status flags set.  
[Seen in: ca000-Amend-Stock, ca020-Stock-Item-Accept, ca030-Get-Record, ca040-Accept-Block, ca050-Main-Output.]

Path: Delete Stock Records  
Trigger: User selects menu option 3.  
Key steps: Open stock file; read record; check for non‑zero quantity or order values; confirm deletion; delete record; loop for additional deletions.  
I/O: Stock-File.  
Outcomes: Stock record removed, status flags set.  
[Seen in: da000-Delete-Stock, da020-Stock-Item-Accept, da030-Get-Record, da040-Accept-Delete.]

Path: Renumber Stock Records  
Trigger: User selects menu option 4.  
Key steps: Open stock file; read record; accept new stock number and abbreviation; write new record; delete old record; loop for additional renumbering.  
I/O: Stock-File.  
Outcomes: Stock record renamed, status flags set.  
[Seen in: ga000-Renumber-Stock, ga020-Stock-Item-Accept, ga030-Get-Record, ga040-Accept-New-Stock-No, ga050-Accept-Renumber.]

Path: Display Stock Records  
Trigger: User selects menu option 5.  
Key steps: Open stock file; accept key or "*" for all records; read sequentially; display each record; handle escape to exit.  
I/O: Stock-File.  
Outcomes: Stock records displayed to the user.  
[Seen in: fa000-Display-Stock, fa020-Stock-Item-Accept, fa030-Get-Record.]

Path: Report Stock Records  
Trigger: User selects menu option 6.  
Key steps: Open stock file and print file; iterate through all stock records; write formatted report lines; close files; invoke system print command.  
I/O: Stock-File, Print-File.  
Outcomes: Full stock report printed, record count displayed.  
[Seen in: ea000-Report-Stock, ea200-Produce-Report, ea210-Read-Stock, ea220-Heads, ea230-Totals.]

5.4 Termination  
After completing an operation, the program closes any open files (Stock, Purchase, Analysis) and returns to the main menu; selecting option 9 triggers aa999-Exit which exits the program. [Seen in: aa999-Exit, ba999-Exit, ca999-Exit, da999-Exit, ga999-Exit, fa999-Exit, ea999-exit.]

---
## st020
*[243/267]*

### Business/Functional Perspective
### Stock Item Additions & Deletions  

**Program Purpose**  
The program lets users manually adjust inventory levels by adding or removing items, process barcode scans for quick restocking, update purchase order details, and run end‑of‑month audit reports. It ensures that all changes are recorded in the audit trail, keeps stock quantities within allowed limits, and protects against accidental updates to services‑only products. By maintaining accurate stock data and audit information, the program supports reliable inventory reporting, compliance with accounting procedures, and reduces the risk of stock‑management errors.  

**Screen Interactions**  
1. **Stock Movements Menu** – Title: “Stock Movements Menu”  
   * Options displayed:  
     * (1) Stock Additions Entry  
     * (2) Stock Deductions Entry  
     * (3) Stock Barcode Additions Entry  
     * (4) Stock Order Entry  
     * (5) Stock End‑of‑Month Processing (if audit file is present)  
     * (9) Return to System Menu  
   * User selects an option by entering the corresponding number.  

2. **Stock Addition Screen** – Title: “Stock Additions Entry”  
   * Prompts for: Stock Number, auto‑displayed description, Quantity to add, Unit price.  
   * Shows current stock quantity and value, updated values after entry, and any warnings (e.g., quantity limits).  

3. **Stock Deduction Screen** – Title: “Stock Deductions Entry”  
   * Similar layout to the addition screen but for subtracting quantity.  

4. **Barcode Addition Screen** – Title: “Stock Barcode Additions Entry”  
   * User scans a barcode; the system looks up the item, displays the description, quantity, and price, then updates stock and shows the new quantity/value.  

5. **Order Entry Screen** – Title: “Stock Orders Update”  
   * Prompts for Stock Number, description, Quantity on Order, Date Ordered, Date Due, Back‑ordered quantity.  
   * Allows the user to edit these values and updates the stock order record.  

6. **End‑of‑Month Processing Screen** – Title: “Stock End‑of‑Month Processing”  
   * Asks for confirmation to delete the audit file after reports have been generated.  

7. **Report Print Screens** – Title: “Stock Addition Report” / “Stock Deduction Report” / “Stock Audit Report”  
   * Shows printed or spooled report lines; the user sees a confirmation that the report has been printed or is queued.  

**Messages and Errors**  
- **File access errors** – notifications if the stock file or audit file cannot be opened or written to.  
- **Invalid stock number** – alerts when the entered stock number does not exist or is abbreviated incorrectly.  
- **Quantity limits** – warnings if a quantity entered would exceed the maximum allowed (999 999) or would drop stock below zero.  
- **Services‑only product** – messages that the product is services‑only and cannot be added or deducted.  
- **Price and value warnings** – alerts when the new stock value would exceed the maximum or fall below the minimum, or when a zero quantity update is about to occur.  
- **Date validation** – errors for improperly formatted or impossible dates entered for order or due dates.  
- **Back‑order file** – notification if the back‑order file cannot be opened or written to.  
- **Audit file status** – messages indicating whether the audit file has been created, is missing, or is ready for processing.  
- **Deletion confirmation** – prompt requiring the user to confirm that the audit file may be deleted.  

**User Flow Summary**  
When the program starts, the user is presented with a menu of stock‑movement options. Choosing an option opens a screen where the user enters the relevant data: for additions or deductions, the user types the stock number, quantity, and price; for barcode additions, a scan automatically supplies the data; for order updates, the user can edit quantity on order, dates, and back‑order details. The program validates the input, updates the stock record, writes an audit entry if auditing is enabled, and displays the new stock quantity and value. After each operation, the user returns to the menu. Selecting “End‑of‑Month Processing” triggers report generation for additions, deductions, and audit data, then optionally deletes the audit file after user confirmation. Throughout the process, the user receives clear prompts and error messages, and any printed reports are queued or printed automatically.  

**Program Linkages**  
- CBL_CHECK_FILE_EXIST  
- maps04  
- SYSTEM

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa000-Core, performing environment checks, opening the stock file, and initializing variables. [Seen in: aa000-Core.]  
In aa100-Main-Menu the program determines whether to auto‑run the audit report or present the manual menu, based on command‑line arguments. [Seen in: aa100-Main-Menu.]  
aa107-Main-Menu-Start displays the stock movement menu and waits for user selection, looping in aa110-Accept-Loop until a valid choice is made. [Seen in: aa107-Main-Menu-Start, aa110-Accept-Loop.]  
aa120-Bypass-Accept-1 opens the audit file if required and dispatches to the appropriate processing routine based on the menu reply, then returns to aa010-Display-Headings for the next operation. [Seen in: aa120-Bypass-Accept-1, aa010-Display-Headings.]  
The program terminates via aa999-Exit, closing files and performing any final cleanup. [Seen in: aa999-Exit.]

5.2 Initialization  
The program sets environment variables, checks for the existence of the stock file, and opens it using Stock-Open. [Seen in: aa000-Core.]  
It initializes screen layout, menu reply, and period descriptors, and converts the current date for display. [Seen in: aa000-Core.]

5.3 Core Processing  

Path: Audit Report  
Trigger: WS-CD-Args (6:1) = "5" and Stk-Audit-Used = 1 (auto‑run) or Menu-Reply = 5 (manual)  
Key steps: set Menu-Reply 5, open audit file, call ea000-Process-End-of-Month, close audit file, exit  
I/O: Stock file (already open), Audit file (open, read, write), Print file (open, write)  
Outcomes: prints audit report, sets Stk-Activity-Rep-Run to 1, increments Stk-Audit-No, closes files, exits  
[Seen in: aa100-Main-Menu, aa120-Bypass-Accept-1, ea000-Process-End-of-Month.]

Path: Manual Stock Additions  
Trigger: Menu-Reply = 1  
Key steps: call ba000-Process-Manual-Additions: display headings, accept stock number, read stock record, validate services flag, accept quantity, accept price, update stock record, write audit record, print transaction, loop  
I/O: Stock file, Audit file, Print file  
Outcomes: stock quantity increased, stock value updated, audit record written, print line  
[Seen in: aa120-Bypass-Accept-1, ba000-Process-Manual-Additions, ba010-Accept-Data1, ba020-Accept-Qty, ba030-Accept-Price, ba040-Setup-Print-Transaction.]

Path: Manual Stock Deductions  
Trigger: Menu-Reply = 2  
Key steps: call ca000-Process-Manual-Deductions: display headings, accept stock number, read stock record, validate services flag, accept quantity, accept price, update stock record, write audit record, print transaction, loop  
I/O: Stock file, Audit file, Print file  
Outcomes: stock quantity decreased, audit record written, print line  
[Seen in: aa120-Bypass-Accept-1, ca000-Process-Manual-Deductions, ca010-Accept-Data1, ca020-Accept-Qty, ca030-Accept-Price, ca040-Setup-Print-Transaction.]

Path: Barcode Additions  
Trigger: Menu-Reply = 3  
Key steps: call da000-Process-Barcode-Additions: accept barcode (stock number), read stock record, validate services flag, accept price (or use last cost), update stock record, write audit record, print transaction, loop  
I/O: Stock file, Audit file, Print file  
Outcomes: stock quantity increased by 1, audit record written, print line  
[Seen in: aa120-Bypass-Accept-1, da000-Process-Barcode-Additions, da010-Accept-Data1, da030-Accept-Price, da040-Setup-Print-Transaction.]

Path: Order Entry  
Trigger: Menu-Reply = 4  
Key steps: call fa000-Process-Orders: display headings, accept stock number, accept quantity ordered, accept dates, update stock record with order details, print transaction, loop  
I/O: Stock file, Print file  
Outcomes: stock record updated with order details, print line  
[Seen in: aa120-Bypass-Accept-1, fa000-Process-Orders, fa010-Accept-Data1, fa020-Accept-Qty, fa030-Accept-Date-Ord, fa040-Accept-Date-Due, fa050-Accept-B-ord, fa060-Setup-Print-Transaction.]

5.4 Termination  
The program exits via aa999-Exit, closing the stock file, audit file, and any open printer, then performing a GOBACK. [Seen in: aa999-Exit.]  
If invoked with auto‑run arguments, the program terminates immediately after printing the audit report. [Seen in: aa120-Bypass-Accept-1, aa999-Exit.]

---
## st030
*[244/267]*

### Business/Functional Perspective
### Stock Control Reporting

**Program Purpose**  
This program creates a variety of stock‑control reports that help managers see the current value, activity, reorder status, history, and detailed lists of inventory items. It pulls data from the central stock file and formats it for printing or spooling. The reports support compliance and inventory‑management decisions by providing accurate, up‑to‑date information on stock levels, valuation, and ordering needs.

**Screen Interactions**  
1. **Main Menu** – Displays options 1‑9:  
   * 1 – Valuation Report  
   * 2 – Activity Report  
   * 3 – Re‑Order Report  
   * 4 – Stock History Report  
   * 5 – Stock Report (by number/abbreviation)  
   * 6 – Stock Report by Description  
   * 7 – Stock Report by Location  
   * 9 – Return to System Menu  
   The user selects a number and presses return.  

2. **Report‑Selection Screens** – Depending on the chosen report, the program shows one of the following screens for input:  
   * **Valuation Screen** – Prompts for optional ranges of stock number or abbreviated stock number.  
   * **Activity Screen** – Prompts for optional ranges of stock number or abbreviation, plus a sub‑menu for selecting “All”, “Current Period”, “To Date”, or ranges.  
   * **Re‑Order Screen** – Prompts for ranges and sub‑options for all items, understocked, not in stock, or on order.  
   * **History Screen** – Prompts for optional ranges of stock number or abbreviation.  
   * **Stock Report Screens (by number/abbreviation, by description, by location)** – Each screen asks for optional ranges and, where applicable, location details and page‑break preferences.  

3. **Confirmation Prompt** – If the user enters both stock number and abbreviation ranges or if a range is invalid, a message is shown and the screen is redisplayed for correction.  

**Messages and Errors**  
- *Missing Stock File* – Informs the user that the stock file cannot be located and halts the program.  
- *No Stock Numbers in Range* – Indicates that no stock items match the supplied number range.  
- *No Abbreviation Numbers in Range* – Indicates that no items match the abbreviation range.  
- *Cannot Specify Both Stock and Abbreviation* – Alerts that the user must choose either stock numbers or abbreviations, not both.  
- *Invalid Stock Range* – Warns that the “from” value is greater than the “to” value for stock numbers.  
- *Invalid Abbreviation Range* – Warns that the abbreviation “from” value is greater than the “to” value.  
- *Location Not Found* – Signals that the entered location does not exist in the system.  
- *Location Range Exceeds Limits* – Informs that the number of characters used for page‑break settings exceeds the allowed maximum.  
- *General Continuation Prompt* – After any message, the user presses return to continue.  

**User Flow Summary**  
The user runs the stock‑control reporting program from the main system menu. The program first displays a numbered list of report types. After selecting a type, the user is taken to a screen that collects optional criteria—such as a range of stock numbers, abbreviated numbers, or location ranges—and, where appropriate, a sub‑selection (e.g., all items, current period, or on‑order items). The user enters the desired criteria and confirms the selection. The program then reads the stock file, applies any filters, and formats the selected data into a printable report. The report is sent to the print spooler or displayed on screen, and the user is returned to the main menu to run another report or exit.

**Program Linkages**  
- `maps04`  
- `CBL_CHECK_FILE_EXIST`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by initializing environment variables, converting the current date, and verifying the existence of the stock file before presenting the main report menu. [Seen in: AA000-Core.]  
After the user selects a report option, the program performs a common report‑selection routine that validates input ranges and sets up partial‑list flags. [Seen in: ZZ050-Report-Selection.]  
Depending on the selected option, the program dispatches to one of several report‑processing sections (Valuation, Activity, Re‑Order, History, Stock List, or Location). [Seen in: aa110-Accept-Loop.]  
Once a report is generated, the program closes the print file, optionally prints the report header, and returns to the main menu or exits if the user chose to return to the system menu. [Seen in: aa999-Exit.]

5.2 Initialization  
The program accepts the number of screen lines, sets screen‑exception flags, and copies the print spool name into the PSN variable. [Seen in: AA000-Core.]  
It then converts the current date to the configured date format, establishes period descriptors, checks for the stock file’s existence, and opens the stock file for subsequent processing. [Seen in: AA000-Core, ZZ070-Convert-Date, ZZ060-Convert-Date.]

5.3 Core Processing  

Path: Valuation Report  
Trigger: Menu‑Reply = 1 (user selects “Valuation Report”)  
Key steps: The program normalises abbreviation ranges, starts the stock file at the specified key, iterates through records, filters by stock and abbreviation ranges, and prints each record while accumulating total value. [Seen in: BA000-Process-Valuations, BA010-Read-Rec, BA020-Print-Rec, BA030-Finish-Report.]  
I/O: Stock file (via Stock‑Start/Stock‑Read‑Next), Print file (via Write‑Print‑Record).  
Outcomes: Total valuation printed, WS‑Total‑Value updated, Page‑Nos incremented, and report status set for exit.  

Path: Activity Report  
Trigger: Menu‑Reply = 2 (user selects “Activity Report”)  
Key steps: The program sets up activity ranges, reads stock records, applies activity filters based on current or to‑date periods, prints activity details, and aggregates totals for the period and year‑to‑date. [Seen in: CA000-Process-Activity, CA010-Read-Rec, CA020-Print-Rec, CA030-Finish-Report.]  
I/O: Stock file, Print file.  
Outcomes: Activity report printed, WS‑Total‑Add/Ded and WS‑WIP‑Total‑Add/Ded updated, Page‑Nos updated.  

Path: Re‑Order Report  
Trigger: Menu‑Reply = 3 (user selects “Re‑Order Report”)  
Key steps: The program normalises abbreviation ranges, starts the stock file, filters records by understocked, out‑of‑stock, or on‑order criteria, prints each qualifying record, and tracks totals. [Seen in: DA000-Process-ReOrder, DA010-Read-Rec, DA020-Print-Rec, DA030-Finish-Report.]  
I/O: Stock file, Print file.  
Outcomes: Re‑order report printed, Page‑Nos incremented, report status set.  

Path: Stock History Report  
Trigger: Menu‑Reply = 4 (user selects “Stock History Report”)  
Key steps: The program sets up history ranges, reads stock records, prints historical activity for each month, and aggregates totals. [Seen in: FA000-Process-History, FA010-Read-Rec, FA020-Print-Rec, FA030-Finish-Report.]  
I/O: Stock file, Print file.  
Outcomes: History report printed, Page‑Nos updated, totals displayed.  

Path: Stock Report (by Location)  
Trigger: Menu‑Reply = 7 (user selects “Stock Report by Location”)  
Key steps: The program initializes location ranges, iterates through stock records sorted by location, prints each record, and handles page breaks based on location changes and double‑sided printing settings. [Seen in: GA000-Process-Location, GA010-Read-Rec, GA030-Finish-Report.]  
I/O: Stock file, Print file.  
Outcomes: Location‑based stock report printed, Page‑Nos updated, totals displayed.  

Path: Stock Report (by Description)  
Trigger: Menu‑Reply = 6 (user selects “Stock Report by Description”)  
Key steps: The program sets up description ranges, reads stock records, prints each record with detailed supplier and location information, and tracks the number of records printed. [Seen in: EB000-Process-Stock-Desc, EB010-Read-Rec, EB020-Print-Rec, EB030-Totals.]  
I/O: Stock file, Print file.  
Outcomes: Description‑based stock report printed, record count displayed, Page‑Nos updated.  

5.4 Termination  
After a report is generated, the program closes the print file, optionally prints the report header via a SYSTEM call, and then returns to the main menu or exits if the user selected the system menu option. [Seen in: aa999-Exit.]  
If the user chooses to exit from the main menu, the program performs a GOBACK (exit program) after closing the stock file. [Seen in: aa999-Exit.]

---
## st040
*[245/267]*

### Business/Functional Perspective
### Stock Activity Reset

**Program Purpose**  
This utility resets cumulative stock totals so that a new accounting period can begin cleanly.  
When executed, it clears period‑level totals (week, month, quarter, etc.) and/or month‑within‑year totals, depending on the operator’s selection or the automated command line arguments.  
By ensuring that old totals do not carry over, the program supports accurate reporting, audit readiness, and reduces the risk of erroneous financial statements.  
It also verifies that the underlying stock file or table exists before making any changes.

**Screen Interactions**  
The program presents a single interactive screen that proceeds through a series of prompts.  
1. **Title & Date** – “Stock Activity Reset” with the current date displayed.  
2. **Period Totals Prompt** – “Can I clear this *[period]* Period Totals? [ ] (N/Y)” – user enters Y or N.  
3. **Month Totals Prompt** – “Can I clear End of Month Totals on Stock records? [ ] (N/Y)” – user enters Y or N.  
4. **Backup Confirmation** – “Have you made backups of your data and are you sure?  [ ] (N/Y)” – user confirms with Y or N.  
5. **Status Messages** – If either clearing option was chosen, the screen shows “Will Clear Period totals” or “Will Clear Month totals” to confirm the selected actions.  
6. **Progress Message** – When processing begins, it displays “Updating Stock file as requested” or “Updating Stock table as requested” to inform the operator that records are being updated.

If the program is launched automatically via the stock menu with valid arguments (1, 2, or 3), the prompts are skipped and the clearing proceeds immediately.

**Messages and Errors**  
- **Input Validation** – If the user types anything other than “Y” or “N” at any prompt, a message “Y or N only” is shown and the prompt repeats.  
- **Missing File** – If the stock file or table cannot be found, a message indicating that the stock file was not found is displayed, followed by a request to press return to return to the menu.  
- **Write Failure** – If a record cannot be updated in the stock file/table, a message indicating an error writing the stock record is shown, with a prompt to press return before exiting.  
- **Invalid Auto‑Run Argument** – When run automatically, if the argument is not 1, 2, or 3, a message stating that the sub‑argument is invalid is displayed and the program aborts.  
- **Standard Exit** – After completion (or abort), the program returns to the calling menu.

**User Flow Summary**  
1. **Manual Run** – The operator starts the program from the stock menu or command line.  
2. **Prompt Sequence** – The screen displays the title, date, and three Y/N questions regarding period totals, month totals, and backup confirmation.  
3. **Decision Making** – The operator chooses Y or N for each question. If any input is invalid, the same question is repeated.  
4. **Confirmation** – Once valid choices are made, the program shows which totals will be cleared.  
5. **Processing** – The program verifies that the stock file/table exists, then iterates through each stock record, resetting the selected totals to zero, and writes each record back.  
6. **Completion** – Upon finishing, any errors encountered are reported; otherwise the program exits back to the menu.  

**Program Linkages**  
- `CBL_CHECK_FILE_EXIST`  
- `Stock-Open`  
- `Stock-Read-Next`  
- `Stock-Close`  
- `Stock-Rewrite`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by accepting the environment line count, setting screen exception flags, converting the current date into the system’s locale format, and validating the command‑line arguments to determine whether it is running in interactive or autorun mode. [Seen in: aa000-Core.]  
In interactive mode it displays prompts to confirm clearing of period and/or month‑in‑year totals, validates user responses, checks that audit reports have been run, and then proceeds to the clearing routine if confirmed. [Seen in: aa015-Questions-2, aa020-Accept-Loop, aa030-U-Sure.]  
In autorun mode it interprets the second argument to decide whether to clear period totals, month totals, or both, performs file existence checks, opens the stock file or table, and then iterates through all stock records resetting the appropriate totals before rewriting each record. [Seen in: aa040-Process-All, ba000-Clear-Totals-Main.]

5.2 Initialization  
The program accepts the number of lines from the environment, normalizes it to a minimum of 24, and sets screen exception flags for COBOL screen handling. [Seen in: aa000-Core.]  
It then converts the supplied current date into the system’s locale format, establishes the current month and day, and verifies that the command‑line program name matches “ST040” before proceeding. [Seen in: aa000-Core, zz070-Convert-Date.]

5.3 Core Processing  
Path: Auto‑Run Clearing  
Trigger: WS‑CD‑Args (1:5) = “st040” and WS‑CD‑Args (7:1) in {“1”, “2”, “3”}  
Key steps: set Clear‑Period or Clear‑Year flags, perform file existence checks, open the stock file/table, call ba000‑Clear‑Totals to reset totals, and exit.  
I/O: Stock file (File‑11), Stock table via Stock‑Open, Stock‑Read‑Next, Stock‑Close, Stock‑Rewrite.  
Outcomes: period and/or month totals cleared, status codes set, program exits.  
[Seen in: aa010-Questions, aa040-Process-All, ba000-Clear-Totals-Main.]

Path: Interactive Confirmation  
Trigger: WS‑CD‑Args (1:5) = “st040” and WS‑CD‑Args (7:1) not in {“1”, “2”, “3”}  
Key steps: display prompts, accept Clear‑Year and Clear‑Period responses, validate responses, check audit report run status, confirm backups, then proceed to aa040‑Process‑All if confirmed.  
I/O: same as Auto‑Run path.  
Outcomes: same as Auto‑Run path.  
[Seen in: aa015-Questions-2, aa020-Accept-Loop, aa030-U-Sure, aa040-Process-All.]

Path: File Not Found  
Trigger: FS‑Cobol‑Files‑Used = “Y” and CBL_CHECK_FILE_EXIST returns non‑zero for File‑11.  
Key steps: display ST401 error, prompt for acknowledgment, exit.  
I/O: File‑11.  
Outcomes: program exits with error status.  
[Seen in: aa040-Process-All.]

Path: Clear Totals Loop  
Trigger: ba000‑Clear‑Totals‑Main performs Stock‑Read‑Next until fs‑reply = 10.  
Key steps: for each record, if Clear‑Year and date valid, zero month totals; if Clear‑Period, initialize period totals; rewrite record; handle rewrite errors; loop.  
I/O: Stock file via Stock‑Read‑Next, Stock‑Rewrite, Stock‑Close.  
Outcomes: all stock records updated with cleared totals; program proceeds to exit.  
[Seen in: ba000-Clear-Totals, ba000-Clear-Totals-Main.]

5.4 Termination  
After completing the clearing routine, the program performs a GOBACK to return control to the caller, leaving any status codes set by the called routines. [Seen in: aa999-Exit.]  
If any error occurs during file checks or record rewriting, the program displays the appropriate error message, prompts for acknowledgment, and then exits via GOBACK. [Seen in: aa999-Exit, ba000-Clear-Totals-Main.]

---
## st050
*[246/267]*

### Business/Functional Perspective
### Stock File Compression  

#### Program Purpose  
The program cleans and rebuilds the main stock file. It removes records marked as deleted, resets all yearly and periodic counters, recomputes stock values, and optionally recreates the file from a temporary copy if a previous run left a corrupted file. By doing this at year‑end the system guarantees accurate inventory balances, keeps the file size optimal, and protects against data‑corruption risks.  

#### Screen Interactions  
1. **Initial Information Screen** – Shows program name, date, a note that the utility is not needed for RDBMS processing, and a brief description that the process will clean up deleted records.  
2. **Recovery Prompt** – Asks: *“Is this a recovery from a previous run of this process – [ ] (N/Y)”*.  
3. **Backup Confirmation Screen** – Displays: *“Confirm you wish this to happen & that you have a backup – [ ] (N/Y)”* and warns that all total fields will be cleared.  
4. **Processing Screen** – Updates the user with messages such as *“Recreating Stock file from temp file as requested”* or *“Updating your Stock file as requested”*.  
5. **Final Totals Screen** – Shows the number of records read from the stock file and the number written to the temporary file, then prompts the user to hit return to quit.  

#### Messages and Errors  
- **File length mismatch** – Alerts the user that the stock file record length differs from the temporary file layout and stops the operation.  
- **Cobol files not in use** – Informs the user that the system uses an RDBMS only and the utility is unnecessary.  
- **Stock file missing** – Reports that the primary stock file could not be located.  
- **Temporary file open/write errors** – Indicates problems opening or writing to the temporary file.  
- **Stock record write error** – Signals a failure to write a cleaned stock record, with details of the key that caused the problem.  
- **General operation prompts** – Includes generic “Press return to continue” or “Confirm action” prompts.  

#### User Flow Summary  
1. The user runs the utility.  
2. The program displays its name, the current date, and explains that it will remove deleted records and reset yearly totals.  
3. The user chooses whether the run is a recovery from a previous incomplete execution.  
4. The user confirms that a backup exists and that they want the yearly totals wiped.  
5. The program opens the stock file for reading and a temporary file for writing.  
6. It processes each stock record: deletes any flagged as deleted, clears a series of counters, recalculates the value field, and writes the cleaned record to the temporary file.  
7. If the user selected recovery, the program replaces the original stock file with the temporary file; otherwise it simply updates the original file in place.  
8. Upon completion, the program shows the number of records processed, prompts the user to press return, and then exits.  

#### Program Linkages  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins execution at paragraph **aa000-Core**, performing environment setup, date conversion, and preliminary checks. [Seen in: aa000-Core.]  
It verifies that the Stock file record length matches the temporary file layout, checks that Cobol files are in use, and prompts the user for recovery and confirmation of the compression operation. [Seen in: aa010-Questions, aa020-Recovery, aa030-U-Sure.]  
Based on the user’s responses, the program either rebuilds the Stock file from the temporary file or processes the Stock file to compress it, then terminates. [Seen in: aa999-Exit.]

5.2 Initialization  
The program accepts the number of environment lines, sets screen exception flags, and converts the current date to the local format. [Seen in: aa000-Core.]  
It compares the lengths of the Stock record and the temporary Stock record, aborting if they differ, and verifies that Cobol files are enabled before proceeding. [Seen in: aa000-Core.]

5.3 Core Processing  
Path: **Recovery**  
Trigger: User selects “Y” at the recovery prompt (ws-Recovery = “Y”). [Seen in: aa020-Recovery.]  
Key steps: Display confirmation message, perform **ba010-Build-Stock** to rebuild the Stock file from the temporary file, then exit. [Seen in: aa020-Recovery, ba010-Build-Stock.]  
I/O: Temp-Stock-File (input), Stock-File (output). [Seen in: ba010-Build-Stock.]  
Outcomes: Stock file is recreated from the temporary file; counts a and b reflect records processed; program terminates. [Seen in: ba010-Build-Stock.]

Path: **Compression**  
Trigger: User selects “N” at the recovery prompt (ws-Recovery = “N”). [Seen in: aa020-Recovery.]  
Key steps: Open Stock file for input, open temporary file for output, invoke **ba000-Process-Stock-Comp** to read each Stock record, clear deleted‑record fields, compute Stock‑Value, write cleaned record to the temporary file, and update counters a and b. After processing all records, close files and display totals. [Seen in: aa020-Recovery, ba000-Process-Stock-Comp, ba000-Process-Stock-Comp-Main.]  
I/O: Stock-File (input), Temp-Stock-File (output). [Seen in: ba000-Process-Stock-Comp.]  
Outcomes: Temporary file contains a compressed copy of the Stock file; counters a and b indicate number of records processed and written; program proceeds to exit. [Seen in: ba000-Process-Stock-Comp.]

5.4 Termination  
The program displays a final message prompting the user to hit return, then performs a **GOBACK** to terminate. [Seen in: aa999-Exit.]  
All opened files are closed and any temporary resources are released before exiting. [Seen in: aa999-Exit.]

---
## st060
*[247/267]*

### Business/Functional Perspective
### Stock File Importer

**Program Purpose**  
The Stock File Importer moves inventory records from an external file into the ACAS stock master. It reads each line of the supplied file, translates the data into the internal stock record format, and writes the records to the system’s stock file. This process is typically performed once when a new data source is integrated, ensuring that the stock database is populated with current items and that future reporting and inventory controls can rely on accurate master data.

**Screen Interactions**  
1. **Start Screen** – Displays the program name, current date, and the title “Stock File Importer”.  
   - Prompt: “Provide full path and file name of file to be imported” (user types the file location).  
2. **Progress/Completion Screen** – After all records are processed, the screen shows:  
   - “Records Imported – [number]”  
   - “Records Written – [number]”  
   - A note indicating the import has finished (ST603).  
   - The program waits for the user to press return to exit.  

**Messages and Errors**  
- **Pre‑use Warning** – If the program has not been adapted to the specific file layout, it displays “THIS PROGRAM MUST BE CHANGED BEFORE USE” and stops.  
- **File Access Errors** – If the import file cannot be opened or read, a message informs the user that the file could not be accessed and the program terminates.  
- **Record Write Errors** – If a stock record cannot be written to the master file, the user is notified of the failure and the program stops.  
- **Completion Notice** – A final message confirms that the import has completed successfully and displays the number of records processed.  

**User Flow Summary**  
1. The user starts the importer from the menu.  
2. A screen appears asking for the full path to the inventory file. The user enters the path and presses return.  
3. The program reads each line of the file, converts the fields to the ACAS stock format, and writes the record to the stock master.  
4. Throughout the run, the user sees only the initial prompt and the final summary screen.  
5. Once all records are processed, the program displays the counts of records read and written, shows a completion note, and waits for the user to press return before returning to the menu.  

**Program Linkages**  
- acas011  
- sl070  
- CBL_CHECK_FILE_EXIST  
- maps04

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry performs aa000-Core which displays a mandatory change notice and returns to the caller. [Seen in: aa000-Core.]  
When invoked from the menu, aa010-Get-File-for-Import prompts for the file path, then calls ba000-Import-Stock to begin the import process. [Seen in: aa010-Get-File-for-Import.]  
ba000-Import-Stock opens the import file, ensures analysis tables exist, and then enters a loop reading each record via ba010-Get-A-Record until end-of-file, processing each record according to delimiter type and writing to the stock file. [Seen in: ba000-Import-Stock.]

5.2 Initialization  
aa000-Core displays a change‑notice message and exits, preventing use of the unmodified program. [Seen in: aa000-Core.]  
aa010-Get-File-for-Import accepts the full path and file name, then initiates the import by performing ba000-Import-Stock. [Seen in: aa010-Get-File-for-Import.]

5.3 Core Processing  
Path: Import‑File‑Open‑and‑Check‑Analysis  
Trigger: Program start via ba000-Import-Stock  
Key steps: open input Import-File; if FS-Cobol-Files-Used, call CBL_CHECK_FILE_EXIST on File-15, and if missing call sl070 to create analysis tables; open stock file via Stock-Open.  
I/O: Import-File, File-15 (analysis file)  
Outcomes: analysis tables created if absent, Import-File opened for reading, stock file ready for writes. [Seen in: ba000-Import-Stock.]

Path: Record‑Read‑and‑Process  
Trigger: Successful read of Import-File record  
Key steps: increment ws-Record-Count; initialize WS-Stock-Record; determine delimiter type (Process-Comma flag) and branch to ba030-Process-Comma or ba020-Process-Regular; after processing, perform Stock-Write and increment ws-Write-Count; loop back to ba010-Get-A-Record.  
I/O: Import-File, Stock-File (via Stock-Write)  
Outcomes: ws-Record-Count and ws-Write-Count updated, stock records written. [Seen in: ba010-Get-A-Record.]

Path: Process‑Comma‑Record  
Trigger: Process-Comma flag set (Process-Comma)  
Key steps: unstring Import-Record into fields, set default supplier, parse numeric and amount fields using zz025-Format-Number and zz030-Format-Amount, validate dates with zz050-Validate-Date, populate WS-Stock-Record, perform Stock-Write.  
I/O: Import-File, Stock-File  
Outcomes: stock record populated with parsed values and defaults, written to stock file. [Seen in: ba030-Process-Comma.]

Path: Process‑Regular‑Record  
Trigger: Process-Comma flag not set (regular file)  
Key steps: move corresponding WS-Temp-Stock-Record to WS-Stock-Record, adjust abrev key logic, initialize totals if ws-Reset-Hist, perform Stock-Write.  
I/O: Import-File, Stock-File  
Outcomes: stock record written with fields from the regular layout. [Seen in: ba020-Process-Regular.]

Path: End‑of‑File‑Processing  
Trigger: End of Import-File read (EOF)  
Key steps: perform Stock-Close, close Import-File, move counts to display variables, display record counts, accept reply, then exit.  
I/O: Import-File, Stock-File  
Outcomes: program terminates after reporting totals. [Seen in: ba998-Main-End.]

5.4 Termination  
ba998-Main-End performs Stock-Close, closes Import-File, displays the number of records imported and written, and then returns to the caller. [Seen in: ba998-Main-End.]  
aa999-Exit simply performs GOBACK to return control to the calling program. [Seen in: aa999-Exit.]

---
## stock
*[248/267]*

### Business/Functional Perspective
### Stock Control Menu

#### Program Purpose  
The Stock program presents a single menu that lets a user manage all aspects of the company’s inventory.  
From this screen, the user can enter new dates, maintain stock items, record stock movements, run various reports, perform end‑of‑cycle processing, import or compress the stock file, and, if authorised, change system settings.  
The menu also ensures that the required backup script is available and will trigger it automatically when the user exits.  

#### Screen Interactions  
1. **Main Menu Screen** – Title bar shows “Stock Control System Menu” and the current date and time.  
   - **Options** (select by letter):  
     *A* – Date Entry  
     *B* – Stock Item Maintenance  
     *C* – Stock Movements  
     *D* – Reports  
     *E* – End of Cycle Processing  
     *F* – Stock File Import  
     *Y* – Stock File Compression  
     *X* – Exit to previous menu or system  
     *Z* – System Set Up (visible only when not restricted)  
   - The screen also displays the operating system name and any message about the backup script (e.g., “Using …” or “No BackUp Script in Bin”).

#### Messages and Errors  
- **Environment‑related** – Alerts if the terminal length is not 24 lines or columns are not 80, prompting the user to adjust settings.  
- **Missing Backup Script** – Informs the user that no backup script was found in the expected location.  
- **Unauthorized Option** – Shows “Not permitted” if the user attempts to access System Set Up while restricted.  
- **Unavailable Program** – Displays “Sorry not available – Requests to ACAS support” when a selected function is not implemented.  
- **General Error** – Reports a problem when the system cannot locate required files or cannot perform an operation, suggesting the user contact support.  

#### User Flow Summary  
The user launches the Stock menu and is greeted with the current date/time, operating‑system label, and a list of functions. After selecting a letter, the program routes the request to the corresponding sub‑program: for example, choosing *B* opens the Stock Item Maintenance routine, while *C* leads to the Stock Movements routine. The menu loops, allowing the user to perform multiple tasks in a single session. When the user selects *X* to exit, the program checks for a valid backup script and, if present, runs it before terminating. If the program is started automatically with command‑line arguments, it may bypass the menu entirely, run an audit report or other routine, and then exit, still ensuring the backup is executed.  

#### Program Linkages  
- CBL_CHECK_FILE_EXIST  
- maps04  
- sl070  
- sys002  
- st000  
- st010  
- st020  
- st030  
- st040  
- st050  
- st060  
- SYSTEM   (operating‑system command to execute backup script)

### Technical/Migration Perspective
No response received

---
## stockconvert2
*[249/267]*

### Business/Functional Perspective
### Stock File Conversion  

**Program Purpose**  
The Stock File Conversion program updates existing stock records to include a new field (stock‑Arrival‑Date) set to zero. It rewrites the stock file with an expanded record structure, ensuring that all inventory data remains intact while the file format is brought up to date. The update reduces the risk of incompatibility with future reporting and inventory processes.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- A brief start message indicating the program name and that the conversion has begun.  
- Progress updates after each pass, showing how many records have been read and written.  
- Simple error notices if a file cannot be opened, read, or written, followed by an immediate halt of the program.  
- A final message confirming completion before the program stops.  

**User Flow Summary**  
The user runs the program from the command line in each data‑folder that contains the stock file. When executed, the program first copies the existing stock file to a temporary file, preserving all original data. It then reads the temporary file and writes each record into a new stock file that includes the additional field, initializing that field to zero. Throughout the process, the user sees console output indicating progress, and any critical error will stop the program and report the problem. Upon successful completion, the new stock file replaces the old one, and the program terminates.  

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by opening the existing stock file for input and a temporary file for output, then proceeds to read each record from the old file, writing it to the temporary file. [Seen in: AA000-Start.]  
After all records are copied to the temporary file, the program reopens the temporary file for input and the new stock file for output, then reads each temporary record and writes it to the new stock file. [Seen in: AA020-Process-2.]  
Upon completion of the second pass, the program displays a completion message and terminates. [Seen in: AA020-Read.]

5.2 Initialization  
The program opens Old-Stock-File for input; if the status is not "00", it displays an error, closes the file, and stops. [Seen in: AA000-Start.]  
It then opens Temp-Stock-File for output; on failure it displays an error, closes any open files, and stops. [Seen in: AA000-Start.]  
The program initializes record counters (In-Rec-Count, rec-count) to zero before entering the first read loop. [Seen in: AA010-Read.]

5.3 Core Processing  
Path: Pass 1 – Copy Old to Temp  
Trigger: Entry to AA010-Read after successful file opens.  
Key steps: Read next record from Old-Stock-File; if end‑of‑file, close files and go to Pass 2; otherwise copy record to Temp‑Stock‑Record, write to Temp‑Stock‑File, update counters.  
I/O: Old‑Stock‑File, Temp‑Stock‑File.  
Outcomes: rec‑count and In‑Rec‑Count incremented; temporary file populated with all old records.  
[Seen in: AA010-Read.]

Path: Pass 2 – Copy Temp to New  
Trigger: Entry to AA020-Read after opening Temp‑Stock‑File and Stock‑File.  
Key steps: Read next record from Temp‑Stock‑File; if end‑of‑file, close files, display completion, stop run; otherwise copy record to Stock‑Record, write to Stock‑File, update counters.  
I/O: Temp‑Stock‑File, Stock‑File.  
Outcomes: rec‑count and In‑Rec‑Count incremented; new stock file populated with updated records.  
[Seen in: AA020-Read.]

5.4 Termination  
When the second pass reaches end‑of‑file, the program closes Stock‑File and Temp‑Stock‑File, displays a final message, and stops execution. [Seen in: AA020-Read.]  
In any error condition during reading or writing, the program closes all open files and stops immediately. [Seen in: AA000-Start, AA010-Read, AA020-Read.]

---
## stockconvert3
*[250/267]*

### Business/Functional Perspective
### Stock Record Conversion  

**Program Purpose**  
This program updates the company’s stock file by resetting a new field (stock‑arrival date) to zero for every record. It reads all existing stock records, writes them to a temporary file, then writes them back to the original stock file. The result is a clean, updated stock file that can be used by other parts of the accounting system without risk of incorrect date data.

**Screen Interactions**  
No direct screens. This program is run from the command line after a separate data‑entry step and returns text messages to the console.

**Messages and Errors**  
- If the input or output files cannot be opened, the program stops and displays a clear message about the failure.  
- If a read or write operation encounters an error, the program stops and informs the user that the operation failed.  
- During normal operation, the program prints progress messages indicating how many records have been processed in each of two passes.

**User Flow Summary**  
1. The user navigates to each data folder (e.g., `ACAS`, `whse‑1`, `whse‑2`) and runs the program from the command line.  
2. The program opens the current stock file, copies every record to a temporary file, then copies those records back to the original file, resetting the new field to zero.  
3. Throughout the process, the program prints status messages showing how many records have been read and written.  
4. When finished, it displays a completion message and exits. The updated stock file is ready for use by other accounting functions.

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by opening the existing stock file and a temporary file for output. [Seen in: AA000-Start.]  
It then reads each record from the old stock file, writes it to the temporary file, and counts records. [Seen in: AA010-Read.]  
After the first pass, it reopens the temporary file for input, writes each record to the new stock file, and terminates. [Seen in: AA020-Process-2.]

5.2 Initialization  
The program opens the old stock file for input and checks the status, closing and stopping if an error occurs. [Seen in: AA000-Start.]  
It also opens the temporary file for output, verifies the status, and displays a start message. [Seen in: AA000-Start.]

5.3 Core Processing  
Path: Pass 1 – Read Old Stock, Write Temp  
Trigger: Program flow reaches AA010-Read after opening files.  
Key steps: Read next record from Old-Stock-File, handle end‑of‑file by closing files and moving to Pass 2, otherwise write record to Temp-Stock-File, update counters, loop.  
I/O: Old-Stock-File, Temp-Stock-File.  
Outcomes: rec‑count and In‑Rec‑Count updated, temporary file populated, files closed on EOF.  
[Seen in: AA010-Read.]

Path: Pass 2 – Read Temp Stock, Write New Stock  
Trigger: Program flow reaches AA020-Process-2 after Pass 1 completion.  
Key steps: Open Temp-Stock-File for input, open Stock-File for output, read each record from Temp-Stock-File, write to Stock-File, update counters, loop until EOF, then display end message and stop run.  
I/O: Temp-Stock-File, Stock-File.  
Outcomes: New stock file populated, record counts, program terminates.  
[Seen in: AA020-Process-2, AA020-Read.]

5.4 Termination  
Upon reaching the end of the second read loop, the program closes all files, displays a completion message, and stops. [Seen in: AA020-Read.]  
If any file operation error occurs during processing, the program closes any open files and stops immediately. [Seen in: AA000-Start, AA010-Read, AA020-Read.]

---
## stockLD
*[251/267]*

### Business/Functional Perspective
### Stock Table Load

#### Program Purpose  
This program imports stock item records from a flat Stock file into the system’s database table. It validates each record, updates existing entries when duplicates are found, and records progress and any errors. The load supports both MySQL and legacy COBOL file storage, ensuring data integrity and traceability. It is normally run as a batch job after the stock data file has been prepared, providing a reliable data‑load mechanism for the accounting system.

#### Screen Interactions  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

#### Messages and Errors  
- **Configuration issues** – The program cannot locate the system configuration file or the database parameters, or the Stock file itself is missing.  
- **File access errors** – Problems opening, reading, or writing the Stock file or the database table.  
- **Duplicate records** – When a record already exists, the program updates it and continues without stopping the load.  
- **Database errors** – SQL errors or transaction failures trigger a rollback and terminate the load.  
- **Summary output** – At completion the program reports how many records were read, written, and updated, along with the number of log entries created.

#### User Flow Summary  
1. The user starts the program (typically from a batch or command line), optionally supplying up to two arguments.  
2. The program reads system configuration to obtain database connection details. If these are missing or invalid, it attempts to load them from an external parameter file; failure to do so stops the load.  
3. It opens the Stock file for reading. If the file is not found, the program exits with a message.  
4. It establishes a connection to the database. Any connection failure aborts the run.  
5. The program reads each record from the Stock file. For each record it attempts to insert it into the database.  
   * If a duplicate key is detected, the record is rewritten (updated) and the duplicate count is increased.  
   * Any other read or write error is logged, a rollback is attempted, and the program terminates.  
6. Progress and error messages are written to the system log.  
7. After all records have been processed, a summary of totals is logged. The program then commits any pending changes, closes the database and the Stock file, and ends.

#### Program Linkages  
- acas-get-params  
- acas011  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at aa000-main-start, performing argument parsing, setting logging parameters, and opening the system parameter file. [Seen in: aa000-main-start.]  
It then loads database connection details either from the system record or from acas.param via acas-get-params, and proceeds to open the stock file and the target RDB table. [Seen in: aa000-main-start, aa010-Proc-Override.]  
The core loop reads each record from the stock file, writes it to the RDB table, handles duplicate keys, and continues until end-of-file, after which cleanup and exit occur. [Seen in: aa010-Read, aa999-Finish.]

5.2 Initialization  
The program parses up to two command‑line arguments using zz020-Get-Program-Args, initializes logging identifiers, and opens the System-File for reading. [Seen in: aa000-main-start.]  
It reads the system record, validates required fields, and if necessary invokes acas-get-params to obtain RDB parameters, setting the global RDBMS variables before proceeding. [Seen in: aa000-main-start.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: Opening and reading System-File at program start.  
Key steps: Open System-File, read system record, validate fields, call acas-get-params if needed, set RDBMS variables.  
I/O: System-File.  
Outcomes: RDBMS connection parameters populated; program aborts if missing or invalid.  
[Seen in: aa000-main-start.]

Path: File Open  
Trigger: Transition to aa010-Proc-Override after parameter load.  
Key steps: Open stock file via acas011-Open-Input, open RDB via acas011-Open, set file-system flags.  
I/O: Stock File, RDB table.  
Outcomes: File handles initialized; program ready for record processing.  
[Seen in: aa010-Proc-Override.]

Path: Stock File Read/Write Loop  
Trigger: Each iteration of aa010-Read.  
Key steps: Read next stock record, write to RDB, increment counters, handle errors, loop until EOF.  
I/O: Stock File, RDB table.  
Outcomes: Records transferred, counters updated, errors logged, loop exits on EOF.  
[Seen in: aa010-Read.]

Path: Duplicate Key Handling  
Trigger: Duplicate key error detected during write (fs-reply 22, 99, or SQL-Err 1062/1022).  
Key steps: Reset fs-reply and WE-Error, rewrite record, increment rewrite counter, continue loop.  
I/O: RDB table.  
Outcomes: Duplicate records are rewritten, rewrite counter incremented, processing continues.  
[Seen in: aa010-Read.]

Path: EOF Termination  
Trigger: fs-reply = 10 after read.  
Key steps: Jump to aa999-Finish.  
I/O: None beyond stock file read.  
Outcomes: Exit loop, proceed to cleanup.  
[Seen in: aa010-Read.]

Path: Error Termination  
Trigger: fs-reply not zero after write (non‑duplicate error).  
Key steps: Log error details, set return-code 16, go to aa999-Finish.  
I/O: None beyond stock file and RDB.  
Outcomes: Program aborts with error status, cleanup performed.  
[Seen in: aa010-Read.]

5.4 Termination  
The aa999-Finish paragraph logs record counts, closes the RDB and stock files, closes the System-File, and returns control to the caller. [Seen in: aa999-Finish.]  
No explicit commit is performed; the program relies on the database's autocommit setting or external transaction handling. [Seen in: aa999-Finish, aa030-Commit (unused).]

---
## stockMT
*[252/267]*

### Business/Functional Perspective
### Stock Record Handling  

**Program Purpose**  
The program provides a reliable interface for all stock‑file operations used by the Applewood Accounting system. It opens the underlying database table, reads, writes, updates, and deletes stock records while guaranteeing key integrity, preventing duplicate entries, and ensuring that any errors are captured and reported. By centralising data access, it reduces the risk of inconsistent stock data and supports audit and compliance requirements for inventory management.  

**Screen Interactions**  
No direct screens. This program is invoked by other modules after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- **Success** – The requested operation completes and the record (if applicable) is returned.  
- **End of Data** – No further records are available to read.  
- **Record Not Found** – The requested key does not exist in the table.  
- **Duplicate Key** – An attempt was made to insert a record with a key that already exists.  
- **Invalid Key Type** – The key number supplied for the operation is out of the allowed range.  
- **SQL Error** – A database error occurs (e.g., syntax error, connection failure).  
- **System Error** – A serious system failure (e.g., database not available, table lock timeout).  

**User Flow Summary**  
1. A calling module supplies a stock record and a file‑function code (open, close, read next, read indexed, write, update, delete, or start).  
2. The program validates the key number and function, then performs the requested action against the `STOCK‑REC` table in the chosen RDBMS.  
3. For read operations, it returns the requested record (or the next record in the cursor) and indicates whether more data remains.  
4. For write, update, or delete operations, it reports success, duplicates, or missing records.  
5. The program sets status codes (`FS‑Reply` and `WE‑Error`) that the caller can use to decide the next step or display a user‑facing message.  

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at **ba-ACAS-DAL-Process**, where it accepts linkage data, sets screen exception flags, and performs an initial environment setup.  
It then evaluates **File‑Function** and dispatches to one of the operation paragraphs (Open, Close, Read‑Next, Read‑Indexed, Start, Write, Rewrite, Delete, or Bad‑Function).  
After executing the chosen operation, control flows to **ba999‑end** for logging (if enabled) and program termination. [Seen in: ba-ACAS-DAL-Process.]

5.2 Initialization  
The **ba010‑Initialise** paragraph clears all status and error fields, prepares the MySQL error buffers, and validates key ranges for indexed operations.  
When **File‑Function = 1** (Open), **ba020‑Process‑Open** builds the MySQL connection string, calls the pre‑compiled open routine, and sets the cursor state to inactive. [Seen in: ba010‑Initialise, ba020‑Process‑Open.]

5.3 Core Processing  

Path: Process‑Open  
Trigger: File‑Function = 1 (Open)  
Key steps: Build connection string, call MYSQL‑1000‑OPEN, set cursor inactive, set WS‑File‑Key to “OPEN STOCK”.  
I/O: STOCK‑REC table (connection only).  
Outcomes: FS‑Reply set to 0 on success; WE‑Error remains 0; cursor inactive.  
[Seen in: ba020‑Process‑Open.]

Path: Process‑Read‑Next  
Trigger: File‑Function = 3 (Read‑Next)  
Key steps: If cursor inactive, perform a SELECT with key “0000000000000” and ORDER BY STOCK‑KEY; if rows exist, activate cursor; otherwise return EOF.  
I/O: STOCK‑REC table (SELECT, FETCH).  
Outcomes: FS‑Reply 10 on EOF, WE‑Error 10; on success, WS‑File‑Key set to STOCK‑KEY, record loaded into Stock‑Rec, cursor remains active.  
[Seen in: ba040‑Process‑Read‑Next.]

Path: Process‑Start  
Trigger: File‑Function = 9 (Start)  
Key steps: Validate access type, build WHERE clause with MOST‑Relation, execute SELECT, activate cursor if rows found.  
I/O: STOCK‑REC table (SELECT).  
Outcomes: FS‑Reply 0 on success, 21 on no data; WE‑Error 0; cursor active if rows returned.  
[Seen in: ba060‑Process‑Start.]

Path: Process‑Write  
Trigger: File‑Function = 5 (Write)  
Key steps: Load host variables from Stock‑Rec (bb000‑HV‑Load), build INSERT statement, execute command, check row count for duplicate key.  
I/O: STOCK‑REC table (INSERT).  
Outcomes: FS‑Reply 0 on success, 22 on duplicate key, WE‑Error 0; SQL‑Err and SQL‑Msg set on MySQL error.  
[Seen in: ba070‑Process‑Write.]

Path: Process‑Delete  
Trigger: File‑Function = 8 (Delete)  
Key steps: Build WHERE clause on key, execute DELETE command, verify one row affected.  
I/O: STOCK‑REC table (DELETE).  
Outcomes: FS‑Reply 0 on success, 99 on error, WE‑Error 995 on MySQL error; cursor remains inactive.  
[Seen in: ba080‑Process‑Delete.]

5.4 Termination  
If testing is enabled, **Ca‑Process‑Logs** writes the operation log before exiting.  
The program ends by executing **ba999‑end**, which performs any final cleanup (freeing cursor if active) and exits the program. [Seen in: ba999‑end.]

---
## stockRES
*[253/267]*

### Business/Functional Perspective
### Stock Data Restore  

**Program Purpose**  
This utility restores stock information from a backup sequential file into the system’s primary stock data file. It ensures that the current stock file is rebuilt accurately from a reliable backup, supporting data integrity and continuity of operations. By validating the backup and reporting any read/write problems, it helps prevent data loss and ensures compliance with internal audit requirements.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- *Missing backup file*: Reports that no stock backup file was found and aborts the restore.  
- *Open failures*: Indicates problems opening the destination stock file and aborts.  
- *Read errors*: Logs any issue encountered while reading a record from the backup file.  
- *Write errors*: Logs failures when writing a record to the destination file.  
- *Completion report*: Shows the total number of records read and written.  

**User Flow Summary**  
A user launches the program (typically from a command line or scheduled job). The program checks for the presence of a sequential backup file. If the file exists, it opens the backup for reading and the primary stock file for writing. It then copies each record from the backup into the primary file, counting records as it goes. Throughout the process, the program writes status messages to a log file. When finished, it logs the total records processed and closes both files. The user reviews the log to confirm successful restoration or to investigate any reported errors.  

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and initializing logging parameters, then attempts to open the source sequential stock file for reading. [Seen in: aa000-Main-Start.]  
If the source file opens successfully, it opens the target ISAM stock file for writing; thereafter it enters a loop that reads each record from the source and writes it to the target, counting records processed. [Seen in: aa010-Read-Recs.]  
Upon reaching the end of the source file or encountering an error, the program closes both files, logs a summary of records transferred, sets the return code to zero, and exits. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs a PERFORM of zz020-Get-Program-Args to capture command‑line parameters and sets logging identifiers for the stock module. [Seen in: aa000-Main-Start.]  
It then opens the input sequential file (Stock-File-Seq) and, if successful, opens the output ISAM file (Stock-File); any failure in these opens results in an error message and immediate termination. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Input File Open Failure  
Trigger: FS‑Reply not equal to zeros after attempting to open Stock‑File‑Seq.  
Key steps: set error message, call Sysout, close Stock‑File‑Seq, goback.  
I/O: Stock‑File‑Seq.  
Outcomes: program exits without processing records.  
[Seen in: aa000-Main-Start.]

Path: Output File Open Failure  
Trigger: FS‑Reply not equal to zeros after attempting to open Stock‑File.  
Key steps: set error message, call Sysout, close both files, goback.  
I/O: Stock‑File, Stock‑File‑Seq.  
Outcomes: program exits without processing records.  
[Seen in: aa000-Main-Start.]

Path: Read‑Write Loop  
Trigger: Successful open of both files; loop continues until end of Stock‑File‑Seq.  
Key steps: read next record, check FS‑Reply, write to Stock‑File, check FS‑Reply, increment input and output counters.  
I/O: Stock‑File‑Seq (read), Stock‑File (write).  
Outcomes: counters updated, error messages logged on read/write failures, loop terminates on end‑of‑file or error.  
[Seen in: aa010-Read-Recs.]

Path: Finish‑Off  
Trigger: End of read loop or error condition.  
Key steps: close both files, compose summary message with record counts, call Sysout, set Return‑Code to zero, goback.  
I/O: Stock‑File‑Seq, Stock‑File.  
Outcomes: files closed, summary logged, program terminates normally.  
[Seen in: aa020-Finish-Off.]

5.4 Termination  
The program closes any open files, logs a final “CLOSE” message, sets the return code to zero, and exits via GOBACK. [Seen in: aa020-Finish-Off.]  
All output, including error and summary messages, is routed through the Call‑Sysout routine which writes to the system log. [Seen in: Call‑Sysout.]

---
## stockUNL
*[254/267]*

### Business/Functional Perspective
### Stock File Backup  

**Program Purpose**  
The program creates a backup of the current stock data by copying all records from the primary stock file into a new sequential file with a `.seq` extension. This backup is used for recovery or audit purposes when the original ISAM file becomes inaccessible or corrupted. By preserving the exact data set, the program helps maintain data integrity and ensures compliance with internal data‑retention policies. It logs its activity and the number of records processed to provide a clear audit trail.  

**Screen Interactions**  
No direct screens. This program is run as a background task (for example, from a command line or a scheduled job) and reports results via a log file.  

**Messages and Errors**  
- If the source stock file cannot be found or opened, a log entry records the issue and the program stops.  
- If any record cannot be read from the source file, the error is logged and the backup process terminates.  
- If writing a record to the backup file fails, a log entry indicates the write error and the process stops.  
- If required environment variables or program arguments are missing, the program logs a failure message and aborts.  

**User Flow Summary**  
The user (or an automated system) starts the backup program to preserve the current stock data. The program reads each record from the original stock file and writes it to a new `.seq` file, counting how many records are processed. Throughout the operation, it writes status messages to a log file, noting any problems that occur. When all records have been copied or an error stops the process, the program logs the total number of records successfully written and exits, leaving the log file available for review.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by retrieving command‑line arguments and initializing logging parameters in paragraph aa000-Main-Start. [Seen in: aa000-Main-Start.]  
It then opens the source stock file for input and a sequential output file for writing, proceeding to read and copy each record in paragraph aa010-Read-Recs. [Seen in: aa010-Read-Recs.]  
Upon completion or error, it closes both files, reports record counts, and exits in paragraph aa020-Finish-Off. [Seen in: aa020-Finish-Off.]

5.2 Initialization  
The program performs a call to zz020-Get-Program-Args to parse command‑line arguments and sets up logging identifiers (WS-Log-System and WS-Log-File-no). [Seen in: aa000-Main-Start.]  
It then opens the input stock file; if the file cannot be opened, it logs a message and aborts the program. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Normal Record Copy  
Trigger: Successful open of Stock-File and Stock-File-Seq, and FS-Reply equals zeros.  
Key steps: Read each record from Stock-File, increment input counter, write the record to Stock-File-Seq, increment output counter.  
I/O: Stock-File (input), Stock-File-Seq (output).  
Outcomes: Record counts are updated; on completion, control moves to aa020-Finish-Off.  
[Seen in: aa010-Read-Recs.]

Path: Read Error  
Trigger: FS-Reply not equal to zeros after a read attempt.  
Key steps: Construct error message with SY003 and FS-Reply, log the message, and terminate processing.  
I/O: Stock-File (input).  
Outcomes: Program exits with error status, skipping any further writes.  
[Seen in: aa010-Read-Recs.]

Path: Write Error  
Trigger: FS-Reply not equal to zero after a write attempt.  
Key steps: Log SY006, terminate processing.  
I/O: Stock-File-Seq (output).  
Outcomes: Program exits with error status, skipping any remaining records.  
[Seen in: aa010-Read-Recs.]

Path: No Stock File  
Trigger: FS-Reply not equal to zeros after attempting to open Stock-File.  
Key steps: Log “No stock file to process”, close the file, and exit.  
I/O: Stock-File (input).  
Outcomes: Program terminates without performing any record copy.  
[Seen in: aa000-Main-Start.]

5.4 Termination  
The program closes both the sequential output file and the source stock file, logs the total records processed, and sets Return-Code to zero before exiting. [Seen in: aa020-Finish-Off.]

---
## sys002
*[255/267]*

### Business/Functional Perspective
### System Parameters Setup  

**Program Purpose**  
The program collects, validates and stores all key system‑level settings that govern how the accounting system operates.  It provides a central interface for configuring user identity, date formats, printing options, database access, accounting structure, tax rules, and stock‑management parameters.  By ensuring that these values are entered correctly and persisted, the program reduces data‑entry risk, supports regulatory compliance, and enables consistent reporting across all sub‑systems.  

**Screen Interactions**  

| # | Screen Title | Inputs Provided by User | Outputs/Results | Options/Buttons |
|---|--------------|------------------------|-----------------|-----------------|
| 1 | **User Data** | User name, address lines, postcode, country, date‑format choice, period start & end dates, statistics year, page‑lines, VAT rates, current cycle & quarter, VAT registration number, email address, data‑file handling mode, cycle period, escape key to quit | Stores personal and system‑wide date and display preferences | Escape to abort |
| 2 | **Verify** | Y/N to confirm saving of parameters | Either commits parameters or re‑displays previous screen | Y (accept), N (re‑edit) |
| 3 | **OPS Data 1** | Restrict ACAS parameter access (Y/N), single/multi‑user flag (0/1), operating system selection (1‑6), data‑capture system (0‑2) | Configures security, multi‑user mode and data‑capture method | N/A |
| 4 | **OPS Data 2** | Print‑spooler names for CUPS (3 fields) | Sets printer configuration | N/A |
| 5 | **OPS Data 3** | RDBMS schema name, user name, password, host, socket, port | Sets database connection parameters | N/A |
| 6 | **G/L Data** | Profit‑centre/branch flag, branch level, grouping, comparative figures, ledger index, validation flag, archiving flag, sales & purchase ranges, auto‑VAT posting, next batch number, IRS usage flag | Configures general ledger behaviour | N/A |
| 7 | **P/L Data** | Record delimiter, stock link, next folio, next batch, pay account, ledger account, creditor account | Sets profit‑loss ledger structure | N/A |
| 8 | **S/L Data 1** | Late‑letter and late‑charge flags, credit period, discount, minimum & maximum late balance, credit limit, delimiter, own invoice numbers flag, next invoice number, invoice line limit, late‑charge %, first batch number, stock link, back‑order link & default, pay, ledger, debtor, VAT accounts | Configures sales ledger behaviour | N/A |
| 9 | **S/L Data 2** | Flags to print company heads on invoices, statements, late letters, delivery notes | Determines report header inclusion | N/A |
|10 | **Stock Data** | Debug mode, order‑entry mode, back‑order flag, current & to‑date periods, averaging flag, activity‑report run flag, audit number | Configures stock‑management behaviour | N/A |
|11 | **IRS Data** | IRS client name, P/L appropriation or capital account | Configures IRS‑related accounting | N/A |

**Messages and Errors**  
- **Invalid Input** – If the user enters a date that cannot be parsed or selects an unsupported option, the screen will display a message such as “Invalid Date” and prompt the user to re‑enter the value.  
- **Missing Data** – If a required field such as the print‑spool name (when printing is requested) or database credentials (when RDBMS is selected) is left blank, a notice will appear stating that the value must be provided.  
- **Operation Failure** – When the system attempts to write the parameters to the parameter file or database and encounters an I/O or connection error, a concise error message (“Error on system file processing” or “Error on RDBMS processing”) is shown and the user can choose to retry or abort.  
- **Security Warning** – If the program detects a mismatch in the stored user name (in older, protected builds) it will halt and advise contacting the system administrator.  

**User Flow Summary**  
The user starts the program and is first presented with the **User Data** screen, where they enter personal details, address, and global settings such as date format and printing preferences.  After confirming these values, they are taken to the **Verify** screen to accept or re‑edit.  The workflow continues through a series of configuration screens – **OPS**, **G/L**, **P/L**, **S/L**, **Stock**, and optionally **IRS** – each collecting a distinct set of parameters relevant to that domain.  At each step, the program validates input, offers helpful feedback, and allows the user to cancel or repeat entries.  Once all screens are completed and the user confirms, the program writes the consolidated parameter set to the system file (and, if configured, to the database).  Finally, the user may request a printed copy of the parameters; if chosen, the program outputs a formatted report via the CUPS spooler.  After successful completion, the program terminates, leaving the system ready for other operations.  

**Program Linkages**  
- maps04  
- maps99  
- SYSTEM   (used for printing the final report)

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by initializing the environment, parsing command‑line arguments, and opening the system parameter file. [Seen in: Init01-Main.]  
It reads the system record, converts dates, and displays the main menu for parameter entry. [Seen in: Menu-Option.]  
Based on the user’s selection, it dispatches to the appropriate parameter screens (user, system, G/L, S/L, P/L, stock) and finally prints a summary report. [Seen in: User-Params, System-Params, GL-Params, SL-Params, PL-Params, Stock-Params, Print-Params.]  
After all parameters are entered, the updated system record is rewritten to the file or RDBMS table and the program exits. [Seen in: Main-Exit.]

5.2 Initialization  
The program sets screen exception environment variables, displays the banner, and ensures that initialization occurs only once per run. [Seen in: Init01-Main.]  
It moves command‑line arguments into the working‑storage, opens the system file for input, performs mapser to load environment variables, and opens the RDBMS connection if configured. [Seen in: Init01-Main.]  
The system record is read, dates are converted, and screen data is prepared for display. [Seen in: Init01-Main.]  
If the system record size is smaller than expected, a diagnostic message is shown and the program aborts. [Seen in: Init01-Main.]

5.3 Core Processing  
Path: Init01-Main  
Trigger: Program start.  
Key steps: set environment, display banner, open system file, read system record, convert dates, call mapser, open RDBMS if needed.  
I/O: system file, RDBMS tables.  
Outcomes: system record loaded, environment set, RDBMS connection established.  
[Seen in: Init01-Main.]

Path: Menu-Option  
Trigger: After initialization, user selects to edit parameters.  
Key steps: display menu, accept user choice, rewrite system record, close system file, open RDBMS if used, update system record in RDBMS.  
I/O: system file, RDBMS.  
Outcomes: system record updated, ready for parameter entry.  
[Seen in: Menu-Option.]

Path: User-Params  
Trigger: User selects the user data screen.  
Key steps: display user screen, accept input, validate dates, set defaults, update screen.  
I/O: screen only.  
Outcomes: user parameters stored in system record.  
[Seen in: Main-User.]

Path: System-Params  
Trigger: User selects the system parameters screen.  
Key steps: display OPS data, accept input, validate, set defaults.  
I/O: screen only.  
Outcomes: system parameters updated.  
[Seen in: ops-main.]

Path: GL-Params  
Trigger: User selects the G/L parameters screen.  
Key steps: display GL data, accept input, validate, set defaults.  
I/O: screen only.  
Outcomes: G/L parameters updated.  
[Seen in: GL-Params-Main.]

Path: Print-Params  
Trigger: User selects to print a summary report.  
Key steps: prompt for print, open print file, write report, close file.  
I/O: print file.  
Outcomes: printed report generated.  
[Seen in: Print-Params.]

5.4 Termination  
The program closes any open files, writes the final system record to the file or RDBMS, and performs a GOBACK to terminate. [Seen in: Main-Exit.]  
Final status codes are set before exit to indicate success or error conditions. [Seen in: Main-Exit.]

---
## sys4LD
*[256/267]*

### Business/Functional Perspective
### Record 4 Table Load  

#### Program Purpose  
The program transfers the single system‑file record (Record 4) into a MySQL table. It reads the system parameters, verifies that database settings are available, writes the record, and reports whether the load succeeded or failed. By ensuring the system record is stored in the database, the program keeps configuration data synchronized, supports audit trails, and reduces the risk of inconsistencies between the file system and the database.  

#### Screen Interactions  
No direct screens. This program is run from the command line or a script and writes status messages to the system output.  

#### Messages and Errors  
* **File access problems** – If the system file cannot be opened or a record cannot be read, the program stops and reports a file‑reading error.  
* **Missing database configuration** – If database details are not supplied or the configuration file cannot be read, the program aborts with a missing‑parameter notice.  
* **Duplicate record** – If the record already exists in the table, the program rewrites it silently and counts the rewrite.  
* **Write failures** – Any other write error (e.g., permissions, connection issues) is reported with a generic “write error” message and the program terminates.  
* **Rollback / Commit issues** – If a rollback or commit cannot be completed, a notice is printed but the program continues to terminate normally.  
* **Completion status** – At the end the program prints the number of records processed, the number rewritten, and a final “EOJ - Load Sys4 Table” message.  

#### User Flow Summary  
1. The user (or an automated job) launches the program from the command line, optionally supplying up to two arguments.  
2. The program reads the system parameters from the file, loading any missing database details from a configuration file if necessary.  
3. It then attempts to write the single Record 4 to the MySQL table. If the record already exists, it updates the existing row; otherwise, it inserts a new one.  
4. Throughout the operation, the program writes progress and error messages to the console.  
5. When finished, it reports how many records were processed and rewritten, performs a commit, and prints a final “EOJ” message before exiting.  

#### Program Linkages  
- acas-get-params  
- sys4MT  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by parsing command line arguments, initializing logging, and opening the System file to retrieve database parameters. [Seen in: aa000-main-start.]  
It then loads RDBMS settings, optionally from acas.param, and overrides file system flags before opening the target RDBMS table via the sys4MT data access layer. [Seen in: aa010-Proc-Override.]  
The main processing loop writes the single System-Record-4 to the database, handling duplicate keys and errors, and finally outputs statistics before closing files and exiting. [Seen in: aa010-Read, aa999-Finish.]

5.2 Initialization  
The program performs argument validation, sets up logging parameters, and clears the log system and file numbers. [Seen in: aa000-main-start.]  
It opens the System-File, reads the system record, and populates the WS-System-Record and RDBMS variables, falling back to acas-get-params if necessary. [Seen in: aa000-main-start.]  
File system flags are reset to indicate RDB usage, and the RDBMS connection is established via acas000-Open. [Seen in: aa010-Proc-Override, acas000-Open.]

5.3 Core Processing  
Path: System Parameter Load  
Trigger: start of aa000-main-start.  
Key steps: open System-File, read record, load RDBMS settings, possibly call acas-get-params.  
I/O: System-File.  
Outcomes: sets RDBMS variables, may go to aa010-Proc-Override.  
[Seen in: aa000-main-start.]

Path: RDB Open  
Trigger: after override.  
Key steps: set file system flags, perform acas000-Open.  
I/O: none.  
Outcomes: RDB opened, ready for write.  
[Seen in: aa010-Proc-Override, acas000-Open.]

Path: Record Write  
Trigger: aa010-Read.  
Key steps: write record via acas000-Write, handle duplicate key by rewriting, update counters.  
I/O: System-Record-4 via acas000.  
Outcomes: counters updated, may go to aa999-Finish.  
[Seen in: aa010-Read.]

Path: Error Handling  
Trigger: fs-reply not zero after write.  
Key steps: call aa100-Check-4-Errors, display error messages, possibly rollback.  
I/O: none.  
Outcomes: may go to aa999-Finish.  
[Seen in: aa100-Check-4-Errors.]

Path: Finish  
Trigger: aa999-Finish.  
Key steps: output record counts, close RDB via acas000-Close, close System-File, exit.  
I/O: System-File, RDB via acas000-Close.  
Outcomes: program terminates.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program closes the System file, closes the RDBMS connection if not already closed, and writes a final EOJ message before returning control. [Seen in: aa999-Finish.]  
The final GOBACK statement ends the program, returning the return-code set earlier. [Seen in: aa999-Finish.]

---
## sys4MT
*[257/267]*

### Business/Functional Perspective
### Data Access Layer Function  

**Program Purpose**  
This program provides a single, reusable routine for accessing and manipulating the “SYSTOT-REC” ledger‑totals table in a relational database.  It is invoked by other ACAS modules to open a database connection, read the next ledger record, write new records, or update existing records.  By centralising database logic, the program ensures consistent data validation, error handling, and audit logging, thereby reducing duplication of code, preventing key conflicts, and simplifying maintenance across the accounting system.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
* Successful operation – the routine reports success through a zero status code.  
* End of data – when there are no more rows to read, the routine signals an end‑of‑file condition.  
* Duplicate key – if an insert or update would create a duplicate ledger key, the routine reports a duplicate‑key error.  
* Key‑not‑found or key‑out‑of‑range – when the requested record does not exist or the supplied key is invalid, an error status is returned.  
* SQL or database errors – any database‑level error (e.g., connection failure, syntax error) is captured and returned as a generic error status, with details available in the logging facility for troubleshooting.  

**User Flow Summary**  
A calling module passes a linkage area that includes the requested file function (open, close, read‑next, write, or rewrite) and, when required, a data record to be stored or updated.  
* For **open**, the program establishes a connection to the database and returns a ready‑to‑use state.  
* For **read‑next**, it selects the next ledger row, loads the record into the supplied data buffer, and signals whether a row was returned or the end of the table was reached.  
* For **write**, it inserts a new ledger record and reports success or duplicate‑key errors.  
* For **rewrite**, it updates the existing ledger record identified by the primary key and reports success or any database errors.  
* For **close**, it terminates the database connection.  
Throughout the process, the routine updates status fields (FS‑Reply and WE‑Error) and, if testing is enabled, writes diagnostic logs.  

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry performs environment setup and initialises variables before dispatching based on File-Function. [Seen in: ba-ACAS-DAL-Process.]  
Depending on File-Function, control transfers to one of the processing paragraphs: Open, Close, Read-Next, Write, Rewrite or Bad-Function. [Seen in: ba-ACAS-DAL-Process.]  
After the selected operation completes, the program performs cleanup and exits via ba999-end or ba999-exit. [Seen in: ba999-end.]

5.2 Initialization  
Accepts environment line count and ensures a minimum of 24 lines for screen handling. [Seen in: ba-ACAS-DAL-Process.]  
Sets screen exception and escape handling flags to enable special key detection. [Seen in: ba-ACAS-DAL-Process.]  
Clears all error and logging fields and initializes the MySQL command buffer. [Seen in: ba010-Initialise.]

5.3 Core Processing  
Path: Open  
Trigger: File-Function = 1  
Key steps: set MySQL connection parameters from linkage, perform MYSQL-1000-OPEN, check fs-reply.  
I/O: MySQL connection.  
Outcomes: sets ws-No-Paragraph, WS-File-Key, Most-Cursor-Set, fs-reply if error.  
[Seen in: ba020-Process-Open.]

Path: Close  
Trigger: File-Function = 2  
Key steps: if cursor active perform ba998-Free, perform MYSQL-1980-CLOSE.  
I/O: MySQL connection.  
Outcomes: sets ws-No-Paragraph, WS-File-Key.  
[Seen in: ba030-Process-Close.]

Path: Read-Next  
Trigger: File-Function = 4  
Key steps: if cursor not active build WHERE clause, perform SELECT, store result, fetch next record, handle EOF, unload HVs to record.  
I/O: MySQL SELECT, FETCH, table SYSTOT-REC.  
Outcomes: sets fs-reply, WE-Error, WS-File-Key, Most-Cursor-Set, System-Record-4.  
[Seen in: ba040-Process-Read-Next.]

Path: Write  
Trigger: File-Function = 5  
Key steps: load HVs from record, perform INSERT, handle duplicate key, set status.  
I/O: MySQL INSERT, table SYSTOT-REC.  
Outcomes: sets fs-reply, WE-Error, SQL-Err, SQL-Msg.  
[Seen in: ba070-Process-Write.]

Path: Rewrite  
Trigger: File-Function = 7  
Key steps: load HVs, build WHERE clause, perform UPDATE, handle errors, set status.  
I/O: MySQL UPDATE, table SYSTOT-REC.  
Outcomes: sets fs-reply, WE-Error, SQL-Err, SQL-Msg.  
[Seen in: ba090-Process-Rewrite.]

Path: Bad-Function  
Trigger: File-Function other  
Key steps: set error codes 990, 99.  
I/O: none.  
Outcomes: sets WE-Error, Fs-Reply.  
[Seen in: ba100-Bad-Function.]

5.4 Termination  
If a cursor is active, ba998-Free releases the MySQL result set and resets cursor state. [Seen in: ba998-Free.]  
ba999-end optionally logs activity and then exits the program via ba999-exit. [Seen in: ba999-end.]  
The exit paragraph ba999-exit performs the final program exit. [Seen in: ba999-exit.]

---
## systemLD
*[258/267]*

### Business/Functional Perspective
### System Parameter Load

**Program Purpose**  
This routine loads the contents of the system parameters file into the MySQL “System” table. It validates that the database connection details are present, resolves missing settings from an alternative parameters file if necessary, and writes each record while handling duplicate entries and transaction integrity. The result is an up‑to‑date system configuration table that other parts of the accounting system rely on for correct operation. By ensuring the table is refreshed in a single batch run, the program reduces the risk of configuration drift and supports audit readiness.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **File access failures** – If the system file cannot be opened or read, a descriptive message is displayed and the job stops.  
- **Missing or invalid database parameters** – When required fields (DB name, user, host, port, socket) are absent or the alternative parameters file cannot be read, the job reports the problem and aborts.  
- **Duplicate record handling** – If a record already exists in the table, the program updates it instead of creating a new entry, notifying the user of the rewrite.  
- **Database write errors** – Any failure to write a record (other than a duplicate) triggers a detailed error message showing the SQL error, message, and state, then the job terminates.  
- **Transaction failures** – Commit or rollback operations that fail are reported, and the job stops to prevent inconsistent data.  
- **General operation status** – At completion the program prints a summary of records processed, records rewritten, and log entries generated.

**User Flow Summary**  
1. The user runs the program (typically from a script or command line).  
2. The routine reads the system file to gather configuration data.  
3. It verifies that database connection details are available; if not, it attempts to obtain them from a secondary parameters file.  
4. The program opens a connection to the MySQL database and prepares to write each system record.  
5. For each record, it attempts to insert it; if the record already exists it rewrites it, otherwise it inserts a new entry. Duplicate or write errors are reported immediately.  
6. After all records are processed, the routine commits the transaction (or rolls back if a fatal error occurred).  
7. A final summary message is printed, and the program exits, leaving the system table updated and ready for use by the rest of the application.

**Program Linkages**  
- `acas-get-params`  
- `systemMT`  
- `MySQL_rollback`  
- `MySQL_commit`  
- `ACAS-Sysout`

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program starts by retrieving command line arguments, initializing logging, and opening the system file to read RDBMS parameters. [Seen in: aa000-main-start.]  
It then loads RDBMS settings either from the system record or from acas.param, sets up database connection parameters, and opens the RDB via systemMT. [Seen in: aa010-Proc-Override.]  
The main processing loop reads each system record, writes it to the database, handles duplicate or error conditions, and finally commits or rolls back before closing files and exiting. [Seen in: aa010-Read.]

5.2 Initialization  
The program performs zz020-Get-Program-Args to capture up to two command line arguments and sets up the SO-Print buffer and logging flags. [Seen in: aa000-main-start.]  
It opens the System-File for input, verifies the file reply, and reads the first record to obtain RDBMS parameters; if missing, it attempts to read acas.param via acas-get-params. [Seen in: aa000-main-start.]  
Database connection variables (DB-Schema, DB-UName, etc.) are initialized from the system record or acas.param, and the RDBMS flat status is forced to "66" before calling acas000-Open to establish the RDB connection. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: System File Read and RDB Write  
Trigger: aa010-Read is performed after opening the system file and setting RDBMS flat status.  
Key steps: Move system record to WS-System-Record, increment input record count, set File-System-Used flags, call acas000-Write to insert record into RDB, check SQL-State and fs-reply for duplicate or error, handle duplicate by rewriting or incrementing rewrite count, otherwise increment output record count.  
I/O: System-File, RDB via systemMT (acas000).  
Outcomes: fs-reply and WE-Error may be set; duplicate records increment ws-Rec-Cnt-R-Out; successful inserts increment ws-Rec-Cnt-Out; errors cause early exit to aa999-Finish.  
[Seen in: aa010-Read.]

Path: Error Handling Path  
Trigger: fs-reply not equal to zero after acas000-Write or acas000-ReWrite.  
Key steps: Display error messages using Call-Sysout, output SQL error details, and go to aa999-Finish.  
I/O: None beyond display.  
Outcomes: Program terminates with error status, no commit.  
[Seen in: aa010-Read.]

Path: Commit Path  
Trigger: aa030-Commit is called after successful processing before finish.  
Key steps: Call MySQL_commit to commit transaction.  
I/O: MySQL commit via external call.  
Outcomes: Transaction committed; return-code may be checked.  
[Seen in: aa030-Commit.]

Path: Rollback Path  
Trigger: aa020-Rollback is called when errors occur or before exit if needed.  
Key steps: Call MySQL_rollback to undo transaction.  
I/O: MySQL rollback via external call.  
Outcomes: Transaction rolled back; return-code may be checked.  
[Seen in: aa020-Rollback.]

Path: Finish Path  
Trigger: aa999-Finish is executed at program end or after error.  
Key steps: Output record counts and log rec count via Call-Sysout, close RDB via acas000-Close, close System-File, display an end‑of‑job message, and goback.  
I/O: System-File, RDB via acas000-Close, display outputs.  
Outcomes: Program exits with return-code 0 unless earlier set.  
[Seen in: aa999-Finish.]

5.4 Termination  
The program closes the RDB connection using acas000-Close, closes the system file, displays an end‑of‑job message, and returns control with goback. [Seen in: aa999-Finish.]  
Any pending commit or rollback is performed via aa030-Commit or aa020-Rollback before final exit. [Seen in: aa030-Commit, aa020-Rollback.]

---
## systemMT
*[259/267]*

### Business/Functional Perspective
### System Record Management  

**Program Purpose**  
This program provides a single point of access to the system configuration record used by the accounting system.  It opens the database connection, retrieves the current system settings, and allows the record to be inserted or updated.  By guaranteeing that only one system record exists and that all changes are applied atomically, the program helps maintain consistent business parameters such as VAT rates, database credentials, and operating mode flags.  This consistency reduces configuration errors and supports reliable system operation.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
- If the system record cannot be found or the data set is empty, the program reports “No data available” and indicates that the end of data has been reached.  
- If a duplicate record is attempted to be inserted, the program reports a “Duplicate record” error.  
- Database‑level problems (e.g., connection failures or SQL errors) are reported as “Database error” with a brief description of the issue.  
- Other unexpected conditions (invalid keys, missing tables, or other technical failures) result in a generic “Unexpected error” message.  

**User Flow Summary**  
A system administrator or a configuration module initiates a request to view or change the system settings.  The program first opens the database connection, then retrieves the single system record.  The record’s values (e.g., company details, VAT rates, and operational flags) are returned to the calling module, which can display them or use them for further processing.  If the user wishes to modify the settings, the updated record is passed back to the program, which writes the new values to the database or updates the existing row.  Throughout the process, the program ensures that only one system record exists and that any errors are clearly reported to the caller.  

**Program Linkages**  
- fhlogger  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program starts in the **ba-ACAS-DAL-Process** paragraph, initializing environment settings and dispatching based on the File-Function value. [Seen in: ba-ACAS-DAL-Process.]  
It then evaluates the File-Function and performs one of the following actions: open the database (**ba020-Process-Open**), close the database (**ba030-Process-Close**), read the next record (**ba040-Process-Read-Next**), write a new record (**ba070-Process-Write**), rewrite an existing record (**ba090-Process-Rewrite**), or report an invalid function (**ba100-Bad-Function**). [Seen in: ba020-Process-Open, ba030-Process-Close, ba040-Process-Read-Next, ba070-Process-Write, ba090-Process-Rewrite, ba100-Bad-Function.]  
After completing the requested operation, control flows to **ba999-End**, which performs optional logging and then exits the program via **ba999-exit**. [Seen in: ba999-End, ba999-exit.]

5.2 Initialization  
The program accepts the number of environment lines, sets screen exception handling, and initializes key working‑storage variables to spaces or zero in the **ba010-Initialise** paragraph. [Seen in: ba010-Initialise.]  
It then evaluates the File-Function value to determine the operation to perform, dispatching to the appropriate process paragraph. [Seen in: ba-ACAS-DAL-Process.]

5.3 Core Processing  
Path: Open Database  
Trigger: File‑Function = 1  
Key steps: Perform MYSQL‑1000‑OPEN to establish a MySQL connection, set WS‑File‑Key to “OPEN SYSTEM”, and mark the cursor as inactive.  
I/O: MYSQL‑1000‑OPEN.  
Outcomes: FS‑Reply set to 0 on success; on failure control jumps to ba999‑End.  
[Seen in: ba020-Process-Open.]  

Path: Close Database  
Trigger: File‑Function = 2  
Key steps: Perform MYSQL‑1980‑CLOSE to terminate the MySQL connection, set WS‑File‑Key to “CLOSE SYSTEM”.  
I/O: MYSQL‑1980‑CLOSE.  
Outcomes: FS‑Reply set to 0.  
[Seen in: ba030-Process-Close.]  

Path: Read Next Record  
Trigger: File‑Function = 4  
Key steps: If the cursor is not active, build a SELECT query with a key condition, execute it via MYSQL‑1210‑COMMAND, store the result set via MYSQL‑1220‑STORE‑RESULT, then fetch the next record with MYSQL‑1239‑EXIT and load host variables using bb100‑UnloadHVs.  
I/O: MYSQL‑1210‑COMMAND, MYSQL‑1220‑STORE‑RESULT, MYSQL‑1239‑EXIT.  
Outcomes: FS‑Reply 0 and WE‑Error 0 on success; if no data, FS‑Reply 10 and WE‑Error 10 (EOF).  
[Seen in: ba040-Process-Read-Next.]  

Path: Write Record  
Trigger: File‑Function = 5  
Key steps: Load host variables via bb000‑HV‑Load, construct an INSERT statement, and execute it with MYSQL‑1210‑COMMAND.  
I/O: MYSQL‑1210‑COMMAND.  
Outcomes: FS‑Reply 0 and WE‑Error 0 on success; duplicate key sets FS‑Reply 22; other errors set FS‑Reply 99.  
[Seen in: ba070-Process-Write.]  

Path: Rewrite Record  
Trigger: File‑Function = 7  
Key steps: Load host variables via bb000‑HV‑Load, construct an UPDATE statement, and execute it with MYSQL‑1210‑COMMAND.  
I/O: MYSQL‑1210‑COMMAND.  
Outcomes: FS‑Reply 0 and WE‑Error 0 on success; errors set FS‑Reply 99 and WE‑Error 994.  
[Seen in: ba090-Process-Rewrite.]  

Path: Bad Function  
Trigger: any other File‑Function value  
Key steps: Set WE‑Error to 990 and FS‑Reply to 99.  
I/O: none.  
Outcomes: error status returned to caller.  
[Seen in: ba100-Bad-Function.]  

5.4 Termination  
Upon reaching **ba999-End**, the program optionally logs the operation via Ca‑Process‑Logs if Testing‑1 is set. [Seen in: ba999-End.]  
The program then exits cleanly through the **ba999-exit** paragraph. [Seen in: ba999-exit.]

---
## systemRES
*[260/267]*

### Business/Functional Perspective
### System File Restore

**Program Purpose**  
The program restores the four critical system records from a backup sequential file into the active system ISAM file. It verifies each record’s integrity, reports any read errors, and provides a summary of how many records were processed. By ensuring that the system file contains the correct baseline data, it supports reliable operation, compliance with audit requirements, and reduces the risk of data loss.

**Screen Interactions**  
1. **System Record Screen** – Displays the contents of the first system record, shows the text “System Rec”, prompts the user to press *Enter* to continue.  
2. **Default Record Screen** – Shows the second record’s contents, displays “Default Rec”, and waits for the user to press *Enter*.  
3. **Final Record Screen** – Presents the third record, labeled “Final Rec”, and pauses for user confirmation.  
4. **System 4 Record Screen** – Displays the fourth record, labeled “System 4 Rec”, and requires the user to press *Enter* before proceeding.  
5. **Summary Screen** – After all records are written, it shows the total number of records read and written, then prompts the user to press *Enter* before the program terminates.

**Messages and Errors**  
- If the backup file cannot be opened, the program displays a message indicating a problem opening the system file and then exits.  
- When a record cannot be read (e.g., due to corruption or missing data), a notice is shown for that specific record (“Not set up ?”) and the program stops.  
- Upon successful completion, a summary of records processed is displayed.  
- If the database parameters are missing or improperly configured, the program informs the user and aborts.

**User Flow Summary**  
The user launches the program, which immediately attempts to open the backup file `system.seq`. The program then reads each of the four system records one by one. After each read, the record’s content is shown on the screen, and the user is prompted to press *Enter* to proceed. If any read fails, an error message is displayed and the process halts. Once all four records are successfully written to the system ISAM file, a final summary of the number of records in and out is shown. The program then closes the files and exits, returning control to the calling environment.

**Program Linkages**  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins at paragraph **aa000-Main-Start**, performing argument retrieval via **zz020-Get-Program-Args** and initializing control variables. It opens the sequential system file **System-File-Seq**, reads four system records in order, and writes them to the output file **System-File** while tracking record counts. Finally, it logs a summary through **Call-Sysout**, closes files, sets the return code to zero, and exits with **GOBACK**. [Seen in: aa000-Main-Start.]

5.2 Initialization  
The program sets logging flags and counters to zero, then opens **System-File-Seq** for input; if the open fails, it displays an error message, closes the file, sets return-code 128, and exits. It also initializes secondary record structures (**WS-System-Record**, **Default-Record**, **Final-Record**, **System-Record-4**) to zero. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: Read System Records  
Trigger: Successful open of **System-File-Seq**  
Key steps: sequentially read four records into **WS-System-Record**, **Default-Record**, **Final-Record**, **System-Record-4**; increment **ws-Rec-Cnt-In** for each successful read; display prompts and accept user input after each read.  
I/O: **System-File-Seq**  
Outcomes: four system records loaded into working storage, **ws-Rec-Cnt-In** updated.  
[Seen in: aa000-Main-Start.]

Path: Write System Records  
Trigger: Completion of all four reads  
Key steps: open **System-File** for output; write each of the four records with rrn values 1‑4, incrementing **ws-Rec-Cnt-Out** after each write; close both files.  
I/O: **System-File**  
Outcomes: records written to output file, **ws-Rec-Cnt-Out** updated.  
[Seen in: aa000-Main-Start.]

Path: Error Handling on Open  
Trigger: **fs-reply** not zero after attempting to open **System-File-Seq**  
Key steps: display program name and error message, accept user reply, close the file, set **return-code** to 128, and exit with **GOBACK**.  
I/O: **System-File-Seq**  
Outcomes: program terminates with error status.  
[Seen in: aa000-Main-Start.]

Path: Logging Summary  
Trigger: After closing the files and before exiting  
Key steps: construct **SO-Print** string with record counts, call **Call-Sysout** to log the summary, then log a "CLOSE" message via another **Call-Sysout** call.  
I/O: None (calls external **ACAS-Sysout**)  
Outcomes: summary information written to log.  
[Seen in: aa000-Main-Start.]

5.4 Termination  
The program sets **Return-Code** to zero, then exits with **GOBACK** after all processing and logging are complete. [Seen in: aa000-Main-Start.]

---
## systemUNL
*[261/267]*

### Business/Functional Perspective
### System UnLoad Backup

**Program Purpose**  
This program creates a backup copy of the system parameter file by exporting all four system records to a sequential `.seq` file. It ensures that core configuration data, defaults, final accounts and totals are safely stored for future restoration. The backup also records database connection details and logs status messages for audit and troubleshooting. By keeping a reliable copy, the system protects against file corruption or incompatible ISAM changes.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the system file cannot be opened, a file‑open error is shown.  
- When reading any of the four system records fails, an error message indicates the specific record that could not be read.  
- If database parameters are missing, a message alerts the user that the database is not configured.  
- General status messages are logged to `SYS‑DISPLAY.log` and can be reviewed for troubleshooting.

**User Flow Summary**  
The user runs the program from the command line (no arguments required). The program opens the system file and reads each of the four records. Any read errors are displayed to the user. After successfully reading, the program writes all four records to a sequential file named `system.seq`. Throughout the process, it logs progress and any issues to `SYS‑DISPLAY.log`. The program then exits with a return code indicating success or failure.

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in paragraph **aa000-Main-Start**, performing **zz020-Get-Program-Args** to parse command line arguments and initialize logging variables. [Seen in: aa000-Main-Start.]  
It opens the input **System-File**, reads the four system records (records 1–4) sequentially, handling any read errors and counting records read. [Seen in: aa000-Main-Start.]  
After loading the system record, it opens an output sequential file **system-file-seq**, writes the four records in order, reports counts via **Call-Sysout**, and then exits with a return code of zero. [Seen in: aa000-Main-Start.]

5.2 Initialization  
The program sets **WS-Log-System** to 0 and **WS-Log-File-no** to 10, then clears record counters and initializes secondary records via the INITIALISE statement. [Seen in: aa000-Main-Start.]  
It opens the input **System-File** and verifies the status code, displaying error messages and aborting if the file cannot be opened. [Seen in: aa000-Main-Start.]

5.3 Core Processing  
Path: **Read System Record (Record 1)**  
Trigger: The first read of **System-File** after opening it.  
Key steps: read record into **System-Record**, check **fs-reply**, increment **ws-Rec-Cnt-In** or **ws-Rec-Cnt-R-Out** accordingly.  
I/O: **System-File**.  
Outcomes: **ws-Rec-Cnt-In** incremented on success; error message displayed and program may abort if **fs-reply** non‑zero.  
[Seen in: aa000-Main-Start.]

Path: **Read Default Record (Record 2)**  
Trigger: Setting **rrn** to 2 and reading **System-File**.  
Key steps: read into **Default-Record**, check **fs-reply**, update counters.  
I/O: **System-File**.  
Outcomes: **ws-Rec-Cnt-In** incremented on success; error message displayed and **ws-Rec-Cnt-R-Out** incremented on failure.  
[Seen in: aa000-Main-Start.]

Path: **Read Final Record (Record 3)**  
Trigger: Setting **rrn** to 3 and reading **System-File**.  
Key steps: read into **Final-Record**, check **fs-reply**, update counters.  
I/O: **System-File**.  
Outcomes: similar counter updates and error handling.  
[Seen in: aa000-Main-Start.]

Path: **Read System Record 4 (Record 4)**  
Trigger: Setting **rrn** to 4 and reading **System-File**.  
Key steps: read into **System-Record-4**, check **fs-reply**, update counters.  
I/O: **System-File**.  
Outcomes: similar counter updates and error handling.  
[Seen in: aa000-Main-Start.]

Path: **Write Records to Seq File**  
Trigger: After all four records are read, open output **system-file-seq** and write each record sequentially.  
Key steps: open output, write **System-Record-Seq** from **System-Record**, write from **Default-Record**, write from **Final-Record**, write from **System-Record-4**, close files, set **ws-Rec-Cnt-Out** to 4.  
I/O: **System-File-Seq**, **System-File**.  
Outcomes: records written to .seq file, counters updated, status messages sent via **Call-Sysout**.  
[Seen in: aa000-Main-Start.]

5.4 Termination  
The program closes both the sequential output file and the input system file, then outputs a final status line and a "CLOSE" message via **Call-Sysout** before setting **Return-Code** to zero. [Seen in: aa000-Main-Start.]  
It then performs a **GOBACK** to terminate execution. [Seen in: aa000-Main-Start.]

---
## valueLD
*[262/267]*

### Business/Functional Perspective
### Stock Value Table Load  

**Program Purpose**  
The program loads a master list of stock values from a flat file into a MySQL database table. It validates that the database connection parameters are available and that the source file exists before starting the import. By performing the load in a single run, the program helps maintain an up‑to‑date value table, ensuring that downstream accounting processes work with accurate stock prices. Successful completion is reported to the operator, while any problems are flagged for immediate attention.

**Screen Interactions**  
No direct screens. This program is run after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- **Missing or unreadable value file** – The program stops and reports that no value file was found or could not be opened.  
- **Database connection issues** – If the database parameters are missing or the connection fails, an error message is displayed and the program aborts.  
- **Record‑level errors** – Duplicate keys or write failures for individual records are noted; duplicate records are skipped and counted.  
- **General load errors** – Any unexpected read or write problem is reported with diagnostic details.  
- **Completion summary** – At the end, the program prints the number of records read, loaded, and rewritten, and confirms successful completion.

**User Flow Summary**  
The operator runs the program, optionally providing up to two command‑line arguments that identify the target file and a test flag. The program first checks that the system configuration is present and that the database can be accessed. It then attempts to open the value file; if the file is missing, the operator is notified and the run ends. When the file is available, the program reads each record, attempts to insert it into the MySQL table, and handles duplicates by updating the existing row. Throughout the process, counts of processed and rewritten records are maintained. After all records are processed, the program reports totals, writes a closing message, and terminates cleanly.

**Program Linkages**  
- acas-get-params  
- acas013  
- MySQL_rollback  
- MySQL_commit  
- ACAS-Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program starts in **aa000-main-start**, processes command‑line arguments, opens the system parameter file, and initializes database connection parameters before branching to **aa010-Proc-Override**. [Seen in: aa000-main-start.]  
**aa010-Proc-Override** opens the value data file for input and the target MySQL table via acas013, handling missing file or database errors, and then enters the main record processing loop at **aa010-Read**. [Seen in: aa010-Proc-Override.]  
**aa010-Read** repeatedly reads each value record, writes it to the database, handles duplicate key conditions by rewriting or counting, and upon EOF or fatal error exits to **aa999-Finish** where resources are closed and a summary is printed. [Seen in: aa010-Read.]

5.2 Initialization  
The program begins by performing **zz020-Get-Program-Args**, printing the program name to the screen, and setting logging parameters before opening the System-File for reading. [Seen in: aa000-main-start.]  
It reads the system record, validates that the RDBMS database name is present, and if necessary invokes **acas-get-params** to load database connection details from acas.param. [Seen in: aa000-main-start.]  
If the database is not configured or the system file cannot be opened, the program displays an error message and aborts with a non‑zero return code. [Seen in: aa000-main-start.]  
After successful parameter loading, **aa010-Proc-Override** initializes file‑system flags, opens the value input file via acas013‑Open‑Input, and opens the MySQL table via acas013‑Open, preparing for record processing. [Seen in: aa010-Proc-Override.]

5.3 Core Processing  
Path: Main Record Processing Loop  
Trigger: **aa010-Read** called after file openings.  
Key steps: read next value record, increment input count, write record to MySQL, handle duplicate key errors by rewriting or counting, increment output or rewrite counts, loop back to read next.  
I/O: Value file, MySQL table.  
Outcomes: record counts updated, duplicate records rewritten or counted, loop continues until EOF or error.  
[Seen in: aa010-Read.]

Path: Missing Value File  
Trigger: **acs013‑Open‑Input** returns FS‑Reply 35.  
Key steps: print “No Value file present” message, close System‑File, close value file, goback.  
I/O: none.  
Outcomes: program terminates without processing any records.  
[Seen in: aa010-Proc-Override.]

Path: Database Open Failure  
Trigger: **acs013‑Open** returns FS‑Reply non‑zero.  
Key steps: print error message, close System‑File, close value file, set return‑code 16, goback.  
I/O: MySQL table.  
Outcomes: program terminates with database error status.  
[Seen in: aa010-Proc-Override.]

Path: Duplicate Key Handling  
Trigger: SQL‑State “23000”, FS‑Reply 22 or 99, or SQL‑Err 1062/1022 during write.  
Key steps: clear FS‑Reply and WE‑Error, rewrite record, if rewrite fails print error, else increment rewrite count, continue loop.  
I/O: MySQL table.  
Outcomes: duplicate records are rewritten, rewrite count incremented, processing continues.  
[Seen in: aa010-Read.]

Path: Fatal Read Error  
Trigger: FS‑Reply non‑zero after **acs013‑Read‑Next**.  
Key steps: print error details, set return‑code 16, go to **aa999‑Finish**.  
I/O: Value file.  
Outcomes: program terminates with error status.  
[Seen in: aa010-Read.]

5.4 Termination  
In **aa999‑Finish** the program prints record counts, closes the MySQL table and system file, then closes the value file and signals end of job before returning to the caller. [Seen in: aa999-Finish.]  
The program exits with a GOBACK, leaving the return‑code set to indicate success or the type of error encountered. [Seen in: aa999-Finish.]

---
## valueMT
*[263/267]*

### Business/Functional Perspective
### Value Table Access

**Program Purpose**  
This routine provides a single point of access to the *VALUEANAL‑REC* table that stores value analysis records. It can open or close the database connection, read records sequentially or by key, search for the first matching record, insert new entries, update existing ones, delete single records or clear the entire table, and return status information. The function supports auditability and data integrity by ensuring that each operation reports success or a clear error condition to the calling application.

**Screen Interactions**  
No direct screens. This program is invoked by other modules that perform data entry and simply receives results back from this routine.

**Messages and Errors**  
The program reports user‑relevant outcomes in plain language.  
- **Success** – Operation completed and the requested record (if any) is returned.  
- **End of Data** – No more records are available when reading sequentially.  
- **Record Not Found** – A search or indexed read did not match any record.  
- **Duplicate Key** – Attempt to write a record that already exists.  
- **Delete/Rewrite Failure** – An error occurred while removing or updating a record.  
- **Database Error** – Any other issue with the database connection or SQL statement.  

All error messages are communicated through status fields (`FS-Reply`, `WE-Error`, `SQL-Err`, `SQL-Msg`) rather than raw codes.

**User Flow Summary**  
A calling program supplies the data record to be processed, the requested file‑access function (open, close, read, write, delete, etc.), and any key values needed.  
1. If the function is **Open**, the routine establishes a database connection.  
2. For **Close**, it terminates the connection.  
3. A **Read‑Next** fetches the next record in sequence; a **Read‑Indexed** or **Start** search retrieves the first matching record based on a key.  
4. A **Write** inserts a new record; **Rewrite** updates an existing record.  
5. **Delete** removes a single record; **Delete‑All** clears the whole table.  
After each action, the routine returns the record (if applicable) and status indicators that tell the caller whether the operation succeeded, failed, or yielded no data.

**Program Linkages**  
- MySQL_errno  
- MySQL_sqlstate  
- MySQL_error  
- MySQL_fetch_record  
- MySQL_free_result  
- MySQL_query  
- fhlogger

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
Program entry performs environment setup, screen exception configuration, and initializes working storage before dispatching to a function‑specific paragraph based on File‑Function. [Seen in: ba010-Initialise.]  
The dispatch uses an EVALUATE on File‑Function to branch to paragraphs that open, close, read, write, delete, or rewrite the VALUEANAL‑REC table via MySQL. [Seen in: ba020-Process-Open.]  
After the requested operation, the program performs cleanup, optional logging, and exits with FS‑Reply and WE‑Error status codes. [Seen in: ba999-end.]

5.2 Initialization  
On entry, the program accepts environment line count, sets screen exception flags, and clears error and SQL status fields. [Seen in: ba010-Initialise.]  
It also prepares MySQL connection parameters from linkage areas and performs an initial open if File‑Function=1. [Seen in: ba020-Process-Open.]

5.3 Core Processing  
Path: Process‑Open  
Trigger: File‑Function=1  
Key steps: Build MySQL connection strings from linkage areas, call MYSQL‑1000‑OPEN, set cursor inactive, and record operation.  
I/O: MySQL connection.  
Outcomes: fs‑reply set to 0 on success, 99 on error.  
[Seen in: ba020-Process-Open.]

Path: Process‑Read‑Next (including Reread)  
Trigger: File‑Function=3 or subsequent FETCH after a SELECT.  
Key steps: If cursor inactive, construct SELECT with key >= '000', execute, store result, set cursor active; otherwise fetch next record via MySQL_fetch_record.  
I/O: VALUEANAL‑REC table via SELECT and FETCH.  
Outcomes: fs‑reply 0 with record data, 10 for EOF, 99 on error.  
[Seen in: ba040-Process-Read-Next, ba041-Reread.]

Path: Process‑Start  
Trigger: File‑Function=9.  
Key steps: Validate access‑type, construct SELECT with comparison operator based on Access‑Type, execute, set cursor active if rows returned.  
I/O: VALUEANAL‑REC table via SELECT.  
Outcomes: fs‑reply 0 with cursor active, 21 if no rows, 99 on error.  
[Seen in: ba060-Process-Start.]

Path: Process‑Write  
Trigger: File‑Function=5.  
Key steps: Load host variables from VALUEANAL‑REC, build INSERT statement, execute, check row count and duplicate key errors.  
I/O: VALUEANAL‑REC table via INSERT.  
Outcomes: fs‑reply 0 on success, 22 for duplicate key, 99 on other errors.  
[Seen in: ba070-Process-Write.]

Path: Process‑Delete  
Trigger: File‑Function=8.  
Key steps: Build DELETE WHERE key=..., execute, verify row count.  
I/O: VALUEANAL‑REC table via DELETE.  
Outcomes: fs‑reply 0 on success, 99 on error.  
[Seen in: ba080-Process-Delete.]

Path: Process‑Delete‑All  
Trigger: File‑Function=6.  
Key steps: Build DELETE FROM VALUEANAL‑REC without WHERE, execute, handle empty table case.  
I/O: VALUEANAL‑REC table via DELETE.  
Outcomes: fs‑reply 0 on success, 99 on error.  
[Seen in: ba085-Process-Delete-All.]

5.4 Termination  
Before exiting, the program frees any active MySQL result set, optionally logs the operation, and performs a GOBACK. [Seen in: ba998-Free, ba999-end.]  
The final status is communicated via FS‑Reply and WE‑Error fields in the linkage area. [Seen in: ba999-end.]

---
## valueRES
*[264/267]*

### Business/Functional Perspective
### Value File Restore  

**Program Purpose**  
The program rebuilds the main value table from a sequential backup file named *value.seq*. It copies each record into the active ISAM file, ensuring that the accounting data is restored correctly after a corruption or migration. All actions and any problems are written to the system log, giving the organization a clear audit trail and reducing the risk of data loss.  

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.  

**Messages and Errors**  
* **Missing input file** – If *value.seq* does not exist, the program reports “No value Seq file to process” and stops.  
* **Output file open failure** – If the program cannot create the target ISAM file, it logs “Failed on open Value file …” with the error code.  
* **Read error** – Any problem reading a record from *value.seq* triggers a message that includes the error code.  
* **Write error** – If a record cannot be written to the ISAM file, a message “Write error on .dat file” is logged.  
* **Completion summary** – After all records are processed, the program logs the number of records read and written.  
* **Close notifications** – The program logs simple “CLOSE” entries when files are closed.  

**User Flow Summary**  
1. The user initiates the restore job (typically from a batch schedule or command line).  
2. The program checks for the presence of the backup file *value.seq*.  
3. If the file exists, it opens the active value table for writing.  
4. The program reads each record from the backup file, writes it to the value table, and records any read or write errors.  
5. Once all records are processed, it closes both files, logs a final tally of records handled, and exits.  
6. The user reviews the system log (SYS‑DISPLAY.log) to confirm that the restore completed successfully or to investigate any reported issues.  

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins in aa000-Main-Start, performing argument retrieval, setting logging parameters, and printing a header via Call‑Sysout. [Seen in: aa000-Main-Start.]  
It then opens the sequential input file Value‑File‑Seq, handling any open errors, and opens the output file Value‑File, again checking for errors. [Seen in: aa000-Main-Start.]  
After initializing counters, the program enters aa010‑Read‑Recs to read each record from the input file, write it to the output file, and update counters until end‑of‑file or an error occurs, finally proceeding to aa020‑Finish‑Off for cleanup and termination. [Seen in: aa010‑Read‑Recs.]

5.2 Initialization  
The initialization phase in aa000‑Main‑Start performs zz020‑Get‑Program‑Args, sets WS‑Log‑System and WS‑Log‑File‑no, and calls Call‑Sysout to display program information. [Seen in: aa000‑Main‑Start.]  
It then opens Value‑File‑Seq for input, checks FS‑Reply for errors, and if successful opens Value‑File for output, initializing ws‑Rec‑Cnt‑In and ws‑Rec‑Cnt‑Out to zero. [Seen in: aa000‑Main‑Start.]

5.3 Core Processing  
Path: Get‑Program‑Args  
Trigger: Program start  
Key steps: perform zz020‑Get‑Program‑Args  
I/O: none  
Outcomes: program arguments are parsed and stored  
[Seen in: aa000‑Main‑Start.]  

Path: Open‑Input‑File  
Trigger: after header printed  
Key steps: open input Value‑File‑Seq, check FS‑Reply, error handling  
I/O: Value‑File‑Seq  
Outcomes: if error, prints message and gobacks; otherwise proceeds  
[Seen in: aa000‑Main‑Start.]  

Path: Read‑Records‑Loop  
Trigger: after opening output file  
Key steps: perform forever read Value‑File‑Seq, detect end‑of‑file, handle read errors, write to Value‑File, update counters  
I/O: Value‑File‑Seq, Value‑File  
Outcomes: counters incremented, errors cause exit to Finish‑Off  
[Seen in: aa010‑Read‑Recs.]  

Path: Finish‑Off  
Trigger: end of read loop or error  
Key steps: close Value‑File‑Seq and Value‑File, print summary via Call‑Sysout, set Return‑Code to zero, goback  
I/O: Value‑File‑Seq, Value‑File  
Outcomes: program terminates cleanly with zero return code  
[Seen in: aa020‑Finish‑Off.]

5.4 Termination  
The termination sequence in aa020‑Finish‑Off closes both input and output files, prints a summary of records processed, and exits with a zero return code. [Seen in: aa020‑Finish‑Off.]  
The final Call‑Sysout paragraph invokes ACAS‑Sysout to send the accumulated messages to the system display log before the program ends. [Seen in: Call‑Sysout.]

---
## valueUNL
*[265/267]*

### Business/Functional Perspective
### Value File Backup

**Program Purpose**  
This program creates a recoverable backup of the system’s value file by copying each record to a new sequential file named *value.seq*. It guarantees that all current value records are preserved in a format that can be easily restored if the original file becomes corrupted or unavailable. The backup process is essential for maintaining data integrity, supporting audit requirements, and reducing the risk of data loss in the Applewood Accounting System.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
- If the original value file cannot be opened, a log entry notes that there is “No value file to process.”  
- When a record cannot be read, the program logs a problem‑reading message.  
- If writing a record to *value.seq* fails, a write‑error message is recorded.  
- Upon completion, a summary shows the number of records read and written.  
- If required environment variables are missing, the program logs an environment‑setup error.

**User Flow Summary**  
The user initiates the program (typically via a command line or scheduled job). The program attempts to open the source value file. If the file is missing, it writes a notice to the log and exits. Otherwise, it opens the destination sequential file, then reads each record from the source and writes it to the destination, counting how many records are processed. After all records are handled, the program closes both files, logs a final count of input and output records, and terminates. The user can review the *SYS-DISPLAY.log* file to confirm success or to investigate any errors.

**Program Linkages**  
- ACAS‑Sysout

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow  
The program begins by performing argument retrieval and logging setup in paragraph **aa000-Main-Start**. It then opens the source value file for input, checks for open errors, and if successful opens the sequential output file, all within **aa000-Main-Start**. The main processing loop reads each record from the source file, writes it to the sequential file, and handles any read or write errors, as implemented in **aa010-Read-Recs**; upon reaching end‑of‑file or encountering an error the loop exits to **aa020-Finish-Off**. [Seen in: aa000-Main-Start, aa010-Read-Recs, aa020-Finish-Off.]

5.2 Initialization  
The program performs a PERFORM of **zz020-Get-Program-Args** to capture command‑line arguments and sets logging parameters (WS‑Log‑System and WS‑Log‑File‑no) before any file operations. It initializes counters (WS‑Rec‑Cnt‑In and WS‑Rec‑Cnt‑Out) to zero and clears the output buffer **SO‑Print**. File descriptors are opened with **open input Value‑File** and **open output Value‑File‑Seq**; any open‑status errors are reported via **Call‑Sysout** and the program terminates early. [Seen in: aa000-Main-Start, zz020-Get-Program-Args.]

5.3 Core Processing  
Path: Input File Open Error  
Trigger: FS‑Reply not equal to zeros after attempting to open **Value‑File**.  
Key steps: Report error message, close **Value‑File**, log closure, and GOBACK.  
I/O: Value‑File.  
Outcomes: Program exits without processing any records.  
[Seen in: aa000-Main-Start.]

Path: Read Record Error  
Trigger: FS‑Reply not equal to zeros during a READ of **Value‑File**.  
Key steps: Construct error message with SY003 and FS‑Reply, log via **Call‑Sysout**, and exit loop to **aa020‑Finish‑Off**.  
I/O: Value‑File.  
Outcomes: Processing stops; counts reflect only successfully read records.  
[Seen in: aa010-Read-Recs.]

Path: Write Record Error  
Trigger: FS‑Reply not equal to zero after a WRITE to **Value‑File‑Seq**.  
Key steps: Set SO‑Print to SY006, log via **Call‑Sysout**, and exit loop to **aa020‑Finish‑Off**.  
I/O: Value‑File‑Seq.  
Outcomes: Processing stops; output count is one less than input count.  
[Seen in: aa010-Read-Recs.]

Path: End of File  
Trigger: READ of **Value‑File** reaches end‑of‑file.  
Key steps: GO TO **aa020‑Finish‑Off** after completing the loop.  
I/O: Value‑File, Value‑File‑Seq.  
Outcomes: Normal completion; counts of input and output records are logged.  
[Seen in: aa010-Read-Recs, aa020‑Finish‑Off.]

5.4 Termination  
The program closes both the sequential output file and the source value file, logs the closure, sets **Return‑Code** to zero, and performs a GOBACK to terminate. All final status messages are sent through **Call‑Sysout**. [Seen in: aa020‑Finish‑Off.]

---
## xl150
*[266/267]*

### Business/Functional Perspective
### End of Cycle Processing  

**Program Purpose**  
The program consolidates and cleans the accounting data for a given period. It verifies that all proofing, posting and analysis steps have completed, removes outdated invoices and open‑item records, updates sales and purchase ledgers, resets yearly statistics, and clears temporary files. This ensures the books are accurate for reporting, audit and future processing, and protects against data loss or duplication.  

**Screen Interactions**  
1. **Destructive‑Run Warning** –  
   *Title:* “END OF CYCLE PROCESSING”  
   *Displays:* multiple warnings about backup requirements, end‑of‑cycle timing and data readiness.  
   *Input:* a single Y/N response to confirm the run.  
   *Output:* proceeds or aborts the program.  

2. **Pre‑Run Checks** –  
   *Title:* “CHECK FOR Unposted Items”  
   *Displays:* messages for proofed‑but‑not‑posted invoices/payments and missing analysis reports.  
   *Input:* Y/N to continue despite warnings.  
   *Output:* if “N” the program exits; if “Y” it proceeds.  

3. **Ledger Selection** –  
   *Title:* “RUN Sales / Purchase Ledgers?”  
   *Displays:* prompts “Do you wish to run Sales Ledger? (Y/N)” and “Do you wish to run Purchase Ledger? (Y/N)”.  
   *Input:* Y/N responses for each ledger.  
   *Output:* the program processes only the selected ledgers.  

4. **Quarter‑End Confirmation** –  
   *Title:* “END OF QUARTER?”  
   *Displays:* “Is this the end of a quarter (Y/N) – [ ]” (only shown when running from a stand‑alone context).  
   *Input:* Y/N.  
   *Output:* updates quarter and year counters or exits if “N”.  

**Messages and Errors**  
- **Destructive Warning** – “THIS PROGRAM IS DESTRUCTIVE – ENSURE BACKUP FIRST”.  
- **Unposted Issues** – Alerts for invoices or payments that have been proofed but not posted, and for missing analysis reports.  
- **Quarter/Year Checks** – Confirmation required to mark the period as a quarter or year end.  
- **File Access Errors** – Generic messages when a required file cannot be opened, read, written, or deleted.  
- **Data Integrity Alerts** – Notices if invoices are out‑of‑date, if open items are closed, or if value data needs resetting at year end.  
- **Abort Prompt** – After any error or user‑declared stop, the program exits cleanly.  

**User Flow Summary**  
The user initiates the program (either manually or via a scheduled task). The system first presents a warning screen confirming the destructive nature of the run. Upon confirmation, the program checks that all preceding proofing, posting, and analysis steps have completed; if any items are pending, it displays the relevant warnings and asks whether to proceed. The user then chooses which ledgers (Sales, Purchase, or both) to process. If running in a stand‑alone mode, the program also asks whether the current period is a quarter end. The program then executes a series of cleanup and update steps: it rewrites ledgers, removes closed invoices and open items, resets yearly values, and clears temporary files. Throughout the run, status messages keep the user informed of progress. Finally, the program terminates, leaving the accounting data ready for the next period or for reporting.  

**Program Linkages**  
- maps04  
- WS-caller

### Technical/Migration Perspective
5. Processing Logic

5.1 High‑Level Flow  
Program starts at aa00‑Main Section, performing argument parsing and environment setup. [Seen in: aa00‑Main Section.]  
It then checks for auto‑run or interactive mode, displays warnings if necessary, and verifies that prerequisite reports have been run. [Seen in: aa015‑Recheck‑for‑Issues.]  
After user confirmation or auto‑run, it determines which ledgers to process, performs sales and purchase end‑of‑cycle processing, and then exits. [Seen in: aa040‑Display‑End.]

5.2 Initialization  
The program obtains command‑line arguments, sets screen exception flags, and converts the current date to the required format. [Seen in: aa010‑Acpt‑Reply, zz070‑Convert‑Date.]  
It opens necessary files, checks for the presence of OTM files, and sets flags for sales and purchase processing. [Seen in: aa025‑OTM‑Checks.]

5.3 Core Processing  

Path: Auto‑run  
Trigger: function lower‑case (WS‑CD‑Args (1:5)) = "xl150"  
Key steps: skip warning display, perform recheck for issues, request ledgers, test end‑of‑cycle, OTM checks, display heads, display end, process sales and purchase, exit.  
I/O: sales ledger, purchase ledger, OTM3, OTM5, invoice files, value file.  
Outcomes: updates ledgers, deletes closed records, resets values, sets flags.  
[Seen in: aa015‑Recheck‑for‑Issues.]

Path: Menu Dispatch  
Trigger: function lower‑case (WS‑CD‑Args (1:5)) not = "xl150" leading to warning display and user confirmation.  
Key steps: display warnings, accept reply, recheck issues, request ledgers, test EoC, OTM checks, display heads, display end, process sales and purchase, exit.  
I/O: sales ledger, purchase ledger, OTM3, OTM5, invoice files, value file.  
Outcomes: same as auto‑run.  
[Seen in: aa020‑Request‑Ledgers.]

Path: Sales Processing  
Trigger: SL‑EoC = 1  
Key steps: AB00‑SL‑Processing phases: read ledger, update stats, rewrite, process OTM3 and invoices, delete closed invoices, reset values, reset system counters.  
I/O: sales ledger file, OTM3 file, invoice file, value file.  
Outcomes: ledger stats updated, closed invoices removed, value data reset.  
[Seen in: AB00‑SL‑Processing.]

Path: Purchase Processing  
Trigger: PL‑EoC = 1  
Key steps: AC00‑PL‑Processing phases: read ledger, update stats, rewrite, process OTM5 and invoices, delete closed invoices, reset values, reset system counters.  
I/O: purchase ledger file, OTM5 file, invoice file, value file.  
Outcomes: ledger stats updated, closed invoices removed, value data reset.  
[Seen in: AC00‑PL‑Processing.]

Path: End‑of‑Year Cleanup  
Trigger: New‑Year = 1  
Key steps: BA00‑Value‑Reset clears all value records or deletes them, displays count.  
I/O: value file.  
Outcomes: value data cleared.  
[Seen in: BA00‑Value‑Reset.]

5.4 Termination  
Upon completion of all processing, the program sets any required end‑cycle flags and performs a GOBACK. [Seen in: aa970‑Menu‑Exit.]  
If any file error occurs during processing, the program jumps to aa991‑File‑Error‑Exit and returns with an error code. [Seen in: aa991‑File‑Error‑Exit.]

---
## xl160
*[267/267]*

### Business/Functional Perspective
### ISAM File Backup and Restore

**Program Purpose**  
This program helps the accounting system keep its data files safe and consistent. It backs up all COBOL ISAM files by converting them to sequential files, and it can also restore the data back into ISAM format when needed. The operation is performed only when the system is not using the RDB processing mode, ensuring that the backup or restore does not interfere with the current database environment. The tool supports compliance and audit requirements by preserving a clean, recoverable copy of every file.

**Screen Interactions**  
No direct screens. This program is used after a separate data‑entry step and returns results back to that context.

**Messages and Errors**  
The program may inform the user of any of the following conditions:  
- Problems opening or writing to the backup files.  
- Failure to restore a file from its sequential backup.  
- Inability to proceed because the system is currently configured for RDB processing.  
- General completion or cancellation messages indicating that the backup or restore has finished or was stopped.

**User Flow Summary**  
A user initiates the program (typically through a menu or command line). The system verifies that the current configuration allows backup or restore operations. It then scans all COBOL ISAM files, copying each to a sequential backup file or, if restoring, reading each sequential file and writing its contents back into the original ISAM structure. During the process, the user may see simple status updates, such as “File X backed up” or “File Y restored.” Once all files are processed, a final message indicates success or lists any failures that occurred.

**Program Linkages**  
- No external program calls.

### Technical/Migration Perspective
5. Processing Logic

5.1 High-Level Flow
N/A. [Seen in: Procedure-division.]
N/A. [Seen in: Procedure-division.]
N/A. [Seen in: Procedure-division.]

5.2 Initialization
N/A. [Seen in: Procedure-division.]
N/A. [Seen in: Procedure-division.]

5.3 Core Processing
Path: No Processing Paths
Trigger: N/A
Key steps: N/A
I/O: N/A
Outcomes: N/A
[Seen in: Procedure-division.]

5.4 Termination
N/A. [Seen in: Procedure-division.]
N/A. [Seen in: Procedure-division.]

---

## Document Statistics

- **Total Programs**: 267
- **Generated**: 2025-09-24 07:40:22
- **Database**: erp_cobol
- **Table**: cobol_documentation
- **Programs with Functional Documentation**: 267
- **Programs with Technical Documentation**: 267
- **Programs with Both Types**: 267
